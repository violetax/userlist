#Five Minute React 01 - Installing Sublime Text

<p>This is a test</p>
<div id="testing" class="border-black">this is a div tag</div>
<span class="testme">so much testing</span>

cd  ~

nano .bash_profile

alias subl="open -a /Applications/Sublime\ Text.app"

.Hit ctrl-X (not cmd-X) and say yes when it asks if you want to save the file
.Then either restart your terminal or type:

source ~/.bash_profile

source ~/.zshrc

subl

.C:/program files/sublime text 3/

subl
#Five Minute React 02 - Configuring Sublime Text

.So first we hit cmd-shift-p in Sublime Text to bring up the command palette (in Windows it’s ctrl-shift-p), and quickly search for “install package” … which will be the first choice by about the time you’ve typed “inst.” By the way, the command palette is awesome and incredibly functional
.You could write an entire tutorial on using it, and in fact, Wes Bos did just that in his excellent Sublime Text Power User tutorial set, which includes a book and about two dozen videos
.Anyway, click on “install package”—there’s a few second wait as it loads all of the possible packages—and then type “babel” to bring up a list of matching packages
.The one we want is Babel - Syntax definitions for ES6 JavaScript with React JSX Extensions
.Just click to install
.No need to restart Sublime or anything, although you might have to re-open any JSX files you already have open (which is probably none), or manually switch them to “Babel – JavaScript” using the syntax switcher at the bottom right.

.We’re going to need a bit more syntax highlighting
.We’ll be using Sass in this tutorial to establish a basic CSS skeleton
.Sublime doesn’t support it natively, so back we go with cmd-shift-p, install, and then type “sass”
.You want the one named, well, Sass There are also full build systems for Sass that incorporate with Sublime, but we’re going to eschew those in favor of bundling everything with Webpack
.More on that in a later tutorial.

.First you'll need SublimeLinter itself, so ht cmd-shift-p, choose install packages, and type "SublimeLinter"
.Click to install, and let's add a specific plugin for ESlint
.Back to the command palette once more with cmd-shift-p, then choose install packages, then type “eslint” and find SublimeLinter-eslint
.Click it, let it install, and you’re good to go.

#Five Minute React 03 - Installing Node

/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"

brew update

.into your terminal (all Homebrew commands use the brew blah blah syntax)
.There’s some other great stuff you can do with Homebrew, like checking for outdated software and auto-upgrading it, but since we’re installing fresh right now, we’ll leave that alone.

brew install nvm

cd ~
mkdir $HOME/.nvm

export NVM_DIR="$HOME/.nvm"
\. "/usr/local/opt/nvm/nvm.sh"

nvm

nvm install v8.11.1

nvm install v9.9.0

nvm ls

to see what you’ve installed (and nvm ls-remote to see a gigantic list of all of the versions available to you, most of which you will never need or want). As you can see, we’ve got 8.11.1 and 9.9.0, but we’re using 9.9.0 (because it was the last one we installed) … let’s switch to the LTS version, by typing

nvm use v8.11.1

console.log(‘hello world’);

5+5

.I think that makes sense, and it means that NVM-Windows doesn’t need to be updated to match new versions of Node, it can just add them to the list and let users install them
.So, let’s get it up and running on our machine
.Head for https://github.com/coreybutler/nvm-windows, click the releases tab, and grab nvm-setup.zip for the latest release (I'd avoid pre-releases, but you can go for it if you want!).

nvm

.and hit enter to make sure the program installed correctly
.It should give you a list of commands
.For right now, we’re most interested in nvm list, nvm use, and nvm install
.Let’s start by typing

nvm list available

nvm install v8.11.1

nvm install v9.9.0

nvm list

nvm use 8.11.1

nvm list

nvm use v8.11.1

console.log(‘hello world’);

5+5

#Five Minute React 04 - Package Control

brew update && brew install npm

export PATH="$PATH:`npm -g bin`"

$ npm init

.Licensing is outside the scope of this tutorial, but you’re unlikely to be distributing this slightly-more-than-hello-world application to anyone, so I’d just hit enter and accept the default MIT license
.This just governs the permissions you’re giving, telling whether people can or cannot modify and distribute your code
.Again, you’re not likely to ever be distributing this, so it doesn’t really matter
."Private" adds a private: true flag to your package.json, which keeps NPM from publishing it on their site should you register your application in their database, which you won't be doing
.Doesn't really matter what you choose.

.That’s it
.Assuming you got “success Saved package.json,” you’re good to … if you got something else, that’s problematic
.Try running npm init again.

{
  "name": "YarnTest",
  "version": "0.0.1",
  "description": "index.js",
  "author": "Christopher Buecheler",
  "license": "MIT"
}

$ npm add map-reverse

subl index.js

{
  "name": "YarnTest",
  "version": "0.0.1",
  "description": "index.js",
  "author": "Christopher Buecheler",
  "license": "MIT",
  "dependencies": {
    "map-reverse": "^1.0.1"
  }
}

#Five Minute React 05 - Using Node Modules

const userNames = [
  'cwbuecheler',
  'bort',
  'captaincode',
  'hotpants6969',
  'kelly',
  'steve',
  'starlord'
];

.Nothing unusual there, but you might notice that we’re using const and not var
.That’s because Node 8.10.0 fully supports ES2015, so we’re going with the new variable declaration syntax of const for variables that don’t change, and let for variables that do
.If you need help with ES2015 (aka ES6), I absolutely recommend checking out Wes Bos’s ES6 For Everyone course
.He goes through all of the new features in detail
.I’ll be explaining a bit as I go along, but for a more thorough grounding, definitely give his stuff a look.

.Now let’s use Array.map to convert those usernames to uppercase
.In case you need a refresh, Array.map runs through every item in an array and executes a function through which you can manipulate that item, and generates a whole new array from the results
.Here’s the code:

// Use map to generate an array of uppercase usernames
const userNamesUp = userNames.map(name => {
  return name.toUpperCase();
});

.OK, there’s some more ES2015 stuff here
.Another const since once we define the value of userNamesUp, we’re never changing it
.Also our first “arrow function” of this series, which you’re going to see a lot, especially once we hit React development
.The code above is functionally equivalent to a regular JavaScript anonymous function like this:

const userNamesUp= userNames.map(function(name) {
  return name.toUpperCase();
});

.It’s just slightly more concise
.Arrow functions also handle how this is scoped somewhat differently, but that’s not relevant here
.For more info, again, check out that Wes Bos course
.You can also read up on arrow functions at a variety of places on the web, including, of course, Mozilla’s Developer Network.

.Now that we’ve got our map function in, let’s write a quick for loop to run through our brand new array of uppercased names and console.log them
.Three lines, here we go:

for (let i = 0; i < userNamesUp.length; i++) {
  console.log(userNamesUp [i]);
}

node index.js

.CWBUECHELER
.BORT
.CAPTAINCODE
.HOTPANTS6969
.KELLY
.STEVE
.STARLORD

and be returned to your command prompt. You’ve successfully mapped an array and then output the results. Nice job. Note that if you were to change those final lines to use userNames instead of userNamesUp, you’d get the original, non-capitalized list. This is because Array.map is non-destructive. It doesn’t overwrite the array on which you use it, but rather generates a brand new one.

let mapReverse = require('map-reverse');

import mapReverse from 'map-reverse';

let mapReverse = require('map-reverse');

.Now that we have mapReverse, let’s use it
.At the bottom of index.js, type the following:

const userNamesUpRev = mapReverse(userNames, name => {
  return name.toUpperCase();
});

const userNamesUpRev = mapReverse(userNames, function(name) {
  return name.toUpperCase();
});

console.log('--------------');
for (let i = 0; i < userNamesUpRev.length; i++) {
  console.log(userNamesUpRev[i]);
}

.We can use i again as an iterator because of the way JavaScript scope works
.The variable i only exists while each for loop is running.

node index.js

.CWBUECHELER
.BORT
.CAPTAINCODE
.HOTPANTS6969
.KELLY
.STEVE
.STARLORD
--------------
.STARLORD
.STEVE
.KELLY
.HOTPANTS6969
.CAPTAINCODE
.BORT
.CWBUECHELER

#Five Minute React 06 - Installing MongoDB

brew update && brew install mongodb

.This will, just like when we installed Yarn a couple tutorials ago, make sure that Homebrew has the most up to date list of packages, and then install the MongoDB package
.Let it run, and … you’ve got MongoDB
.Now we need to make a directory in which to store our data
.MongoDB’s default is /data/db … and that’s fine by me if you want to use it
.I’m going to put it somewhere else though, mostly so I can show you how to make the necessary edits to make Mongo work with the new directory
.So let’s put our data in our home directory, instead of at the top level
.First, in our terminal, we need to type:

mkdir -p  ~/data/db

and hit enter. Now you need to edit Mongo’s config file. It’s in /usr/local/etc/mongod.conf – the reason there's a D in "mongod" is because it stands for daemon (the server kind).

subl /usr/local/etc/mongod.conf

systemLog:
  destination: file
  path: /usr/local/var/log/mongodb/mongo.log
  logAppend: true
storage:
  dbPath: /usr/local/var/mongodb
net:
  bindIp: 127.0.0.1

#systemLog:
#  destination: file
#  path: /usr/local/var/log/mongodb/mongo.log
#  logAppend: true

.Now we need to work with that dbPath setting
.Delete what’s there and replace it with /Users/YOURUSERNAME/data/db

.Note that, obviously, YOURUSERNAME needs to be replaced with your user name, unless your username is, in fact, “yourusername” … which would be really weird
.My username on my MacBook is “chris” so my config looks like:

dbPath: /Users/chris/data/db

.You might also be wondering why it is that, if the config file was originally set to /usr/local/var/mongodb, it doesn’t by default use that folder for storing data
.Well, that’s because Mongo doesn’t read that config file unless you tell it to (Homebrew generates the file when you install MongoDB)
.So let’s deal with that by launching the Mongo daemon
.There are two ways to go about this: as a one-off launch, and as a service
.The former means that every time you restart your Mac (or even just kill the terminal in which Mongo is running), you’ll have to restart MongoDB
.The latter means that MongoDB runs in the background, and will spin up automatically every time you restart
.Obviously, you want the latter for your server, but for our local machines let’s stick with the running it manually every time, for now.

mongod

mongod --config /usr/local/etc/mongod.conf

brew services start mongodb --config /usr/local/etc/mongod.conf

.C:\Program Files\MongoDB\Server\3.6\bin\

.Now, we need to decide where we’re going to store our data
.By default, MongoDB will look in \data\db on the same drive on which the program is installed (in this instance, C)
.That’s fine, but for the purposes of showing how to use custom folders, I’m going to go with C:\mongo\data\db\ instead
.So open A command prompt, head for C:\ and then type:

md mongo\data\db.

mongod  --dbpath c:\mongo\data\db

mongod

and hitting enter. There it goes, spinning up and waiting for connections, which we’ll talk about more in the next tutorial. For now, you’re done, unless you’d like to register Mongo as a Windows service that runs in the background whenever you start your machine. To do that, you’ll first need to create a config file, which for the purposes of this tutorial we’ll store in C:\mongo, but you can put it wherever you like. Your config file should be named mongod.cfg and should look like this:

systemLog:
    destination: file
    path: c:\mongo\mongod.log
storage:
    dbPath: c:\mongo\data\db

mongod --config "C:\mongo\mongod.cfg" -install

#Five Minute React 07 - Using MongoDB

.In your new terminal window, the one not running mongod, just type mongo
.No D on the end, no config stuff, just the word mongo
.This will launch the MongoDB console, which allows you to interact with the database (which is being run by the daemon)
.You’ll get a few basic pieces of information – including a warning about this database being accessible without access control, ie: a username and password authentication system being enabled
.Never fear, mongo console, we will absolutely enable access control before we start producing code intended for live servers
.For right now, we’re just messing around.

show dbs

use musiclist

.You’ll see the console report that it’s switched to using a new db called musiclist – but if you repeat the show dbs command, you won’t see musiclist in the resulting output
.This is because Mongo doesn’t actually create the database until you put some data into it.

db.users.insert({ fullName: 'John Smith', email: 'johnsmith@testemail.com' });

.WriteResult({ "nInserted" : 1 })

show dbs

db

show collections

db.users.find();

{ "_id" : ObjectId("58d17a14f52141ed54476589"), "fullName" : "John Smith", "email" : "johnsmith@testemail.com" }

db.users.find().pretty();

{
        "_id" : ObjectId("58d17a14f52141ed54476589"),
        "fullName" : "John Smith",
        "email" : "johnsmith@testemail.com"
}

.A big improvement! Note that MongoDB generated its own unique ID for our user
.It’ll do this for any object you add to any collection
.You can override the value manually if for some reason you think it’s a good idea, but I wouldn’t recommend it – you’ll be stepping on lots of functionality that proves really useful down the road
.If you really want to add your own id for tracking purposes, consider a separate key/value pair like musiclistID: 12345 or similar.

.Let’s add a few more users
.We don’t have to do this with multiple db.users.insert() statements
.We can stick multiple user objects into that one statement by putting them into an array
.I like to start in a text editor and then paste into the console, so let’s open Sublime and enter the following:

db.users.insert([
  {
    fullName: 'Jane Doe',
    email: 'janedoe@testemail.com'
  },
  {
    fullName: 'Leslie Tanner',
    email: 'leslietanner@testemail.com'
  }
]);

.BulkWriteResult({
        "writeErrors" : [ ],
        "writeConcernErrors" : [ ],
        "nInserted" : 2,
        "nUpserted" : 0,
        "nMatched" : 0,
        "nModified" : 0,
        "nRemoved" : 0,
        "upserted" : [ ]
})

db.users.find().pretty();

{
        "_id" : ObjectId("58d3c77d20ab241a7845c2fc"),
        "fullName" : "John Smith",
        "email" : "johnsmith@testemail.com"
}
{
        "_id" : ObjectId("58d3c78620ab241a7845c2fd"),
        "fullName" : "Jane Doe",
        "email" : "janedoe@testemail.com"
}
{
        "_id" : ObjectId("58d3c78620ab241a7845c2fe"),
        "fullName" : "Leslie Tanner",
        "email" : "leslietanner@testemail.com"
}

db.users.updateOne(
  { fullName: 'Jane Doe' },
  { $set: { email : 'janeycakes@burnermail.com' } }
);

{ "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 }

db.users.remove({ fullName: 'Leslie Tanner' });

.WriteResult({ "nRemoved" : 1 })

db.users.find().pretty();

{
        "_id" : ObjectId("58d3c77d20ab241a7845c2fc"),
        "fullName" : "John Smith",
        "email" : "johnsmith@testemail.com"
}
{
        "_id" : ObjectId("58d3c78620ab241a7845c2fd"),
        "fullName" : "Jane Doe",
        "email" : "janeycakes@burnermail.com"
}

#Five Minute React 08 - Version Control Part 1

git

#Five Minute React 09 - Version Control Part 2

mkdir -p ~/web/musiclist

.Now we need to set up our directory to talk to GitHub
.For that, we need the GitHub URL from which to clone the repository
.You can find this by going to the top level page of the repository you created in GitHub, and clicking the green “Clone or Download” button in the upper right
.Copy the URL and then switch back to your terminal
.Change directories to ~/web/ or wherever you’re storing your musiclist folder
.Then type the following:

git clone [paste your URL here] musiclist

.Touch test.html

subl test.html

<html>
  <head>
    <title>Testing!</title>
  </head>
  <body>
    <h1>This is a Test</h1>
    <p>
      We just need something to commit to the GitHub repo.
    </p>
  </body>
</html>

subl README.md

.This is a change to an existing file.

git status

git add README.md
git add test.html

git add -A

git status

git commit -m "first change"

that -m lets us add a message to the commit. I try to go with useful message such as “adding an about page and styling it up.” Also cool: you can reference GitHub issue numbers and other GitHub data here, by typing something like “fixes issue #9 by keeping the user logged in on static pages” and the commit will be referenced on that issue’s page. Nice!

git push

#Five Minute React 10 - Installing Express

$ npm -g add express-generator@4.15.5

.It’ll do its thing
.After that, it’s time to install the actual webserver
.By the way, if you still have that test.html file in your /musiclist folder you can go ahead and delete it
.We won’t be using it
.Change to whatever directory is holding /musiclist (in my case, ~/web) and type the following:

express -v ejs -f musiclist

<ul>
  <% for(var i = 0; i < supplies.length; i++) {%>
    <li><%= supplies[i] %></li>
  <% } %>
</ul>

$ npm start

$ npm start

$ npm

$ npm start

#Five Minute React 11 - Intro to Express Part 1

$ npm start

node ./bin/www

var express = require('express');
var path = require('path');
var favicon = require('serve-favicon');
var logger = require('morgan');
var cookieParser = require('cookie-parser');
var bodyParser = require('body-parser');

var index = require('./routes/index');
var users = require('./routes/users');

var app = express();

app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'ejs');

app.use(logger('dev'));
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: false }));
app.use(cookieParser());
app.use(express.static(path.join(__dirname, 'public')));

app.use('/', index);
app.use('/users', users);

app.use(function(req, res, next) {
  var err = new Error('Not Found');
  err.status = 404;
  next(err);
});

app.use(function(err, req, res, next) {
  // set locals, only providing error in development
  res.locals.message = err.message;
  res.locals.error = req.app.get('env') === 'development' ? err : {};

  // render the error page
  res.status(err.status || 500);
  res.render('error');
});

module.exports = app;

#Five Minute React 12 - Intro to Express Part 2

$ npm start

in the /musiclist directory.

.Let’s start by opening /bin/www
.Don’t let the use of /bin fool you: this is not a binary file, but rather a simple text file containing some information our Express server uses to start up
.We’re not going to spend much time on this file, because we’re not going to touch anything in it
.You could manually edit the port your server runs on here, but it’s better to set it as an environment variable, which is referenced on line 15 by process.env.PORT
.I won’t be talking about how to set environment variables until a later tutorial, so if you really don’t want to use 3000, go ahead and change the number on that same line and save the file
.Note: you will have to restart your server by hitting cmd-or-ctrl-c and then re-typing npm start if you make any changes here.

.Close this file and let’s look at the /public directory
.This folder contains three sub-folders, images, javascripts, and stylesheets
.The images folder is empty, the javascripts folder is empty, and the stylesheets folder contains a very basic CSS file that we’re going to be nuking when we set up our MusicList CSS.

.All right, let’s move on to /routes
.This is an important folder – it holds the files that contain middleware functionality that’s called when you hit a particular route that’s defined in app.js
.These functions let you access data in the request, prepare the response, and return it to the browser
.Open index.js and take a look.

const express = require('express');
const router = express.Router();

/* GET home page. */
router.get('/', (req, res, next) => {
  res.render('index', { title: 'Express' });
});

module.exports = router;

.It’s short and to the point: it pulls in Express and router functionality via a couple of requires, then jumps right to responding to an HTTP GET at the top level by running a function that renders a view.

.Just to clarify a bit, see that res.render on line 6? That’s saying “Render the index view in our views folder, and include a local variable called title, with the value of ‘Express.’” – that res.render ends the sequence, which you can also tell because the next() function is never called
.We’ll work more with these routes in coming tutorials.

.Let’s open the corresponding view right now
.We want /views/index.ejs, which is another short and simple file.

<!DOCTYPE html>
<html>
  <head>
    <title><%= title %></title>
    <link rel='stylesheet' href='/stylesheets/style.css' />
  </head>
  <body>
    <h1><%= title %></h1>
    <p>Welcome to <%= title %></p>
  </body>
</html>

    <p>
      <% var randomNumber = Math.floor(Math.random() * 100) + 1; %>
      <%= randomNumber %>
    </p>

.Now switch back to index.js in /routes for a second
.Remember that local variable being set, called title, with a value of Express? … well, let’s change that to MusicList and see what happens when we refresh the page.

.The answer is “nothing” … well, not nothing, since we’re seeing our random number now, but the reason the title didn’t change is because the Express server doesn’t recognize changes to .js files without a restart
.This can be tedious, and in a couple tutorials we’ll be installing an app called Nodemon which auto-detects changes and restarts the server when they happen, but for now just kill and restart
.Now when we refresh, we see that the new value in our title variable is showing, along with our random number
.Hooray!

/routes/users.js is basically the same as index.js, except instead of rendering a view it just responds with plain text. I suggest deleting this file, along with the lines referencing it in app.js. We’re going to be organizing things a little differently.

/views/error.js is a simple view that gets returned by the error middleware in app.js, which we covered in the last tutorial. I’d leave it for now, since it’s handy for displaying stack traces. If you want to see it in action, just try to navigate to a page you know isn’t there, and you can see the 404 error it prints out.

.We’re all set here
.In the next tutorial, we’re going to talk more about Express routes, and how to string multiple actions together using that next() function that Express provides
.See you there!

#Five Minute React 13 - Express Routing

.So, right, the code … let’s open /app.js and take a look at line 24:

app.use('/', index);

.This is telling our app that when a user sends any HTTP request to the top level of the site, it should use our “index” router
.That means the router should be prepared to handle any traffic we expect
.For our index, that’s only GET … we’re not going to be POSTing, PUTting, or DELETEing anything at the top level
.So, back to /routes/index.js, and look at line 5:

router.get('/', function(req, res, next) {

.This is specifically saying “if a browsers sends an HTTP GET request to the top level, run the following function,” and then providing a function that renders /views/index.ejs with a local variable set, as we covered previously.

.For a web page, that’s great
.We want to render views and send back the resulting HTML, and we’ll be using /views/index.ejs as the entry point into our React app
.For an API, though, we don’t want to send back HTML
.We want to send back JSON
.So we’re going to build a test function to do that
.But first, very quickly, let’s convert this file to ES6 (we’ll do app.js shortly, for consistency)
.All that requires is changing the file to look like this:

const express = require('express');
const router = express.Router();

/* GET home page. */
router.get('/', (req, res, next) => {
  res.render('index', { title: 'Express' });
});

module.exports = router;

const testJSON = [
  {
    name: 'John Smith',
    username: 'CaptainCode'
  },
  {
    name: 'Jane Doe',
    username: 'JaneyCakes'
  }
];

router.get('/sendjson', (req, res, next) => {
  res.json(testJSON)
});

.OK, save the file, and then start (or restart, if it was already running) our node server
.Then navigate to localhost:3000/sendjson

#Five Minute React 14 - Express Cleanup and API Setup

.First part’s easy
.We’re going to go through and change our vars to const and let … actually, entirely const in this case
.Let’s do that
.I like to just multi-select in Sublime by selecting the first instance of var; and then using cmd-or-ctrl-D
.Then you just type const once, and every instance you've selected changes to const
.Now, you may be wondering why line 28 is a const even though we’re adding something to the object on line 29
.The reason for this is because const objects are only immutable—which means they can’t be changed—at the top level
.For example, you can’t say:

const user = {
   name: 'Joe Smith',
   age: 24
}

user = {
  name: 'Ted Smith',
  age: 36
}

user.name = 'Ted Smith';
user.age = '36';

.A quick side-note about const and let … they have different scope than var, and there are occasions where we will still want to use var
.For example, this code:

var userCount = 650;
if (user.isNew() === true) {
  var userCount = 651;
}

wouldn't work because var's scope falls through into the if block, so you'd get an error about assigning the variable twice. This code would work:

let userCount = 650;
if (user.isNew() === true) {
  let userCount = 651;
}

.However it's important to understand that despite having the same name, those are two different variables
.Outside of that if block, if you console.log userCount, you'd get 650
.Inside it, you'd get 651
.This is important to understand, and also hammers home why you'd want to be careful with variable names, because things can get confusing.

.All right, let's convert the two functions in this file to arrow functions
.Again, we're not messing with the scope of this in these functions, so we don't have to convert them, but my feeling is that in general the best way to learn this stuff is to see it a lot and work with it a lot
.Helps drill it into your brain
.Or at least, that's what works for me.

app.use((req, res, next) => {

app.use((err, req, res, next) => {

$ npm -g add nodemon

nodemon npm start

.All right, let's configure our API directory
.This doesn't really involve much up front
.We're doing it here more to show how to add a route in Express than because it's a necessary step
.So, first off, make an api folder as a subdirectory of your routes directory
.There's about a hundred ways to do this
.I'm just going to use Sublime
.Then I'm going to make a new file in /api called index.js
.In this file, we'll want to start with three lines that will be in all of our route files:

const express = require('express');
const router = express.Router();

module.exports = router;

router.get('/', (req, res, next) => {
  res.json({ text: 'MusicList API Test' });
});

const index = require('./routes/index');

const api = require('./routes/api/index');

app.use('/', index);

app.use('/api', api);

.Save the file and we're done
.Our API is connected to the app and ready for testing
.Of course, we've only built a single HTTP GET response, but that's fine for now
.We'll also want to eventually lock the API down so its only accessible by MusicList, and not the general public, but that's another tutorial
.For now, let's go check out API response by navigating to localhost:3000/api

#Five Minute React 15 - Git Branching

.So, real quick, open /routes/index.js, which should look like this:

const express = require('express');
const router = express.Router();

/* GET home page. */
router.get('/', (req, res, next) => {
  res.render('index', { title: 'MusicList Alpha' });
});

const testJSON = [
  {
    name: 'John Smith',
    username: 'CaptainCode'
  },
  {
    name: 'Jane Doe',
    username: 'JaneyCakes'
  }
];

router.get('/sendjson', (req, res, next) => {
  res.json(testJSON)
});

module.exports = router;

const express = require('express');
const router = express.Router();

/* GET home page. */
router.get('/', (req, res, next) => {
  res.render('index', { title: 'MusicList Alpha' });
});

module.exports = router;

.Then open /routes/api/index.js, which should look like this:

const express = require('express');
const router = express.Router();

router.get('/', (req, res, next) => {
  res.json({ text: 'MusicList API Test' });
});

module.exports = router;

const express = require('express');
const router = express.Router();

module.exports = router;

.That should do it for cleanup, unless you still have that test.html file sitting in your top level directory
.If so, delete that, too! All right, we’re looking good
.Before we make any further code changes, let’s commit our code to our repository
.We can do this by switching to a terminal or command prompt, changing to our musiclist directory, and typing the following:

git status

git branch develop

git branch

git checkout develop

git push -u origin develop

git add -A

git commit -m "Initial Express scaffolding"

git push

git add -A
git commit -m "commit summary"
git push

#Five Minute React 16 - Data Modeling

{
  "username": "CaptainCode",
  "fullName": "Sarah Thompson",
  "details": {
    "age": 29,
    "isAdmin": true
  }
}

{
  "username": "LordHighAdmiralFluffball",
  "fullName": "Bill Jacobs",
  "age": 25,
  "isAdmin": true
}

$ npm add mongoose@5.0.4

.Whew
.That was a tough one, but we got through it, somehow, together, and now we’ve got mongoose installed (and Yarn automatically added it to our package.json)
.Now we need to tell our app to actually use Mongoose
.So, open /app.js, find this line:

const bodyParser = require('body-parser');

const mongoose = require('mongoose');

const app = express();

// Connect Mongoose
mongoose.connect('mongodb://localhost/musiclist');

.Let’s model that out
.First, create a directory at the top level of your project called models – you can use mkdir for this if you want
.I’m lazy and am just going to right-click in Sublime
.Since this is a small application, I’m not going to bother with subdirectories here, but you totally could if you wanted
.Instead, let’s just create a file called user.js
.I’m going to give you all of the code here, but I strongly encourage you to type it out by hand, rather than copy-pasting
.Trust me: you learn way more by doing that, especially if you mistype something and then have to fix it.

const mongoose = require('mongoose');
const Schema = mongoose.Schema;

const User = new Schema({
    username: String,
    password: String,
    firstName: String,
    lastName: String
});

module.exports = mongoose.model('User', User);

#Five Minute React 17 - Installing Passport

.So, let’s get going
.We’re going to need a couple of different dependencies, so instead of npm adding each of them, let’s edit package.json, add them there, and then do one yarn to install them
.Your package.json should currently look like this:

{
  "name": "musiclist",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "start": "node ./bin/www"
  },
  "dependencies": {
    "body-parser": "~1.18.2",
    "cookie-parser": "~1.4.3",
    "debug": "~2.6.9",
    "ejs": "~2.5.7",
    "express": "~4.15.5",
    "mongoose": "5.0.4",
    "morgan": "~1.9.0",
    "serve-favicon": "~2.4.5"
  }
}

"express-session": "1.10.1",

"passport": "0.3.2",
"passport-local": "1.0.0",
"passport-local-mongoose": "4.0.0",

$ npm

.That’s it
.Hit enter, and Yarn will run through your package.json and install any packages that it hasn’t already installed
.That means the four we just added
.Excellent
.Now let’s tie them into Express
.Open up /app.js and just below the line where we require mongoose (line 7, to be specific), add the following code:

const passport = require('passport');
const LocalStrategy = require('passport-local').Strategy;

.This is bringing in Passport and also a “Strategy” constructor from Passport-Local, which is an approach for connecting Express to our authentication setup
.Now find the big block of app.use lines starting on line 24
.Right under the cookie parser bit on line 29, add the following:

app.use(require('express-session')({
  secret: 'any random string can go here',
  resave: false,
  saveUninitialized: false
}));
app.use(passport.initialize());
app.use(passport.session());

// Configure Passport
const User = require('./models/user');
passport.use(new LocalStrategy(User.authenticate()));
passport.serializeUser(User.serializeUser());
passport.deserializeUser(User.deserializeUser());

.Hey, look at that … we’re using our User model! However, in order for our user model to be, uh, used, we need to change it a bit
.We’re done with app.js so save that file and open /models/user.js, then add the following code after the top two lines:

const passportLocalMongoose = require('passport-local-mongoose');

.User.plugin(passportLocalMongoose);

  password: string,

const mongoose = require('mongoose');
const Schema = mongoose.Schema;
const passportLocalMongoose = require('passport-local-mongoose');

const User = new Schema({
  username: String,
  firstName: String,
  lastName: String
});

.User.plugin(passportLocalMongoose);

module.exports = mongoose.model('User', User);

.Nodemon Yarn Start

.Assuming your server starts with no errors, refresh localhost:3000 to make sure we still have our “Welcome to MusicList” text (and our goofy random number).

#Five Minute React 18 - Setting Up Testing

$ npm add jest@19.0.2 --dev

$ npm add supertest@3.0.0 --dev

mongo

use musiclist

db.users.deleteMany({});

{ "acknowledged" : true, "deletedCount" : 2 }

db.users.insert({ "username": "administrator", firstName: "YOUR FIRST NAME", "lastName": "YOUR LAST NAME" });

.WriteResult({ "nInserted" : 1 })

db.users.find().pretty()

{
  "_id" : ObjectId("590b5a89ccdfaa7c64e19746"),
  "username" : "administrator",
  "firstName" : "Christopher",
  "lastName" : "Buecheler"
}

#Five Minute React 19 - Testing With Jest

getData()
  .then(data => {
    manipulateData(data);
  });

getData(
  massageData(data,
    filterData(data,
      uppercaseData(data,
        displayData(data);
      );
    );
  );
);

const displayData = async (data) => {
  const data = await getData();
  const massagedData = await massageData(data);
  const filteredData = await filterData(massagedData);
  const uppercasedData = await uppercaseData(filteredData);
  return uppercasedData;
}

.Now we need a file that lays out our test
.Some people like to store tests in a separate folder, but I prefer to keep them in the same folder as whatever they’re testing
.In this case, that’s our /routes/api folder, so let’s create a new file there and save it as users.test.js
.You’ll note that we don’t have a users.js yet in our API folder
.We’ll get there, promise.

test('test the user API', () => {
   // user api test code
});

describe('The User API', () => {
  it('Returns a list of all users'), () => {
    // user api test code
  });
});

// Access supertest module functionality under the variable name "request"
const request = require('supertest');

// Top level of this test suite: the entire user API
describe('The User API', () => {

  // Specific test
  it('Returns a list of all users', async () => {

    // Connect to the server and get a response
    // Expect that response to be a 200 and serve JSON
    const res = await request('http://localhost:3000')
      .get('/api/users/list')
      .expect(200)
      .expect('Content-Type', /json/);

    // These expects are jest, not supertest
    // First, expect to get a result that is an array
    expect(Array.isArray(res.body)).toBe(true);
    // Second, expect the array to have something in it
    expect(res.body.length).toBeGreaterThan(0);
    // Third, expect the username of the first returned user to be Administrator
    expect(res.body[0].username).toBe('administrator');
  });
});

.All right, let’s talk about that test before we run it
.We’re bringing in SuperTest and assigning it to the variable request, as in server request, because that’s what SuperTest does – it makes testable requests to a server
.As we know from previous tutorials, when you make a request to a server, you get a response in return.

.Next, we use a describe function to add a top level header to our test, under which we define a specific test
.See that async before the function we’re passing the test? That tells us not to continue until any await requests in the function are fulfilled, sequentially
.We work with that on the next line, when we say that our res variable must await the server’s response.

.Without this Async/Await block, we’d send a request out to the server but the test would just keep a-runnin’
.res would be undefined or null, because the script is executing faster than the server can respond, and all our tests would fail.

.Once we HAVE a server response, the Async / Await loop will complete and the test will continue on
.Now res is full of our entire server response, which is a whole bunch of stuff, but what we really want is the body, which is the JSON that the API is sending back
.From here, we can test that the body is an array, that it has something in it, and that the first (and only, for now) entry’s username is “Administrator”.

"test": "jest"

$ npm test

#Five Minute React 20 - Testing an API Endpoint

.You should still have MongoDB and your Express server running from the last tutorial
.If you don’t, make sure to launch ‘em
.Switch over to Sublime Text (or your editor of choice) and let’s create a new file in /routes/api called users.js – we’ll use this to handle API endpoints that deal with users and user accounts
.In a larger application, you’d probably want to break this out into even more granular chunks, but we shouldn’t need to do that here (and if we do, it can be done later with relative ease).

const express = require('express');
const router = express.Router();

const User = require('../../models/user');

.Next up, we want to set up our API to listen for requests at /api/users/list … we’ll handle the first two folders in app.js
.In this file, we only need to worry about the final directory
.Add these lines:

router.get('/list', (req, res, next) => {
});

  User.find((err, users) => {
    if (err) {
      res.send(err);
    }
    res.json(users);
  });

router.get('/list', (req, res, next) => {
  User.find((err, users) => {
    if (err) {
      res.send(err);
    }
    res.json(users);
  });
});

.OK, so, it’s a little weird to be using a singular model name to find potentially more than one user, but think of it like saying “find ANY user that matches X” … in this case we’re not providing X, so the result will be every single user
.Mongoose has a convenient FindOne method that’ll allow you to get a single object returned, although this can be problematic depending on what you’re searching for; if you have three users with a first name of “Jim” and that’s what you search for, you’ll only ever get back to first one if you use FindOne.

module.exports = router;

const express = require('express');
const router = express.Router();

// Import our User model
const User = require('../../models/user');

// GET User List.
router.get('/list', (req, res, next) => {

  // Find all matching users, which in this case is all of 'em
  User.find((err, users) => {
    if (err) {
      // if something's broken, send an error
      res.send(err);
    }
    // Otherwise, send the array of users.
    res.json(users);
  });
});

module.exports = router;

.Now we need to make a quick change to app.js to point to our new endpoint
.Save this file and open app.js
.Find these two lines:

const index = require('./routes/index');
const api = require('./routes/api/index');

const users = require('./routes/api/users');

app.use('/', index);
app.use('/api', api);

app.use('/api/users', users);

.Save that file and we’re set
.Our test should pass
.Let’s do a sanity check and look at the API output in a browser, too
.If you ran nodemon to start your server, it should’ve restarted several times as you saved various JS files
.Head to http://localhost:3000/api/users/list and you should see JSON output of the single user we’ve created
.Cool!

$ npm test

.PASS  routes\api\users.test.js
  The User API
    √ Returns a list of all users (55ms)

.Test Suites: 1 passed, 1 total
.Tests:       1 passed, 1 total
.Snapshots:   0 total
.Time:        1.508s
.Ran all test suites.

#Five Minute React 21 - Working With ESLint

.ESLint isn’t just a Sublime Text package
.Actually, it’s not a Sublime Text package at all
.It’s a Node module that can be run in a lot of ways, including via the command line
.The package we installed for Sublime Text ties in with ESLint, so we need to install the node module
.We also need to create a file called .eslintrc in the top level of our application folder, which will contain the rules that we want ESLint to follow (for example, two-space indentation instead of tabs, which has become the standard for most JS development).

$ npm info "eslint-config-airbnb@15.0.1" peerDependencies

{ eslint: '^3.19.0',
  'eslint-plugin-jsx-a11y': '^5.0.1',
  'eslint-plugin-import': '^2.2.0',
  'eslint-plugin-react': '^7.0.1' }

$ npm add --dev eslint-config-airbnb@15.0.1 eslint@^3.19.0 eslint-plugin-jsx-a11y@^5.0.1 eslint-plugin-import@^2.2.0 eslint-plugin-react@^7.0.1

.Note that if the version numbers you’re getting are different, you should use those ones, and not the ones listed here
.Once you hit enter, this will take a bit
.When it’s done, we should have everything we need to install
.Switch back to Sublime Text and create a file in the top level of your app called .eslintrc
.The first thing we’re going to do is import AirBnB’s settings, so add the following:

{
  "extends": "airbnb"
}

const expressSession = require('express-session')({
    secret: 'some random string goes here',
    resave: false,
    saveUninitialized: false
});

and then change our app.use line on what is now line 35 to:

app.use(expressSession);

const User = require('./models/user');

{
  "extends": "airbnb",
  "rules": {
    "no-unused-vars": ["error", { "argsIgnorePattern": "next" }]
  }
}

.Save the file and refresh app.js (either by closing and reopening it or, my preferred method, hitting space, backspace, and ctrl-s), and the error should go away
.If you don’t like the idea of disabling this error for any variable in your code named next then you can ignore the eslint change above and instead manually add a comment at the end of any line, telling ESLint to ignore that error, like this:

app.use((err, req, res, next) => { // eslint-disable-line

#Five Minute React 22 - ESLint From The Command Line

$ npm -g add eslint-config-airbnb@15.0.1 eslint@^3.19.0 eslint-plugin-jsx-a11y@^5.0.1 eslint-plugin-import@^2.2.0 eslint-plugin-react@^7.0.1

$ npm add --dev eslint-plugin-jest@20.0.3

$ npm -g add eslint-plugin-jest@20.0.3

.OK, cool
.Now we can lint our entire app
.“BUT WAIT,” you may be thinking
.“Does this mean we’re going to lint the literally tens of thousands of files in our node_modules folder? Because that seems like an apocalyptically bad idea!”

.It is, and we’re not going to do that
.ESLint is smart, and it automatically ignores node_modules
.We could also tell it to ignore other files by setting up a .eslintignore file, but we’ll get to that another time.

{
  "extends": "airbnb",
  "rules": {
    "no-unused-vars": ["error", { "argsIgnorePattern": "next" }]
  }
}

  "plugins": [ "jest" ],
  "env": {
    "jest/globals": true
  },

{
  "extends": "airbnb",
  "plugins": [ "jest" ],
  "env": {
    "jest/globals": true
  },
  "rules": {
    "no-unused-vars": ["error", { "argsIgnorePattern": "next" }]
  }
}

"lint": "eslint ."

$ npm lint

.Start with app.js and let's just tell ESLint to ignore that favicon line, like this:

const favicon = require('serve-favicon'); // eslint-disable-line

.Save that file and open up models/users.js
.We need to fix line 1 by adding a new line (this is to keep require blocks separate, even if they’re only a single line)
.We also need a trailing comma at the end of our object
.The final file should look like this:

const mongoose = require('mongoose');

const Schema = mongoose.Schema;
const passportLocalMongoose = require('passport-local-mongoose');

const User = new Schema({
  username: String,
  firstName: String,
  lastName: String,
});

.User.plugin(passportLocalMongoose);

module.exports = mongoose.model('User', User);

.Now open up api/index.js
.This one’s easy: just an empty line after the require
.It should look like this:

const express = require('express');

const router = express.Router();

module.exports = router;

/api/users.js has a few issues, too, so open that up. Again, we need a new line after our require statement.

.Line 8’s error is interesting
.In AirBnB’s opinion, functions should always return something (a JavaScript function with no return value automatically returns undefined, but undefined doesn’t qualify as “something”)
.The way to fix this is by adding a return at the beginning of our two res lines
.Then we fix our improperly spaced if statement on line 9, and all we have left to do is add a new line at the end of the file
.It’ll look like this:

const express = require('express');

const router = express.Router();

const User = require('../../models/user');

/ GET User List. /
router.get('/list', (req, res, next) => {
  User.find((err, users) => {
    if (err) {
      return res.send(err);
    }
    return res.json(users);
  });
});

module.exports = router;

.Our last two files are easy
.Open /api/users.test.js and unpad the block by deleting lines 6 and 9, and add a blank line at the end
.It should look like this:

// Access supertest module functionality under the variable name "request"
const request = require('supertest');

// Top level of this test suite: the entire user API
describe('The User API', () => {
  // Specific test
  it('Returns a list of all users', async () => {
    // Connect to the server and get a response
    // Expect that response to be a 200 and serve JSON
    const res = await request('http://localhost:3000')
      .get('/api/users/list')
      .expect(200)
      .expect('Content-Type', /json/);

    // These expects are jest, not supertext
    // First, expect to get a result that is an array
    expect(Array.isArray(res.body)).toBe(true);
    // Second, expect the array to have something in it
    expect(res.body.length).toBeGreaterThan(0);
    // Third, expect the username of the first returned user to be Administrator
    expect(res.body[0].username).toBe('administrator');
  });
});

.And then open /routes/index.js and add a new line under the require statement and a new line at the end, giving us this:

const express = require('express');

const router = express.Router();

/ GET home page. /
router.get('/', (req, res, next) => {
  res.render('index', { title: 'MusicList Alpha' });
});

module.exports = router;

$ npm lint

#Five Minute React 23 - Installing React Necessities

const myFunc = (myParam) => {
};

var myFunc  = function(myParam) {
};

$ npm add react@16.1.1 react-dom@16.1.1 webpack@3.4.1 babel-loader@7.0.0 babel-core@6.24.1 babel-jest@20.0.3 babel-preset-react@6.24.1 sass-loader@6.0.6 node-sass@4.5.3

#Five Minute React 24 - Setting Up Webpack

$ npm add babel-preset-env@1.6.1

git branch

git checkout develop

git add -A
git commit -m "API and testing setup."
git push

.Once that’s done, it’s time to set up our Webpack config file
.Switch to Sublime Text and, in the top level of your musiclist folder, create a file called webpack.config.js
.This will contain our configuration for our react app.

const path = require('path');

module.exports = {
};

  entry: {
    'javascripts/build.js': './src/index.jsx',
  },

.Since our React app will be entirely built from a starting file, we only need one point of entry
.Basically we’re only searching a single house, not a whole block full of them
.Our entry is going to be a file that doesn’t exist yet, called index.jsx, located in a top-level directory called src, which will contain all of our React source.

  output: {
    filename: '[name]',
    path: path.join(__dirname, 'public'),
  },

.See that name in brackets? That’s a variable that Webpack will automatically recognize, and it maps to the filenames we defined in the entry block above
.So for now, since we only have one entry point, Webpack will see that as filename: 'javascripts/build.js'
.What these lines are saying is “Our output file should live at /public/javascripts/build.js.”

.We have to use the [name] variable to reference the entry point, instead of just providing the filename here, because we’re going to have multiple entry points and output files in the future when we start also compiling CSS.

  resolve: {
    extensions: ['.js', '.jsx'],
  },

  module: {
    rules: [
      {
        test: /\.jsx?$/,
        exclude: /(node_modules|bower_components|public\/)/,
        loader: 'babel-loader',
      },
    ],
  },

const path = require('path');

module.exports = {
  entry: {
    'javascripts/build.js': './src/index.jsx',
  } ,
  output: {
    filename: '[name]',
    path: path.join(__dirname, 'public'),
  },
  resolve: {
    extensions: ['.js', '.jsx'],
  },
  module: {
    rules: [
      {
        test: /\.jsx?$/,
        exclude: /(node_modules|bower_components|public\/)/,
        loader: 'babel-loader',
      },
    ],
  },
};

#Five Minute React 25 - Our First React Components

.Sorry, for a minute I forgot I wasn’t British
.Anyway, in our last tutorial we created a very basic Webpack config file, but had to leave off before we could actually use it
.Today we’re going to change that
.First we need to make a few additions and changes to our app
.We’re going to jump right in by switching to sublime text and then creating a new file in your top level musiclist folder called .babelrc
.These are the rules which Babel will use when Webpack calls upon it to transpile your ES2015-17 and JSX down to regular old JavaScript
.Fortunately it’s a super simple file
.Here is everything it needs to contain:

{
  "presets": ["env", "react"],
}

env for all the latest JavaScript goodness, and react for React. That’s it, we’re done here. Save the file, and open up package.json. We need to create a script to run Webpack, so add a comma to line 8, and then underneath it, add the following:

"build-dev": "webpack --config webpack.config.js --progress --profile --colors"

.This means when we type npm run build-dev in our command line, it’ll run Webpack, using the config file we wrote in the last tutorial, with a couple of options set to make its output look a little nicer.

.Create a top-level directory in your musiclist folder called src which will contain all of our React source files, including JSX components, JavaScript actions and stores (we’ll get to those), and more
.In that new folder, create a file called index.jsx
.This is the top-level component of our app, from which all other components will be initialized (albeit not all in this file – it’ll branch outwards, like an upside-down tree).

import React from 'react';
import { render } from 'react-dom';
import TestComponent from './testcomponent';

render(
  <TestComponent />,
  document.querySelector('#react-app'),
);

.All right, let’s go through this line-by-line
.Line one imports our React module, which seems valuable if we’re going to be writing a React app
.Line two does something interesting, which we haven’t covered before in this series
.It’s importing something from our React-Dom module … but instead of pulling a master object that contains all of that module’s methods and other properties, we’re pulling a single method, render.

.Back to our JSX file
.Line 3 is importing a test React component from testcomponent.jsx (we don’t have to add the file extension – Webpack is smart enough to figure it out)
.Eagle-eyed observers may note that testcomponent.jsx does not, in fact, exist
.We’ll be fixing that in a second.

.Lines five through eight use the render function we imported from React-Dom to render our react component into our page, inserting it into a div named react-app
.Annoyed by ESLint flagging “document” as undefined? Pop over real quick to .eslintrc and, in the env block, add a comma to line 5 and then add the following:

"browser": true,
"node": true,

.This will tell ESLint not to complain about assumed globals like Window, Document, and a few others
.Save the file, go back to index.jsx, and hit space, delete, save in order to fresh the ESLint plugin for Sublime
.There we go.

.OK, so now we need two things: a test component, and a div with an ID of react-app
.Let’s do the test component first
.Create a new file in /src called testcomponent.jsx, and then add the following:

import React from 'react';

export default function TestComponent() {
  return (
    <div>
      <h1>React Test Component</h1>
    </div>
  );
}

.We’re importing React again, which we will do a lot
.Then we’re defining a new function, which we’re exporting (so that it can be imported by index.jsx), named TestComponent
.The “default” means we can just do:

import TestComponent from './testcomponent';

import { TestComponent } from './testcomponent';

.Once we define our function, we give it a return block which, as you can see, returns a bunch of HTML
.This is JSX, the bizarre JS/HTML hybrid of which I’ve spoken in the past
.Look ye upon it, and despair!

.Or don’t
.It’s pretty straightforward
.Mostly it’s JavaScript, except when you’re in a return block, in which case you can return HTML … which you can mix with JavaScript, but we’re getting ahead of ourselves.

.It’s almost time to see that beautiful heading-one text showing up in our browser
.All that’s left to do is edit our top level view and then run our Webpack build
.So, open up /views/index.ejs
.Nuke everything in between the body tags and then add this instead:

<div id="react-app">Loading ...</div>

<script src="/javascripts/build.js"></script>

… it’s important to load our build.js after the div that contains our React app, because otherwise it’ll load the javascript and try to initialize React before that div exists, creating an error in our browser console and causing the app load to fail. Save this file. We’re done writing code. Now we switch to a terminal window, make sure we’re in our musiclist directory, and type:

$ npm run build-dev

.BEHOLD! We have built a React app
.Not one that does much, but a React app nonetheless
.Make sure our node server is running, then navigate to localhost:3000 … if everything went according to plan, you’ll see a big header that says “React Test Component”

#Five Minute React 26 - Using Props In React

.If you’ve read up on React at all, one of the things you’ve probably heard mentioned is the concept of “props.” This word, which is derived from “properties” is React’s term for various values that are handed down from parent component to child component
.What this looks like in practice is like you’re adding an attribute to your JSX component tag
.For example, our test component tag, here on line 6 of /src/index.jsx
.Let’s add a prop to that
.Here’s how we do it
.Take this line:

<TestComponent />,

<TestComponent headline="Test Headline" />,

.There you go, you’ve added a prop
.This will get passed down to /src/testcomponent.jsx, and we can work with it there
.Props can be all of the basic JavaScript types: strings and numbers, booleans, objects and arrays, etc
.They are always passed down from parent to child (there are ways of communicating from a child component to the parent, but the practice is not generally encouraged)
.They should not be modified in the child components, only used … but we’ll get to that.

.For now, let’s switch to /src/testcomponent.jsx and modify it to use the prop we’re now sending
.Open up the file, and make two changes, first, find line 3:

export default function TestComponent() {

export default function TestComponent(props) {

.The secret truth is that React has been passing a props object to our function even though we didn’t have any props defined (and hadn’t written our function to accept it)
.We’re just adding a function parameter so we can actually use the props in the component.

<h1>React Test Component</h1>

<h1>{props.headline}</h1>

.ESLint is going to complain here, because it wants us to be doing type-checking on our props in order to make sure that a prop that’s supposed to be a number is a number and not an array, or that a boolean is actually true or false instead of the words “true” or “false.” React used to have basic type-checking for props available by default, but as type-checking approaches like TypeScript and Flow have become more popular, it was moved to its own module
.We're not going to worry about type checking in this course
.Let’s turn it off in ESLint by opening .eslintrc, adding a comma at the end of line 10, and then just below it typing the following:

"react/prop-types": [0]

.Save that file, switch back to /src/testcomponent.jsx, and do the old space, delete, save routine, and the error will go away
.Cool
.Now let’s add a second and third prop, and actually do more with it than just printing out a string
.Switch back to /src/index.jsx and add a couple more props to our test component, so it looks like this:

<TestComponent headline="Test Headline" count={1234} showCount />,

.As you can see, we’re using curly braces to pass a number because if we used quotes it’d show up as a string
.We’re also passing showCount with no value since it’s a boolean – if it exists, it’s true
.If not, it’s false
.Switch back to /src/testcomponent.jsx.

.Now … we could reference each prop as an object property in the same way we’re doing it with props.headline, but let’s use variable destructing instead
.Just below your function declaration on line 3, add the following:

const { headline, count, showCount } = props;

<h1>{headline}</h1>

{ showCount ? <p>{count}</p> : null }

.What we have there is a ternary operator, which is a single-line JavaScript solution for “if a condition is met, do one thing, otherwise do another thing,” and which we’ll be using a lot in React because JavaScript inside return blocks can’t span more than a single line, so if / else routines aren’t available to us here (there are ways to get around this, and we’ll cover them later)
.In this case, our ternary operator is saying “if the showCount prop exists, produce some HTML with the count in it, otherwise do nothing.”

.Now that we’re passing props from parent to child and using it, let’s take a look at localhost:3000, refresh it, and watch our text show up … or not so much
.Remember, any time we make changes to our React app, we have to recompile it with Webpack
.It’s very possible that at this moment you are staring, jaw agape, at your screen and thinking, I’m going to have to type something in the command line and watch it compile every single time I make any changes whatsoever to this app?

$ npm run build-dev

.This’ll run our webpack build, which should run without errors
.If you get any, check for typos! Once it’s done, flip back to localhost:3000 and refresh
.Hey, look at that, we’re using our passed props
.Nice.

#Five Minute React 27 - Webpack Hot-Reloading Part 1

$ npm add --dev webpack-dev-server@2.4.5 react-hot-loader@3.0.0

.AirBnB’s ESLint rules don’t like us using dev dependencies in our code, but we’re going to have to do so here in one instance, so let’s keep them from complaining
.Open up .eslintrc, add a comma to the end of line 11, and just below it add the following:

"import/no-extraneous-dependencies": ["error", {"devDependencies": true }],

.Now it’s time to tackle .babelrc, so open that up
.Add a comma at the end of line two, and then below that add the following:

"plugins": ["react-hot-loader/babel"]

.Save that, and let’s tackle the big one … webpack.config.js
.First, replace line 1 const path = require('path'); with the following:

const { resolve } = require('path');
const webpack = require('webpack');

.Next, just below line four, module.exports = {, add the following:

context: resolve(__dirname, 'src'),

.resolve is one of several methods used for reading and manipulating paths
.Essentially, it comes in handy for making sure that your application can find files whether or not it’s running on Windows, OSX, FreeBSD, Ubuntu, MS DOS 3.1 (err … OK, probably not), or any other OS of your choosing.


.__dirname is a global Node variable that represents the path to the executable that node is currently running
.In our case, that means app.js
.This is important because there will be times when you are executing your node application from a directory that is NOT the application’s home directory (this is especially true when running production code on servers), which means that your current working directory is not the same thing as the directory in which your app actually lives
.We want to generate our file location paths for both our application and for webpack using the latter, so we use __dirname.

  entry: [
    'react-hot-loader/patch',
    'webpack-dev-server/client?http://localhost:8080',
    'webpack/hot/only-dev-server',
    './index.jsx',
  ],

.First we enable the hot reloader for React, then we establish the Webpack dev server, which is a separate server from our application’s webserver and set it up to run at localhost:8080
.After that, we tell Webpack to hot-reload only when webpack compiles successfully
.Finally, we tell it where to start … index.jsx (we don’t need /src because of the context block we already discussed).

.We could theoretically use Webpack’s dev server to serve our entire app, except that our app is a Node.js-based API, not a simple HTML-and-CSS website
.That’s why we have to keep our app running at localhost:3000 as we’ve been doing.

  output: {
    filename: 'build.js',
    path: resolve(__dirname, 'public', 'javascripts'),
    publicPath: '/javascripts',
  },

.We’re replacing the name variable with build.js because we’re no longer providing a name in our entry block
.We’re changing the path to include javascripts, and we’re setting the publicPath because webpack needs it to know where to load hot-update chunks (parts of the file it’s replacing).

  devServer: {
    hot: true,
    contentBase: resolve(__dirname, ''),
    publicPath: '/javascripts',
  },

.This sets hot-reloading to true, explains that the content base path is the same as our app’s base path, and that we want our build file to be served at localhost:8080/javascripts

  plugins: [
    new webpack.HotModuleReplacementPlugin(),
    new webpack.NamedModulesPlugin(),
  ],

#Five Minute React 28 - Webpack Hot-Reloading Part 2

. views/index.ejs – we need to change our javascript reference! Find the following line:

<script src="/javascripts/build.js"></script>

.change to:

<script src="http://localhost:8080/javascripts/build.js"></script>

.Now we need to inform our React app itself that we’ve enabled hot reloading
.Open up src/index.jsx
.We need to add an AppContainer component which is created by the React hot-loader, and then use it to wrap our application
.Start by finding line 2:

import { render } from 'react-dom';
.add:
import { AppContainer } from 'react-hot-loader';

.add:
const renderApp = (Component) => {
  render(
    <AppContainer>
      <Component headline="Test Headline" count={1234} showCount />
    </AppContainer>,
    document.querySelector('#react-app'),
  );
};

.As you can see, this really isn’t so different from the existing render block, it’s just creating a function called renderApp which takes a parameter called Component (which needs to be a React component)
.It then sticks that component into the AppContainer component we imported up above.

.delete:
render(
  <TestComponent headline="Test Headline" count={1234} showCount />,
  document.querySelector('#react-app'),
);

.add:
renderApp(TestComponent);

.add too at the end of file:
if (module && module.hot) {
  module.hot.accept('./testcomponent', () => {
    renderApp(TestComponent);
  });
}

.The module we’re looking for is provided by Webpack while bundling
.You might be wondering why we’re calling the same function twice, which generally seems like bad policy
.However in this case, there’s a good reason: the page won’t render for the first time if we only use the if block we just wrote
.So, we run the function once to initialize our component, and then call it again any time a change happens, in order to reinitialize that component, which allows the hot-reloader to show changes without a full page refresh

.The last thing we need to do is create a script to run our Webpack dev server
.Open package.json, and just below line 6, add the following:

    "start-w": "webpack-dev-server",

$ npm run start-w

.So now, let’s make a change and see if it reloads
.Head over to /src/index.jsx and let’s change one of our props
.Specifically, change the count from 1234, to 5678, and save your file
.Switch back to your browser, and there you go! Automatic rebuilding and hot reloading in action
.This is going to make our life a whole lot easier.

#Five Minute React 29 - React Folders and Template

.Let’s start with our /src directory
.For now, create the following folders underneath /src:

    /actions
    /components
    /reducers
    /utils

.With that done, go ahead and delete /src/testcomponent.jsx 
.actions are what we’ll be using to communicate changes in state to our application
.Components will hold our React components, everything from page templates down to little boxes, buttons, and doodads
.Reducers are what take input from the actions, and then store the state changes in what’s conveniently referred to as the Store
.Utils will be small JavaScript files full of handy stuff that we can import if we need it.

.To put it in jQuery terms, all of these change app state:

$('#myDiv').show();
$('#myDiv').addClass('highlight');
$('#myDiv').html('This is new text for the div.');

.The reason for using React over something like jQuery to manage this stuff is because of all the automagic that happens under the hood
.Instead of having to update a div with text, we can just change a component’s prop, giving it the text we want, and React will automatically render that
.We don’t end up having to write a zillion .show() and .hide() and .html() functions for the various pieces of our app, resulting in a much more compartmentalized and less cumbersome approach to application development
.Additionally, there are also performance things React does in the background that make it extremely fast when it comes to re-rendering part of the page, so that’s an added bonus.

.All right, let’s build our container
.Create a file in /src/components called Template.jsx (yes, with a capital T – it’s convention for React components)
.Then fill it with the following code:

import React from 'react';

export default function Template() {
  return (
    <div className="wrapper">
      <header>
        <h1>MusicList</h1>
      </header>
      <div className="content">
        Content will eventually go here.
      </div>
    </div>
  );
}

.Note that we’re using className instead of class – this is because class is a reserved word in JavaScript
.Don’t worry; React will render it out as “class” in the HTML it generates
.For now, save the file and switch over to /src/index.jsx
.We need to update this file to use our template instead of our now-nonexistent test component
.We don’t need to write any new codes, we just need to change four lines
.Specifically the following ones …

.Line 5:
import TestComponent from './testcomponent';
.becomes
import Template from './components/Template';
.Line 16:
renderApp(TestComponent);
.becomes
renderApp(Template);
.Line 19
  module.hot.accept('./testcomponent', () => {
.becomes
  module.hot.accept('./components/Template', () => {
.And Line 20
    renderApp(TestComponent);
.becomes
    renderApp(Template);

$ npm run start-w

and then save this file. If you still have your browser open, you should see it hot-reload with the changes. If not, navigate to localhost:3000 to see the new stuff.

#Five Minute React 30 - Building Out Components

.First step, in /src/components, create a subfolder called shared, and inside it, create a new file called Header.jsx
.This will be our page header, and it’ll be used on just about every page
.It’s going to look a lot like the other React components we’ve been building, for now
.Here’s the code:

import React from 'react';

export default function Header(props) {
  const { username } = props;
  return (
    <header>
      <h1>MusicList</h1>
      <div className="user-menu">
        <h2>Welcome { username }</h2>
      </div>
    </header>
  );
}

.Save that file
.Now that our component exists, we need to call it, so open up /src/components/Template.jsx
.It’s convention to add a blank line between functionality imports like line 1, and component imports, so make sure line 2 is blank, and then underneath it add the following:

import Header from './shared/Header';

.find:
      <header>
        <h1>MusicList</h1>
      </header>
.& substitute:
      <Header username="anonymous" />

.Now let’s build a page component

$ mkdir src/components/home
$ vim src/components/home/HomePage.jsx

import React from 'react';

export default function HomePage() {
  return (
    <section className="page-content">
      <div className="row">
        <div className="col-sm-12 col-lg-8">
          This is the home page.
        </div>
        <aside className="col-sm-12 col-lg-4">
          This is the sidebar
        </aside>
      </div>
    </section>
  );
}

$ mkdir src/components/account
$ vim src/components/account/ProfilePage.jsx

import React from 'react';

export default function ProfilePage() {
  return (
    <section className="page-content">
      <div className="row">
        <div className="col-sm-12 col-lg-8">
          This is the profile page.
        </div>
        <aside className="col-sm-12 col-lg-4">
          This is the profile page sidebar
        </aside>
      </div>
    </section>
  );
}

.So, now we have two page components
.We can only wire one of them up to our template right now, though (well, we could display both of them at once, but then they wouldn’t exactly be separate pages)
.Let’s go ahead and add our home page for now
.Head back to /src/components/Template.jsx, and just below our import for the Header, add the following line:

$ vim src/components/Template.jsx

import HomePage from './home/HomePage';

.replace the following three lines:
      <div className="content">
        Content will eventually go here.
      </div>
. with this:
      <HomePage />

#Five Minute React 31 - React Routing

.front-end routing: the server’s never contacted
.Your browser request is intercepted by React (or another framework) and React renders a new set of components
.This is all done without a page reload, which speeds things up, and in the case of React, it’s done without even completely rewriting the DOM, which speeds things up even more.

$ npm add react-router-dom@4.1.1
$ npm audit fix

.We’re going to need to wrap our components in our router, but that’s relatively straightforward, at least at the start
$ vim src/components/Template.jsx
.We’re going to modify this file so that it lets us use different components based on browser URL
.Just below line 1, add the following:

import { BrowserRouter as Router, Route } from 'react-router-dom';

.You’ll note we’re doing something interesting with destructuring there … not only are we importing two individual properties, BrowserRouter and Route, but we’re renaming BrowserRouter to just Router for ease of use
.Both of these properties perform essentially as React components, as you’ll see when we adjust the code below.

.Below what is now line 5,
import HomePage from './home/HomePage';
.add the following code:
import ProfilePage from './account/ProfilePage';

.This will allow us to access both of the page components we’ve created from our template
.Next we need to wrap the whole Template component in React-Router’s BrowserRouter wrapper, which remember, we’ve renamed to just Router … so take the entire render block, all of this:

      <div className="wrapper">
        <Header username="anonymous" />
        <HomePage />
      </div>

.Indent it in one more level, and then wrap it with <router></router> so that it looks like this:

    <Router>
      <div className="wrapper">
        <Header username="anonymous" />
        <HomePage />
      </div>
    </Router>

.Now we need to add some routes, so let’s do that! Take that central HomePage component, which looks like this:

        <HomePage />
. And nuke that jerk, replacing it with the following:
        <Route exact path="/" component={HomePage} />
        <Route path="/account/profile/:id" component={ProfilePage} />

.It sort of looks like we’re adding both pages to the template, and in a way we are, but because the template is now wrapped with <router>, React-Router understands that it is to only render these components when the path specified in the path prop is being accessed
.So when we hit localhost:3000/ it should render HomePage
.When we hit localhost:3000/account/profile/ANYID (for example, localhost:3000/account/profile/captaincode), it should render ProfilePage
.For any other URL, it should render neither component.

.Notice that exact boolean prop in the HomePage component? We can set that to make sure the Router understands that / is different than /a … by not setting it in the second Route, we allow for fuzzy matches
.For example, localhost:3000/account/profile/captaincode/random/etc will still bring up the profile page component

.Let’s add some header links so we can quickly flip back and forth between our two pages
$ vim src/components/shared/Header.jsx
.and below line 1 add the following:

import { Link } from 'react-router-dom';

.We’re going to be using <link to /> instead of <a href> for in-app navigation
.Anyway, just below the <h2> block, add the following code:

        <nav>
          <ul>
            <li><Link to="/">Home</Link></li>
            <li><Link to="/account/profile/captainCode">Profile</Link></li>
          </ul>
        </nav>

$ vim src/components/account/ProfilePage.jsx
.Change line 3 to this:

export default function ProfilePage(props) {

const { match } = props;

. match is a prop sent automatically by React Router and what it does is, to quote their own documentation: “A match object contains information about how a <route path> matched the URL.” We can use this to get the :id parameter we defined in our Route, for one thing. So change line 9 to look like this:

This is the profile page. The profile id is: {match.params.id}

.Cool! But we still have that problem to solve where if we try to manually navigate to anything other than a top-level URL, we get a 404
.This is because Express is still taking command of routing whenever a hard request for a new page is made by the browser
.What we need to do is create a wild-card that will catch any URL that’s not a part of our API, and route it to /views/index.js so that our React app always gets initialized, at which point, React Router will take over.

$ vim app.js

.So open /app.js and find lines 42 through 44
.Right now, we have three routes defined
.We want to move the index route down below the API routes, because that’ll allow Express to catch any API routes and NOT send them to the React app, so do that, like this:

app.use('/api', api);
app.use('/api/users', users);
app.use('/', index);
. add an asterisk to that final line, like this:
app.use('/*', index);

.All right, we should now be able to navigate to the user profile page without having to click a link to get there

#Five Minute React 32 - Fixing Webpack

.In the process of researching the issue, I found a better way to handle Webpack/Express combos, using a terrific module called webpack-hot-middleware, which allows us to tie our Webpack server right into Express
.This means no more conflicts, and it also means we don’t have to run a separate terminal window containing our Webpack server, since it will fire up when we launch Express with nodemon npm start.

$ npm add webpack-dev-middleware@1.11.0 webpack-hot-middleware@2.18.0
$ npm audit fix

$ vim webpack.config.js
.Change to:
  entry: [
    'react-hot-loader/patch',
    'react-hot-loader/babel',
    'webpack-hot-middleware/client',
    './index.jsx',
  ],
.Change the output block to look like this:
  output: {
    filename: 'build.js',
    path: '/',
    publicPath: '/javascripts',
  },

.The reason we don’t need the resolve(__dirname, 'public', 'javascripts'), line anymore is because we’re using a virtual server now, rather than writing out an actual JS file, so the physical location on the disk doesn’t actually matter to us (for now – we’ll need to address this before we move to production, but that’s a much later tutorial).

. NOOOOOOOOOOOOOOO!!!!! YO NECESITO MI PROXY!!!!!!!! AUNQUE SOLO EL PROXY, Y NUKO EL RESTO.  We can nuke the entire devServer block – Express is going to handle that for us
.Then move on to our plugins block, which gets one addition at the bottom:

    new webpack.NoEmitOnErrorsPlugin(),

$ vim app.js
.We’ve got some additions to make! Underneath line 14, which closes the const expressSession block, add the following:

const webpack = require('webpack');
const webpackConfig = require('./webpack.config');
const webpackDevMiddleware = require('webpack-dev-middleware');
const webpackHotMiddleware = require('webpack-hot-middleware');

.  just below line 44, add the following:
// Webpack Server
const webpackCompiler = webpack(webpackConfig);
app.use(webpackDevMiddleware(webpackCompiler, {
  publicPath: webpackConfig.output.publicPath,
  stats: {
    colors: true,
    chunks: true,
    'errors-only': true,
  },
}));
app.use(webpackHotMiddleware(webpackCompiler, {
  log: console.log,
}));

$ vim src/index.jsx 
.and change lines 17 to 22,

if (module && module.hot) {
  module.hot.accept('./components/Template', () => {
    renderApp(Template);
  });
}
. To this:
if (module && module.hot) {
  module.hot.accept();
}

$ vim views/index.ejs
. and change line 10,

<script src="http://localhost:8080/javascripts/build.js"></script>
.to:
<script src="/javascripts/build.js"></script>

.Then switch to your terminal window, cd to /public/javascripts, and delete your build.js file
$ rm public/javascripts/build.js
.If you miss this step, your dev server will not work and you will keep getting the same error in your browser’s console no matter what other changes you make, which will drive you crazy for way longer than it should before you finally figure it out... NOT ME


git add -A
git commit -m "webpack and hot-reloading setup"
git push

#Five Minute React 33 - DRYing Your Code

.  “Don’t Repeat Yourself”
.We’re going to create a Sidebar component, and then we’ll shift a little bit of code from our pages to our template.

$ vim src/components/shared/Sidebar.jsx

import React from 'react';

export default function Sidebar() {
  return (
    <aside className="col-sm-12 col-lg-4">
      This is the new sidebar component.
    </aside>
  );
}

$ vim src/components/home/HomePage.jsx
.First, add a line after line 1, and on line 3, add the following:

import Sidebar from '../shared/Sidebar';
.  Nuke these three lines:
        <aside className="col-sm-12 col-lg-4">
          This is the sidebar.
        </aside>
. and replace them with this one:
        <Sidebar />

.The next thing we want to do is remove some of the container HTML from this page
$ vim src/components/home/HomePage.jsx
.Cut the following two non-sequential lines out of HomePage.jsx and add them instead to 
$vim src/components/Template.jsx

    <section className="page-content">
    </section>

.So that Template.jsx returns this:

    <Router>
      <div className="wrapper">
        <Header username="anonymous" />
        <section className="page-content">
          <Route exact path="/" component={HomePage} />
          <Route path="/account/profile/:id" component={ProfilePage} />
        </section>
      </div>
    </Router>

$ vim src/components/account/ProfilePage.jsx 
. and add the following to line 3, just like HomePage.jsx:

import Sidebar from '../shared/Sidebar';

. Then remove the opening and closing section tags entirely (again, you’ll need to remove an indent level from your code), and replace these lines:
      <aside className="col-sm-12 col-lg-4">
        This is the profile page sidebar
      </aside>
. With this one:
      <Sidebar />


#Five Minute React 34 - Adding Bootstrap

.Instead of just calling the CSS via an HTML <style> tag, we’re going to import it into our JavaScript, then use a parsing plugin for Webpack that will pull out the CSS and serve it as a separate file
.This way we’ll be able to make changes to the CSS, if we want, and have Webpack automatically compile them, rather than having to run a separate compiler like Gulp (or the Sass Ruby gem, which is not just a whole other tutorial, but an entirely different tutorial series and possibly website).

$ npm add reactstrap@4.8.0 react-addons-transition-group@15.6.0 react-addons-css-transition-group@15.6.0 bootstrap@4.0.0-alpha.6 extract-text-webpack-plugin@2.1.2 css-loader@0.28.4 style-loader@0.18.2
$ npm audit fix

.This covers Reactstrap, some helper utilities for Bootstrap transitions, Bootstrap itself, and the plugins and loaders we’ll need to get Webpack to do what we want it to do
$ vim webpack.config.js
.First, below line 2, let’s add our extract text plugin, like this:

const ExtractTextPlugin = require('extract-text-webpack-plugin');

. line 14:
    filename: 'build.js',
. line 16:
    publicPath: '/javascripts',
. To be able to serve our CSS from wherever we want.
. let’s change line 14 to this:
    filename: 'javascripts/build.js',
. and line 16 to this:
    publicPath: '/',
. one for handling .css files. Below line 27, add the following code:
      {
        test: /\.css$/,
        use: ExtractTextPlugin.extract({
          fallback: 'style-loader',
          use: 'css-loader',
        }),
      },
. What we’re doing here is saying “when you encounter a CSS file, parse it with our extract text plugin, using css-loader to resolve all imports and URLs in the CSS, and then pipe that output to style-loader, which will actually write the generated CSS out.” 
. add our text extraction plugin to Webpack’s list of plugins:
new ExtractTextPlugin('stylesheets/style.css'),

.This is telling our plugin where to serve the file, which, since in our output we just set our public path to /, means it’ll live at /stylesheets/style.css … which is where it belongs

.Speaking of which, we have an existing file of the same name in the actual, physical /public/stylesheets/ folder that can cause conflicts
.It comes with Express and has about eight lines in it
$ rm public/stylesheets/style.css

$ vim src/index.jsx
.and add the following code under line 3:

import 'bootstrap/dist/css/bootstrap.css';

$ vim src/components/Template.jsx
. and change line 13 to look like this:

        <section className="page-content container-fluid">

$ vim src/components/home/HomePage.jsx
. and just below the first line, add the following:

import { Button } from 'reactstrap';

. add a helper function to this component. Below line 5, add this code:
const showAlert = () => {
  alert('You clicked the button. Well done, Draco!');
};
. tweak to line 13, so that our columns will work on medium-sized screens:
      <div className="col-sm-12 col-md-8">

. Replace:
This is the home page.
. with:
        <p>
          This is the home page.
        </p>
        <p>
          Here for your enjoyment is a button:
        </p>
        <Button onClick={showAlert}>Click Me</Button>

.See that onClick? Some of you may be getting that thing where your eyelid twitches uncontrollably, right now
.Yes, it’s true, we’ve spent the past decade-plus talking about not using HTML onClicks in favor of catching events with JavaScript
.Here’s the thing: we’re still doing that
.It’s just that React is doing that for us
.It’s taking that simple onClick, and turning it into a JavaScript event catcher
.If you were to check your Button element in the element inspector, you’d see that there’s no onClick generated on the finalized HTML output
.So, take a breath, we’re all good!


$ vim src/components/account/ProfilePage.jsx
. change “lg” to “md,” on line 9, like this:

      <div className="col-sm-12 col-md-8">

$ vim src/components/shared/Sidebar.jsx
.We’re going to make this a little prettier and add a Bootstrap card just for the heck of it
.Just below line 1, add this code:

import { Card, CardBlock, CardText } from 'reactstrap';
. swap out the “lg” for an “md” on line 6 like this:
      <aside className="col-sm-12 col-md-4">
.  swap out the following text on line 7:
      This is the new sidebar component.
. with all of this:
      <Card>
        <CardBlock>
          <CardText>
            Sidebar Item
          </CardText>
        </CardBlock>
      </Card>

.Save that file, and we’re good to go
.Make sure your Express server is running, and head for a browser pointed at localhost:3000
.You may need to do a hard-refresh here to get the styles to show up, but everything should be working, including our alert when we click our button on the homepage.

#Five Minute React 35 - Classes and State

.We’re duplicating a plugin right now in our babel config and our webpack config, and it can lead to some state issues, so open .babelrc and just delete this line entirely:

$ vim .babelrc
"plugins": ["react-hot-loader/babel"]

$ vim src/components/shared/Header.jsx
.Below line 2, add the following:

import { Collapse, Navbar, NavbarToggler, NavbarBrand, Nav, NavItem, NavLink } from 'reactstrap';

.As you can see, we’re pulling in a whole bunch of stuff from Reactstrap that we’re going to use to assemble our Navbar
.In order to make toggling work, we need to use an existing method that’s only available to React classes, not pure functions like we have here, so it’s time to build our first one of those
.Here’s what I recommend: you should add a few linebreaks above line 4, export default function Header(props) {, and then write out the entire new class above it
.That way, you can compare the two and note differences between the function and the class.

.We’re going to be using ES6 classes, here
.Classes are special objects that basically put a new layer over JavaScript’s existing prototype-based inheritance
.They’re great for defining an object (in this case a React component) and making it clear how inheritance works
.Classes can extend other classes, which means they get all of the parent class’s existing methods and other parameters, but can also add their own, which don’t get passed up to the parent

.start by declaring our new class:

export default class Header extends React.Component {
}
.  add some lines at the top of the class:
  constructor(props) {
    super(props);

    this.state = {
      isOpen: false,
    };
  }

.A class constructor tells the class what arguments the class can take. It’s similar to defining function arguments like this:

function(arg1, arg2) {
}

.Except we’re doing it inside the class declaration
.In most cases, inside a constructor, you then need to assign the arguments to this.whateverNameYouLike … so you’d expect there to be a line like this:

this.props = props;

. but there’s not. That’s because the actual next line, super (props), is taking the assignments from the parent class (React.Component). In order to use “this” properly in a child class, you need to call super in the constructor. 
. I recommend Wes Bos’s ES6 For Everyone

.Moving on, we see that we’re setting a state variable for our class
.This is the only place you should ever manipulate this.state directly … in all other cases you’ll use a special setState() method, which we’ll get to
.In our case, we’re just setting a variable called “isOpen” to false
.This will control whether or not the navbar starts out expanded or collapsed on small screens (we want it to be collapsed)
.Doing this in the constructor means that this.state and this.state.isOpen will be available anywhere else within the class that we want to use it.
. App state is different from component state. The former contains data available application-wide. The latter controls the particular state of bits and pieces of a given component.
. As a general rule of thumb, if it’s coming in from your database, it should be stored in app state

. add this code to your class, we create a render method (which React will run automatically when it mounts the component) that returns a whole bunch of JSX, most of it comprised of the various components we imported from Reactstrap:
  render() {
    return (
      <header className="wrapper">
        <Navbar color="faded" light toggleable>
          <NavbarToggler right onClick={this.toggleNavbar} />
          <NavbarBrand tag={Link} to="/">MusicList</NavbarBrand>
          <Collapse isOpen={this.state.isOpen} navbar>
            <Nav className="ml-auto" navbar>
              <NavItem>
                <NavLink tag={Link} to="/account/login">Log In</NavLink>
              </NavItem>
            </Nav>
          </Collapse>
        </Navbar>
      </header>
    );
  }

.On line 18 we’re calling a this.toggleNavbar method when a user clicks
.Observant readers might note that we have not actually defined that method yet
.We’ll fix that in a second
.Also note that on line 20 we’re using this.state.isOpen which means that if we toggle that value in our state, the value will change in React, which will cause a redraw, changing the classes necessary to expand or collapse the menu

. let’s add our toggle method. Above the render block, but below the constructor, add the following code:
  toggleNavbar() {
    this.setState({
      isOpen: !this.state.isOpen,
    });
  }
. As you can see from this and the render method, we don’t have to use the “function” declaration or anything in ES6 classes. It’s just the method name and some parens (which would contain arguments, if we needed them, but here we don’t).

.So there’s how setState() works
.You just pass it an object with any parts of the component state you want to manipulate, and it’ll do so
.This is nice because it means you could have, say, five parameters defined in this.state, but only manipulate two of them using setState, and the other three just stay as they were
.Due to React’s automagic, this also triggers a component re-render, which is one of the reasons why you always want to use setState() rather than manually changing this.state.

.All right, seems like we should be done, but we’re not
.Helper methods like toggleNavbar have to be bound in our constructor
.There’s a big, long reason for this, but the shorter version is that if you don’t bind them, React will basically create a new instance of toggleNavbar every time the component re-renders, but when you click on the toggle it’ll be running the old instance of toggleNavbar attached to the old version of the component, which no longer exists
.That’ll throw an error
.It’s a little confusing, but the long and short of it is, we need this line up in our constructor, just above this.state:

this.toggleNavbar = this.toggleNavbar.bind(this);

. we need to delete the old Header function.

. final file should look like this:

import React from 'react';
import { Link } from 'react-router-dom';
import { Collapse, Navbar, NavbarToggler, NavbarBrand, Nav, NavItem, NavLink } from 'reactstrap';

export default class Header extends React.Component {
  constructor(props) {
    super(props);

    this.toggleNavbar = this.toggleNavbar.bind(this);
    this.state = {
      isOpen: false,
    };
  }

  toggleNavbar() {
    this.setState({
      isOpen: !this.state.isOpen,
    });
  }

  render() {
    return (
      <header className="wrapper">
        <Navbar color="faded" light toggleable>
          <NavbarToggler right onClick={this.toggleNavbar} />
          <NavbarBrand tag={Link} to="/">MusicList</NavbarBrand>
          <Collapse isOpen={this.state.isOpen} navbar>
            <Nav className="ml-auto" navbar>
              <NavItem>
                <NavLink tag={Link} to="/account/login">Log In</NavLink>
              </NavItem>
            </Nav>
          </Collapse>
        </Navbar>
      </header>
    );
  }
}

.You may need to hard-refresh, or even restart your server, because we made those changes to .babelrc
.You should have a fully-working navbar, and you can resize your browser down to see the toggle functioning properly as well.

#Five Minute React 36 - Building a Log In Page

.We’re going to create a new page component, then use some Reactstrap to make it look pretty. We’re also going to add some custom Sass

$ npm add sass-loader@6.0.6 node-sass@4.5.3

$ vim webpack.config.js
.We’ll need to add a rule for Sass files, which use the .scss extension, just like we did for jsx and css files
.It will go below the two other rules, and look like this:

      {
        test: /\.scss$/,
        use: ExtractTextPlugin.extract({
          use: [
            {
              loader: 'css-loader',
            },
            {
              loader: 'sass-loader',
            },
          ],
          fallback: 'style-loader',
        }),
      },

$ mkdir src/css
$ vim src/css/musiclist.scss
.This will be where we put our own custom styles and overrides
.For now, all we need is the following:

header {
  margin-bottom: 1rem;
}

.This will give a little padding between our header and our content, which is always nice
$ vim src/index.jsx
. and just below line 4, where we’re importing Bootstrap’s css, let’s add the following:

import './css/musiclist.scss';

.Now the style.css file that Webpack is serving from its dev server includes our custom styles
.Unfortunately, thought, styles don’t reload, so you have to refresh to see visual changes
.Do that, and your margin should show up

.Let’s move on to the login page
$ vim src/components/account/LoginPage.jsx
.At the top of the file, we’ll need to import React and a few Reactstrap components, with these two lines:

import React from 'react';
import { Button, Form, FormGroup, Label, Input } from 'reactstrap';

. We’re going to create this component as an ES6 class, just like our Header, because we’re eventually going to need some state manipulation for form validation (among other things). So, here’s the code for that:

export default class LoginPage extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      <p>this is the log in page</p>
    );
  }
}

.We need to add a route to our template
$vim src/components/Template.jsx
. and underneath line 5, add the following:

import LoginPage from './account/LoginPage';
. add a route under like 15, like this:
          <Route exact path="/account/login" component={LoginPage} />

.Let’s add a form to the Log In page
.Replace <p>this is the log in page</p> with the following code:

      <div className="row justify-content-center">
        <div className="col-10 col-sm-7 col-md-5 col-lg-4">
          <Form>
            <FormGroup>
              <Label for="exampleEmail">Email</Label>
              <Input
                type="email"
                name="email"
                id="exampleEmail"
                placeholder="noreply@musiclist.com"
              />
            </FormGroup>
            <FormGroup>
              <Label for="examplePassword">Password</Label>
              <Input
                type="password"
                name="password"
                id="examplePassword"
                placeholder="password"
              />
            </FormGroup>
            <Button>Log In</Button>
          </Form>
        </div>
      </div>

.Save the file
.Your hot-reloader should’ve hot-reloaded, and you should now be able to see our fancy new Log In page (note: log in page may be less fancy than advertised by the previous sentence)
.I think Bootstrap’s default placeholder text is way too dark, and makes the forms look already filled in, so let’s quickly add the following to musiclist.scss:
$ vim src/css/musiclist.scss 


.form-control::-webkit-input-placeholder { color: #EEE; }
.form-control::-moz-placeholder { color: #EEE; }
.form-control:-ms-input-placeholder { color: #EEE; }
.form-control:-moz-placeholder { color: #EEE; }

#Five Minute React 37 - API Endpoint: Registration

mongo

use musiclist
db.users.remove({})

. install https://www.getpostman.com/apps at /opt

.OK, let’s write some API endpoints
.Oh, and we need to make one quick change to our User model, too: including an email addres

$ vim models/user.js
.under line 10, add 
  email: String,

.  remember that we previously added some Passport connectivity to this model, which is shortly going to allow us to use Passport’s register method

$ vim routes/api/authentication.js
.This is going to hold all of our auth-related endpoints, including registering, so let’s start with that, since right now we don’t have anyone in the database
.Let’s start with these three lines:

const express = require('express');
const passport = require('passport');
const User = require('../../models/user.js');
. here we’re requiring Express, Passport, and our user model

. Below line 3, add a blank line and then, on line 5, this code:
const router = express.Router();

. define our route on line 7, like this:
// POST to /register
router.post('/register', (req, res) => {
});

.It just tells our app to listen for a POST to /register (underneath the rest of our API URI, which we’ll define in a minute)
.Now, let’s use the incoming JSON data and create a user object to save, via our User model (which we use to make sure that only the data we want in our database gets in there, in case the JSON being sent contains excess stuff)
.Here’s the code for that:

// POST to /register
router.post('/register', (req, res) => {
  // Create a user object to save, using values from incoming JSON
  const newUser = new User({
    username: req.body.username,
    firstName: req.body.firstName,
    lastName: req.body.lastName,
    email: req.body.email,
  });
});

. req.body, by the way, will contain all of our incoming JSON data (or form data, if we were sending this via a normal web form, but we’ll be using Ajax to send it as JSON).

// POST to /register
router.post('/register', (req, res) => {
  // Create a user object to save, using values from incoming JSON
  const newUser = new User({
    username: req.body.username,
    firstName: req.body.firstName,
    lastName: req.body.lastName,
    email: req.body.email,
  });

  // Save, via passport's "register" method, the user
  User.register(newUser, req.body.password, (err, user) => {
    // If there's a problem, send back a JSON object with the error
    if (err) {
      return res.send(JSON.stringify({ error: err }));
    }
    // Otherwise, for now, send back a JSON object with the new user's info
    return res.send(JSON.stringify(user));
  });
});

module.exports = router;

.This will allow us to use these new API routes in app.js
.Your entire file, for reference, should look like this:

const express = require('express');
const passport = require('passport');
const User = require('../../models/user.js');

const router = express.Router();

// POST to /register
router.post('/register', (req, res) => {
  // Create a user object to save, using values from incoming JSON
  const newUser = new User({
    username: req.body.username,
    firstName: req.body.firstName,
    lastName: req.body.lastName,
    email: req.body.email,
  });

  // Save, via passport's "register" method, the user
  User.register(newUser, req.body.password, (err, user) => {
    // If there's a problem, send back a JSON object with the error
    if (err) {
      return res.send(JSON.stringify({ error: err }));
    }
    // Otherwise, for now, send back a JSON object with the new user's info
    return res.send(JSON.stringify(user));
  });
});

module.exports = router;

$ vim app.js

. underneath line 24, add the following:
const authentication = require('./routes/api/authentication');
. underneath line 62, add this code:
app.use('/api/authentication', authentication);

.As you can see, the first line brings our authentication router into the app, and the second line says to direct any requests to /api/authentication to it
.Thus, it will currently handle /api/authentication/register
.Any other requests will currently redirect back to the top level of our server, initializing our react app (for example, if you tried localhost:3000/api/authentication/test you’d just end up seeing our Musiclist header with no page content)

. time to create a user and then log him in.

.Switch over to postman:
.1	Set the dropdown from GET to POST
.2	For the URL, use:
. TO REGISTER:
http://localhost:3000/api/authentication/register
. TO LOGIN:
http://localhost:3000/api/authentication/login
. TO LOGOUT:
http://localhost:3000/api/authentication/logout 
.3	Click “body” just below the URL
.4	Click the “raw” radio button
.5	Select “JSON (application/json)” from the dropdown 
	
{
  "username": "administrator",
  "password": "WHATEVERPASSWORDYOUWANT",
  "firstName": "YOURFIRSTNAME",
  "lastName": "YOURLASTNAME",
  "email": "YOURPREFERREDEMAIL"
}
. E.g. REGISTER:
{
  "username": "administrator",
  "password": "hostiaellibro",
  "firstName": "Jane",
  "lastName": "Fonda",
  "email": "fondajane@hotmail.com"
}

#Five Minute React 38 - Log In and Log Out

$ vim routes/api/authentication.js
. add a new route underneath our /register route:

// POST to /login
router.post('/login', (req, res) => {
  passport.authenticate('local')(req, res, () => {
    // If logged in, we should have user info to send back
    if (req.user) {
      return res.send(JSON.stringify(req.user));
    }

    // Otherwise return an error
    return res.send(JSON.stringify({ error: 'There was an error logging in' }));
  });
});
.  Do the login and then send back the logged in user’s info, or if that fails, send an error (error code’s unlikely to ever be called because a bad login, say a mistyped password or nonexistent user, will throw an HTTP 401 unauthorized error which ends the response: We’ll want to catch that  on the React side of things when we write our Ajax code

. make sure your Express server is running, and head over to Postman: use whatever the actual password was that you registered your user with (hostiaellibro)

{ "username": "administrator", "password": "hostiaellibro" }

$ vim routes/api/authentication.js:

// GET to /logout
router.get('/logout', (req, res) => {
  req.logout();
  return res.send(JSON.stringify(req.user));
});

. Postman logout: and you should see it return null.
. Change your code to look like this:
router.get('/logout', (req, res) => {
  console.log(req.user);
  req.logout();
  console.log(req.user);
  return res.send(JSON.stringify(req.user));
});

. to logout: first creates a logged in user session, we just get null here … but we can go look in our node console, and see that it did indeed console log the user object first, and then console logged null after the log out was done

. Remember to delete those two console.logs from your code and re-save the file!

#Five Minute React 39 - A Basic Intro to Redux

.  solution to handling state in React applications called Redux

$ npm add redux@3.7.2 react-redux@5.0.5 redux-devtools@3.4.0

. Redux is, well, Redux. React-Redux contains some bindings we’ll need to make things work. And we’re adding in some Redux-Devtools there because they’ll come in handy later, when we start to break things!

. You start with your application. When an event happens, let’s say a click, your Action Handler for that event (which would be a function you write yourself and embed using an onClick in your JSX code) dispatches what Redux calls an “action” … the thing with actions is that they’re not functional. They are an object that contains information. Redux reads this information and, if your action matches its list of actions it’s watching for (more on this later), updates the Store accordingly. The Store is, as we’ve discussed, React’s name for the state of your application.

. That’s all Redux does. Once it changes the Store, Redux is done and React takes over. React, which is tied into the Store, automatically re-renders parts of your app to account for the change in state.

. We could get into “thunks” here and how a module called Redux-Thunk helps with asynchronous functions, but we don’t need it right now, and may not need it at all for an application with this level of complexity, so we’re going to skip it. You may also have heard of “Sagas” … they’re a pretty awesome solution to lining up and firing off whole bunches of Redux actions. We don’t need ‘em, and aren’t going to cover ‘em. Both are examples of ways to DRY large-scale React apps


#Five Minute React 40 - Setting Up The Store

.  wiring Redux into our React app. To start, we’re going to set up our Store

. Redux calls your application’s state the Store, because it’s where your application’s active data is stored

.(Flux, the general paradigm Facebook established for working with React using a one-way data flow, was originally designed to use multiple stores (one for each group of data you want to work with))

. Redux simplifies things a bit. Your Store is one massive JavaScript object, and you use individual files called “reducers” to adjust it 	
. These files take incoming actions:
	. JavaScript objects with a description and any relevant data
. and “reduce” them down into data for the Store
.  what we want our app state to look like:  need to track: and, for that matter, have the API endpoints necessary to track,  also want to track whether an action is in progress, which doesn’t require an API endpoint

. here’s what our Store’s going to look like at first:

{
  progress: 0,
}

. first thing we’re going to do is just get our application talking to our Store with the simplest amount of state data possible:

$ vim src/reducers/progress.js

.We’re not using .jsx here because reducers are pure JavaScript
.They never contain jsx code or have anything to do with the display layer of our application
.They’re pure data handlers.

.Here’s what progress.js should look like:

const initialState = 0;

export default function reducer(state = initialState, action) {
  switch (action.type) {
    default: {
      return state;
    }
  }
}

.We set an initialState variable to zero (I’ll explain why we’re using an integer here when we get to building actions), then ingest that variable into our reducer function using a nifty ES6 feature where a function argument can take either a value or, if that value is null, assign a default
.We’re also bringing in an action argument, which right now is always going to be undefined, but that’s fine, since the only thing our switch statement is doing is going “no matter what, just return the existing state, which is zero, because that’s the default when we don’t pass anything to the state argument.”

$ mkdir src/store
. this folder will contain one file
.I realize that’s kind of stupid, but it helps keep your brain wrapped around what’s coming from where
$ vim src/store/index.js
.This will simplify imports later on.

import { combineReducers, createStore } from 'redux';

import ProgressReducer from '../reducers/progress';

const combinedReducers = combineReducers({
  progress: ProgressReducer,
});

const Store = createStore(combinedReducers);

export default Store;

.Line by line, here’s what’s going on
.First we’re importing two methods from Redux
.The combineReducers function is used to mash all of our individual reducers into a single big object
.The createStore function turns that object into our Store, which helps wire up a lot of the React automagic.

$ vim src/components/TemplateContainer.jsx
. (capital at the start, as always with components)
.Why are we creating a container for our template? Well, because we need to connect to part of our Store in order to pull data from it and then pass that data down as props
.Whenever you want to connect a component, it’s best to create a container component
.That way, all of your logic lives in the container, and the component itself remains a “dumb” component – all it does is display data passed down to it as props

import React from 'react';
import { connect } from 'react-redux';
import Template from './Template';

function TemplateContainer(props) {
  return (
    <Template progress={props.progress} />
  );
}

function mapStateToProps(state) {
  return {
    progress: state.progress,
  };
}

export default connect(mapStateToProps)(TemplateContainer);

.The top three lines import React, the connect functionality we’re going to need from Redux to connect to our Store, and our Template, which we’ll be calling like any ordinary React component
.Then we have a pure function to render our TemplateContainer component, which takes a props argument
.Then we pass the progress value derived from our props on to the template
.Where’s that value coming from? Further down!

.Our next function takes state data that exists in the store, and turns it into a JavaScript object
.You can name this function whatever you like, but mapStateToProps is default Redux nomenclature, and I recommend using it, since that’s what you’ll see in just about any other Redux app you ever look at.

.Finally, we’re exporting our component … except we’re running it through Redux’s connect functionality first
.This is where the magic happens
.It uses our MapStateToProps function to bind a piece of application state from the Store to our component’s props … without overwriting any other props we might’ve sent down from whatever higher-level component called this one! This is crazy useful not only because it lets us access app state easily, but because it will trigger a component re-render every time app state changes … this means if we increment or decrement our progress integer, the prop will change, the component will re-render, and we can do something with that new data.


$ vim src/components/Template.jsx
. and make two small changes, one of them extremely temporary
.First, on line 9, add a props argument like this:

export default function Template(props) {
. just below the header on line 13, add this line:
        <p>{props.progress}</p>

.This is going to display 0 on the page once we’re all set, proving that our app is now attached to our Store

$ vim src/index.jsx
. it’s time to bring in our TemplateContainer component, instead of our Template component (which is now called by the container)
.Adjust the top five lines to look like this:

// Default export from a module
import React from 'react';
// Individual method exports from a module
import { AppContainer } from 'react-hot-loader';
import { Provider } from 'react-redux';
import { render } from 'react-dom';

// CSS from a module
import 'bootstrap/dist/css/bootstrap.css';
// CSS from a local file
import './css/musiclist.scss';

// Default export from a local file
import Store from './store';

.That adds a provider component we need from Redux and also reorganizes things to be in a more logical order (I added a couple of comments to help explain the ordering)
.It also imports that Store we created earlier
.Now change line 16 from

import Template from './components/Template';
. to: 
import TemplateContainer from './components/TemplateContainer';
. Then wrap line 21 in Provider tags, and remove our test props:
      <Provider store={Store}>
        <Component />
      </Provider>
. Change line 29 from:
renderApp(Template)
. to:
renderApp(TemplateContainer)
. final file should look like this:
// Default export from a module
import React from 'react';
// Individual method exports from a module
import { AppContainer } from 'react-hot-loader';
import { Provider } from 'react-redux';
import { render } from 'react-dom';

// CSS from a module
import 'bootstrap/dist/css/bootstrap.css';
// CSS from a local file
import './css/musiclist.scss';

// Default export from a local file
import Store from './store';

import TemplateContainer from './components/TemplateContainer';

const renderApp = (Component) => {
  render(
    <AppContainer>
      <Provider store={Store}>
        <Component />
      </Provider>
    </AppContainer>,
    document.querySelector('#react-app'),
  );
};

renderApp(TemplateContainer);

if (module && module.hot) {
  module.hot.accept();
}

#Five Minute React 41 - Redux Actions

.Create a file in /src/actions called progress.js … once again, no JSX extension here because this file will be pure JavaScript with no rendering.

{
  type: 'A_UNIQUE_NAME_ALWAYS_IN_CAPS_WITH_UNDERSCORES',
  data: 'some data' // can be a string, array, object, boolean, integer, etc.
}

.The data attribute is optional, but all actions must always have a type or Redux won’t know what to do with them
.Our functions will each generate one action and dispatch it to Redux
.You could generate more than one action in a function, but as often as possible it’s best to break things down into creators that create a single action
.You can always call multiple creators from a separate, larger function.

export const incrementProgress = () => {
  return {
    type: 'INCREMENT_PROGRESS',
  };
};

.That’s a very simple function … so simple in fact that it can be shortened using some nice ES6 shorthand (you may notice ESLint is complaining because we haven’t shortened it yet)
.An arrow function that does nothing except return a value can be done entirely on a single line, omitting not only some braces, but the actual return command as well
.Nuke that code and replace it with this code, which does exactly the same thing:

export const incrementProgress = () => ({ type: 'INCREMENT_PROGRESS' });

const returnTrue = () => true;
const sayHi = (firstName, lastName) => `Hi, ${firstName} ${lastName}!`;
const showLength = myArray => myArray.length;

.You only need to wrap function arguments in parens if there’s more than one of them, which is why myArray has no parens in the last example
.All right, so we’ve got our increment action creator
.Pretty simple, huh? You can probably figure out how to do the decrement function without me providing the code
.In fact, let’s make that a little test
.Try to write it yourself and if you aren’t sure, highlight the following block to see the answer:

export const decrementProgress = () => ({ type: 'DECREMENT_PROGRESS' });

.Save the file and that’s it … our action creators are finished
.Now we need to do two things
.The first is, tell our progress reducer to listen for our actions
.The second is wire our buttons up to fire those creators when we click them
.Open /src/reducers/progress.js and just below the switch statement on line 4, add the following code:

    case 'INCREMENT_PROGRESS': {
      return state + 1;
    }
    case 'DECREMENT_PROGRESS': {
      // Don't go lower than zero
      return Math.max(state - 1, 0);
    }

.Save the file
.See what we’re doing here? We’re watching the type value of our action for certain strings, and then acting upon them
.This is how Redux works
.Every time an action of any sort is passed, it runs through all available reducers to see if the type is matched by any, and if so, it acts upon the state.

.Now we have a choice to make
.We could connect our HomePage component using Redux, which will allow us to access our action creators and trigger them with button clicks, but as we pointed out in our last video, it’s good practice to instead create a container element and then pass the functionality down as props, so let’s do that
.In /src/components/home create a file called HomePageContainer.jsx and add the following code:

import React from 'react';

import { bindActionCreators } from 'redux';
import { connect } from 'react-redux';
import { incrementProgress, decrementProgress } from '../../actions/progress';
import HomePage from './HomePage';

export function HomePageContainer(props) {
  return (
    <HomePage
      incrementFunction={}
      decrementFunction={}
    />
  );
}

.Notice that we’re importing our action creators from our action file
.We can’t just plug these in to the incrementFunction and decrementFunction props we’re passing to our HomePage component, though, because they won’t have Redux’s dispatcher attached to them, which is the functionality that actually sends the actions to the reducer
.So we need to use Redux to bind those action creators to functions we can send as props, which we do by creating another function below our first function, like this:

function mapDispatchToProps(dispatch) {
  return bindActionCreators({
    incrementProgressAction: incrementProgress,
    decrementProgressAction: decrementProgress,
  }, dispatch);
}

export default connect(null, mapDispatchToProps)(HomePageContainer);

.This is where the magic happens
.Now the props argument that our HomePageContainer function takes will include two methods: incrementProgressAction and decrementProgressAction
.Oh, by the way, we need that null there as a placeholder for mapStateToProps, which we’re not using in this particular component
.If you omit it, Redux will think your mapDispatchToProps function is a mapStateToProps function, and then your code will break.

export function HomePageContainer(props) {
  const { incrementProgressAction, decrementProgressAction } = props;
  return (
    <HomePage
      incrementFunction={incrementProgressAction}
      decrementFunction={decrementProgressAction}
    />
  );
}

.See how we’re using variable destructuring to pull those methods out of the props argument? That means we don’t have to write props.incrementProgressAction and props.decrementProgressAction when we call our HomePage component
.We’re done here, and we’re in the home stretch
.Save the file and open /src/components/home/HomePage.jsx
.Delete lines 6 through 8
.We’re not going to be using our test function anymore
.Sorry, Draco.

export default function HomePage(props) {

  const { decrementFunction, incrementFunction } = props;

.And finally, we’re going to go ahead and nuke everything displayed on the page (the two <p> tags and the button), so that your return block looks like this:

  return (
    <div className="row">
      <div className="col-sm-12 col-md-8">
      </div>
      <Sidebar />
    </div>
  );

  return (
    <div className="row">
      <div className="col-sm-12 col-md-8">
        <Button onClick={incrementFunction}>Increment</Button>
        <Button onClick={decrementFunction}>Decrement</Button>
      </div>
      <Sidebar />
    </div>
  );

.Save that file, and we’re on to the final step
.Right now our template is still calling HomePage, not HomePageContainer
.That’s no good, so open /src/components/Template.jsx and change line 5 to:

import HomePage from './home/HomePageContainer';

#Five Minute React 42 - Redux Tools

$ npm add --dev redux-logger@3.0.6 redux-devtools-log-monitor@1.3.0 redux-devtools-dock-monitor@1.1.2

.Let that run, and then switch over to Sublime Text
.First, we’re going to create a DevTools component
.This will be a handy overlay (which can be easily hidden) that will show us step by step what’s happening to our app state, and allow us to do things like step back through the state, or even cancel a single state change in the middle of things
.It’s really useful for seeing exactly how your data’s being mutated
.In /src/components/shared, create a file called DevTools.jsx and add the following code:

import React from 'react';
import LogMonitor from 'redux-devtools-log-monitor';
import DockMonitor from 'redux-devtools-dock-monitor';
import { createDevTools } from 'redux-devtools';

const DevTools = createDevTools(
  <DockMonitor
    toggleVisibilityKey="ctrl-h"
    changePositionKey="ctrl-q"
    defaultIsVisible
  >
    <LogMonitor theme="tomorrow" />
  </DockMonitor>,
);

export default DevTools;

.We’re using two pre-made components here
.LogMonitor contains the state monitoring functionality, and DockMonitor gives us a handy place to display data, allowing us to move it around our window, hide it, and so forth
.Save this file, and we’re ready to move on.

.Open /src/store/index.js
.We’re going to make a bunch of changes, here, including laying the groundwork for hot-reloading when we make changes to our reducers (sweet!)
.There will be more work in a future tutorial to get that going, but we might as well make the change to this particular file while we’re editing it.

.We have quite a few changes to make here, but don’t worry, they’re not complicated
.First, change line 1 by adding applyMiddleware and compose to the list of imports, like this:

import { applyMiddleware, combineReducers, compose, createStore } from 'redux';

import { logger } from 'redux-logger';

.After that, we need to tie our DevTools component in with our Store, so we need to import it
.Above line 4, our ProgressReducer import, add the following code:

import DevTools from '../components/shared/DevTools';

.Our combineReducers block stays the same, because we aren’t adding any new reducers right now
.It’s still just the progress reducer
.Soon we’re going to have more of these, but that’ll be another tutorial.

const enhancer = compose(
  applyMiddleware(logger),
  DevTools.instrument(),
);

const Store = createStore(combinedReducers);

export default Store;

export default function configureStore(initialState) {
  const store = createStore(combinedReducers, initialState, enhancer);

  // Hot reload reducers
  if (module.hot) {
    module.hot.accept('../reducers/progress', () =>
      store.replaceReducer(ProgressReducer),
    );
  }

  return store;
}

import { applyMiddleware, combineReducers, compose, createStore } from 'redux';
import { logger } from 'redux-logger';

import DevTools from '../components/shared/DevTools';
import ProgressReducer from '../reducers/progress';

const combinedReducers = combineReducers({
  progress: ProgressReducer,
});

const enhancer = compose(
  applyMiddleware(logger),
  DevTools.instrument(),
);

export default function configureStore(initialState) {
  const store = createStore(combinedReducers, initialState, enhancer);

  // Hot reload reducers
  if (module.hot) {
    module.hot.accept('../reducers/progress', () =>
      store.replaceReducer(ProgressReducer),
    );
  }

  return store;
}

.Save that file, then open up /src/index.jsx and let’s make some changes
.Find this line:

import Store from './store';

import configureStore from './store';

import DevTools from './components/shared/DevTools';

.In between your import templateContainer and const renderApp lines, add this one:

const Store = configureStore();

        <Component />

        <DevTools />

.Ah, but wait … Provider expects only a single child element
.Why that is, I honestly don’t know, but it’s easy to solve
.That child element can contain as many elements as we want, so all we have to do is wrap Component and DevTools with a simple div tag, like this:

        <div>
          <Component />
          <DevTools />
        </div>

.There we go
.Were all set here
.This is what your whole index.jsx file should look like at this point (I added a bit more spacing up at the top for clarity):

// Default export from a module
import React from 'react';

// Individual exports from a module
import { AppContainer } from 'react-hot-loader';
import { Provider } from 'react-redux';
import { render } from 'react-dom';

// CSS from a module
import 'bootstrap/dist/css/bootstrap.css';

// CSS from a local file
import './css/musiclist.scss';

// Default export from a local file
import DevTools from './components/shared/DevTools';
import configureStore from './store';

// JSX Modules
import TemplateContainer from './components/TemplateContainer';

const Store = configureStore();

const renderApp = (Component) => {
  render(
    <AppContainer>
      <Provider store={Store}>
        <div>
          <Component />
          <DevTools />
        </div>
      </Provider>
    </AppContainer>,
    document.querySelector('#react-app'),
  );
};

renderApp(TemplateContainer);

if (module && module.hot) {
  module.hot.accept();
}

.You can play around with the tools here to get a sense of how they work
.Note that ctrl-h will hide/show the overlay
.You can also check out the DevTools documentation if you want to deep dive into what you can do with these tools.

#Five Minute React 43 - Optimizing for Production Part 1

.Let’s start by opening package.json
.In addition to writing some scripts, we’re going to do a little cleanup, since there are a few things in here now that we no longer need
.Start by removing line 9:

    "start-w": "webpack-dev-server",

.We no longer run a separate dev server for Webpack (we exchanged that for Express middleware instead), so we don’t need that
.Also, we can remove the last line of our devDependencies block, near the bottom of the file:

    "webpack-dev-server": "^2.4.5"

.Hey, notice that whole devDepenencies thing? That’s another thing we can use to reduce the overall size of our application
.If, when we deploy our application to a production server, we run npm install --production , it will ignore the entire devDependencies block and not bother to install any of those modules
.That’s a handy thing to know, and I’ll remind you of it when we get to actually deploying a production build.

.By the way, removing this stuff from package.json does NOT remove it from your node_modules folder
.There are ways to do that with Yarn or NPM, but we’re manually editing package.json right now because we’re shortly going to just nuke node_modules and start over again, which is sometimes easier than trying to keep track of what’s been installed and removed.

.OK, save package.json
.It’s now time to dive into our Webpack config, so open webpack.config.js
.This is not going to be as complicated as you might think … at least, not right away! Our Webpack config file will grow progressively more complex as this series continues and our app takes shape, but that kind of makes sense, right?

if (process.env.NODE_ENV === 'production') {
  module.exports.plugins.push(new webpack.optimize.UglifyJsPlugin());
}

.What’s happening here is we’re checking for our NODE_ENV environment variable, which is available to Node applications via the process.env global variable
.If it’s equal to production, we’re uglifying our JS bundle
.If it’s not, we skip that step, leaving us with unminified code, which is much easier to debug.

.Save this file, and head back to package.json
.We’re going to create a new script, just under our start script
.This will be different depending on whether you’re on Windows or Mac … but not different enough to bother switching between videos
.Here’s the code for Windows:

    "start-prod": "SET NODE_ENV=production&& node ./bin/www",

    "start-prod": "NODE_ENV=production node ./bin/www",

$ npm start

.Asset     Size  Chunks                    Chunk Names
javascripts/build.js  2.74 MB       0  [emitted]  [big]  main
stylesheets/style.css   192 kB       0  [emitted]         main

$ npm run start-prod

.Asset     Size  Chunks                    Chunk Names
javascripts/build.js  1.14 MB       0  [emitted]  [big]  main
stylesheets/style.css   192 kB       0  [emitted]         main

#Five Minute React 44 - Optimizing Part 2

.Let’s start by opening webpack.config.js
.Sick of this file, yet? I don’t blame you, but it’s one of the main parts of our app
.Not quite the heart or brain, but at least the pancreas or liver
.Anyway, we don’t actually have too many changes to make here, but we need to split out hot module reloading so that it’s only run when we run our dev server
.Also, since we’re going to be creating static files for production, we need to adjust our output block
.Let’s do that first
.We’re going to start by creating several ternary operators that check our environment
.A quick reminder on how ternaries work
.They’re basically this:

const final = is a condition met? if yes return X : if no return Y;

const myNumber = 12
const numberDescription = myNumber > 10 ? 'bigger than ten!' : 'not bigger than ten!';

.If you change the value of myNumber, you’ll get one of the two strings based on whether or not the value is, in fact, bigger than ten
.That’s a useless ternary that would actually be better as a function that takes a number argument, but you get the idea
.Let’s write one that’s actually useful
.Add this on line 5:

const cssOutputLocation = process.env.NODE_ENV === 'production' ?
  'public/stylesheets/style-prod.css' :
  'stylesheets/style.css';

.We’re splitting it into multiple lines because ESLint doesn’t like lines over 100 characters long, but it’s still the same approach
.Are we in production? If yes, output a static file called “style-prod.css” to our public folder
.If not, our output will be slightly different since it’ll be served by the Webpack Express middleware
.The correct destination is stored in our cssOutputLocation variable, which we’ll use lower in the file.

.Now we need to do the same for our JavaScript
.This is a little more complex, because the output block isn’t a single line
.Rather than try to stuff a bunch of objects into a ternary, we’re going to create our objects first
.Just below the cssOutputLocation lines, add the following:

const jsProdOutput = {
  filename: 'public/javascripts/build-prod.js',
  path: resolve(__dirname),
  publicPath: '/',
};

const jsDevOutput = {
  filename: 'javascripts/build.js',
  path: '/',
  publicPath: '/',
};

const jsOutputLocation = process.env.NODE_ENV === 'production' ? jsProdOutput : jsDevOutput;

.Excellent
.Now we’ve got cssOutputLocation and jsOuputLocation variables
.We’ll use those in a second
.We could also just go with separate Webpack config files for production or development, and we probably will do exactly that in the long run, but I like doing it conditionally first so we can really get a sense of what the differences are while looking at a single file.

.Now we need to modify our entry block
.Right now it’s always running through a bunch of hot-loading entry points
.That’s not useful for production
.Skip down to the very bottom of the file, and add the following code:

if (process.env.NODE_ENV !== 'production') {
  module.exports.entry.unshift(
    'react-hot-loader/patch',
    'react-hot-loader/babel',
    'webpack-hot-middleware/client',
  );
}

.Array.unshift() sticks stuff at the beginning of an array (as opposed to Array.push() which puts stuff at the end), so now we’re only adding our hot-reloading stuff when we’re not in production
.Well, almost
.Scroll back up, and delete those three lines from your entry block, so it looks like this:

  entry: [
    './index.jsx',
  ],

.Now, when Webpack runs, if it’s not in production, it’ll toss those three lines back in ahead of index.js … but if we are in production, it won’t include them
.This will generate more file size savings
.All right, let’s replace our output block with our jsOutputLocation variable
.Your entire output section should now look like this:

output: jsOutputLocation,

.And let’s do the same for our CSS
.Scroll down to the plugins section, and replace this line:

    new ExtractTextPlugin('stylesheets/style.css'),

    new ExtractTextPlugin(cssOutputLocation),

.There’s only one more thing to do in this file
.Did you notice that we’re still calling the Hot Module Replacement Plugin regardless of whether we’re in prod or dev? Let’s fix that
.Cut that line out of the plugins block, and in the if statement at the bottom of your file, add it below the entry lines, like this:

  module.exports.plugins.unshift(new webpack.HotModuleReplacementPlugin());

if (process.env.NODE_ENV !== 'production') {
  module.exports.entry.unshift(
    'react-hot-loader/patch',
    'react-hot-loader/babel',
    'webpack-hot-middleware/client',
  );
  module.exports.plugins.push(new webpack.HotModuleReplacementPlugin());
}

const { resolve } = require('path');
const webpack = require('webpack');
const ExtractTextPlugin = require('extract-text-webpack-plugin');

const cssOutputLocation = process.env.NODE_ENV === 'production' ?
  'public/stylesheets/style-prod.css' :
  'stylesheets/style.css';

const jsProdOutput = {
  filename: 'public/javascripts/build-prod.js',
  path: resolve(__dirname),
  publicPath: '/',
};

const jsDevOutput = {
  filename: 'javascripts/build.js',
  path: '/',
  publicPath: '/',
};

const jsOutputLocation = process.env.NODE_ENV === 'production' ? jsProdOutput : jsDevOutput;

module.exports = {
  context: resolve(__dirname, 'src'),
  entry: [
    './index.jsx',
  ],
  output: jsOutputLocation,
  resolve: {
    extensions: ['.js', '.jsx'],
  },
  module: {
    rules: [
      {
        test: /\.jsx?$/,
        exclude: /(node_modules|bower_components|public\/)/,
        loader: 'babel-loader',
      },
      {
        test: /\.css/;,
        use: ExtractTextPlugin.extract({
          fallback: 'style-loader',
          use: 'css-loader',
        }),
      },
      {
        test: /\.scss/,
        use: ExtractTextPlugin.extract({
          use: [
            {
              loader: 'css-loader',
            },
            {
              loader: 'sass-loader',
            },
          ],
          fallback: 'style-loader',
        }),
      },
    ],
  },
  plugins: [
    new webpack.NamedModulesPlugin(),
    new webpack.NoEmitOnErrorsPlugin(),
    new ExtractTextPlugin(cssOutputLocation),
  ],
};

if (process.env.NODE_ENV === 'production') {
  module.exports.plugins.push(new webpack.optimize.UglifyJsPlugin());
}

if (process.env.NODE_ENV !== 'production') {
  module.exports.entry.unshift(
    'react-hot-loader/patch',
    'react-hot-loader/babel',
    'webpack-hot-middleware/client',
  );
  module.exports.plugins.push(new webpack.HotModuleReplacementPlugin());
}

.Save it, and then open up app.js
.Find lines 47 through 59, which enable our webpack dev server, and wrap them in a check for a production environment, like this:

// Webpack Server
if (process.env.NODE_ENV !== 'production') {
  const webpackCompiler = webpack(webpackConfig);
  app.use(webpackDevMiddleware(webpackCompiler, {
    publicPath: webpackConfig.output.publicPath,
    stats: {
      colors: true,
      chunks: true,
      'errors-only': true,
    },
  }));
  app.use(webpackHotMiddleware(webpackCompiler, {
    log: console.log,
  }));
}

.There we go
.Now our app will only use the dev server when we’re not in production
.Save this file, and move on to /views/index.ejs
.We need to make some changes here to determine where to look for our CSS and JS files
.Change line 5:

    <link rel='stylesheet' href='/stylesheets/style.css' />

    <% if (process.env.NODE_ENV === 'production') { %>
      <link rel="stylesheet" href="/stylesheets/style-prod.css" />
    <% } else { %>
      <link rel="stylesheet" href="/stylesheets/style.css" />
    <% } %>

    <script src="/javascripts/build.js"></script>

    <% if (process.env.NODE_ENV === 'production') { %>
      <script src="/javascripts/build-prod.js"></script>
    <% } else { %>
      <script src="/javascripts/build.js"></script>
    <% } %>

.Save this file, and open package.json
.It’s time to create scripts to build for production, and run our server in production mode
.We're going to replace line 6 because we don’t build to dev right now, we run a dev server
.Take that line:

      "build-dev": "webpack --config webpack.config.js --progress --profile --colors",

      "build-prod": "SET NODE_ENV=production&&webpack -p --config webpack.config.js",

      "build-prod": "NODE_ENV=production webpack -p --config webpack.config.js",

$ npm run build-prod

.Asset    Size  Chunks                    Chunk Names
public/javascripts/build-prod.js  562 kB       0  [emitted]  [big]  main
public/stylesheets/style-prod.css  148 kB       0  [emitted]         main

$ npm run start-prod

#Five Minute React 45 - Wiring Up Log-In Part 1

$ npm add whatwg-fetch@2.0.3

nodemon npm start

.We’re a ways away from actually sending requests to our API yet
.We’ve got code to write
.Let’s do it! Switch over to Sublime and open up /routes/api/authentication.js … we’re making one quick tweak to our API due to a quirk in Passport, the module we use to authenticate users
.Passport is built to take a username and a password
.This username can be an email, or any other value, but you still have to call it “username” which is confusing
.Also if you do that, it locks you into email-only logins, rather than supporting username OR email logins
.We want to have the latter available (though we’re not going to set it up right now), and we also don’t want to have a variable called “username” which contains an email instead of, well, a username.

const mongoose = require('mongoose');

// configure mongoose promises
mongoose.Promise = global.Promise;

.Now swing down to the top of our login block, which should be line 32 if your spacing matches mine
.We need to make this function work with async await, so the first step is to add async to line 33, like this:

router.post('/login', async (req, res) => {

  // look up the user by their email
  const query = User.findOne({ email: req.body.email });
  const foundUser = await query.exec();

  // if they exist, they'll have a username, so add that to our body
  if (foundUser) { req.body.username = foundUser.username; }

.All right, we’re set here
.Save this file, and then create a new file in /src/components/account called LoginPageContainer.jsx
.This is where we’re going to handle the logic that actually talks to the API, while LoginPage will remain a dumb component that just receives props
.We’ll need to “connect” our container to Redux in order to manipulate the Store, but we’ll get to that in the next tutorial.

.Remember how I told you this tutorial was going to end with nothing really working yet? Yeah, sorry again … we’re getting close to the five minute mark, and the next step would take us into eight or nine minutes, so let’s stop here
.We’ll fill in LoginPageContainer.jsx and make some changes to LoginPage.jsx in our next tutorial
.That’ll get us to a point where we can see something actually happening! Then in the following tutorial, we’ll handle actually doing something once a successful login attempt occurs.

#Five Minute React 46 - Wiring Up Log-In Part 2

.Let’s jump right in
.Your server should still be running from last time, but if it’s not, fire it up in development mode (I think at this point I can stop telling you how to do that, right?)
.Then switch over to Sublime Text and open /src/components/account/LoginPageContainer.jsx
.This file should be blank
.If for some reason it’s not, it means you either decided to forge ahead, or your computer is haunted by ghosts … possibly from the future
.Consider calling an exorcist before continuing.

import React from 'react';
import 'whatwg-fetch';

import { bindActionCreators } from 'redux';
import { connect } from 'react-redux';
import { incrementProgress, decrementProgress } from '../../actions/progress';

import LoginPage from './LoginPage';

.We grab two modules, then some functionality, and then our LoginPage component
.Nothing here should be too confusing, but just a reminder that imports done with curly braces mean you’re pulling individual variables or methods from a file that contains more than one, and that each of them are then accessible within your code by those names (for example, incrementProgress).

export class LoginPageContainer extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      <div>
        <LoginPage loginFunction={this.attemptLogIn} />
      </div>
    );
  }
}

.Don’t worry about the fact that this.attemptLogin doesn’t exist yet
.We’ll fix that in a second
.Below that we’re going to need to connect our component to Redux so we can use those progress actions (not to mention other actions we’re going to write later)
.So, below the component, add the following:

function mapDispatchToProps(dispatch) {
  return bindActionCreators({
    incrementProgressAction: incrementProgress,
    decrementProgressAction: decrementProgress,
  }, dispatch);
}

export default connect(null, mapDispatchToProps)(LoginPageContainer);

.All right, let’s add that attemptLogin method
.Below the constructor block in our component class, but above the render block, add the following:

  async attemptLogIn(userData) {
    const { decrementProgressAction, incrementProgressAction } = this.props;

    // turn on spinner
    incrementProgressAction();

    // contact login API
    const loginResponse = await fetch(
      // where to contact
      '/api/authentication/login',
      // what to send
      {
        method: 'POST',
        body: JSON.stringify(userData),
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'same-origin',
      },
    );

    console.log(loginResponse);

    // turn off spinner
    decrementProgressAction();
  }

.As you can see, we have another async function here, which allows us to use await to make sure we have responses from the server before proceeding
.I love asyc/await so much! You’ll also notice that we turn on and off our spinner here (speaking of which, we’re going to need to turn that into an actual spinner pretty soon!)
.Finally, you may notice that this method takes a userData parameter
.We’ll be providing that in LoginPage.jsx

.One last thing to do here
.We need to bind this method so it can use “this” correctly
.We do that in the constructor block by adding a line after line 12 for padding, and then adding the following two lines:

    // bound functions
    this.attemptLogIn = this.attemptLogIn.bind(this);

import React from 'react';
import 'whatwg-fetch';

import { bindActionCreators } from 'redux';
import { connect } from 'react-redux';
import { incrementProgress, decrementProgress } from '../../actions/progress';

import LoginPage from './LoginPage';

export class LoginPageContainer extends React.Component {
  constructor(props) {
    super(props);

    // bound functions
    this.attemptLogIn = this.attemptLogIn.bind(this);
  }

  async attemptLogIn(userData) {
    const { decrementProgressAction, incrementProgressAction } = this.props;

    // turn on spinner
    incrementProgressAction();

    // contact login API
    const loginResponse = await fetch(
      // where to contact
      '/api/authentication/login',
      // what to send
      {
        method: 'POST',
        body: JSON.stringify(userData),
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'same-origin',
      },
    );

    console.log(loginResponse);

    // turn off spinner
    decrementProgressAction();
  }

  render() {
    return (
      <div>
        <LoginPage loginFunction={this.attemptLogIn} />
      </div>
    );
  }
}

function mapDispatchToProps(dispatch) {
  return bindActionCreators({
    incrementProgressAction: incrementProgress,
    decrementProgressAction: decrementProgress,
  }, dispatch);
}
export default connect(null, mapDispatchToProps)(LoginPageContainer);

.All right, save the file and then open up /src/components/account/LoginPage.jsx … there’s a bunch to do here as well
.Remember how ESLint was complaining that we didn’t need to use a class, here? Well, now we do, because we’re going to be manipulating component state to create “controlled” forms
.This means React handles their values, even when a user is manipulating them
.Every change is stored in component state, and the forms always render what’s in that state, meaning if you change it programmatically, they’ll display the new string automatically.

.In your constructor block, under the super line, add the following:

    // component state
    this.state = {
      email: '',
      password: '',
    };

.This sets our component state, which we talked about before in Tutorial 35
.Now we need some methods to manipulate things
.Below your constructor block, but above your render block, add the following lines of code:

  // update state as email value changes
  handleEmailChange(e) {
    this.setState({ email: e.target.value });
  }

  // update state as password value changes
  handlePasswordChange(e) {
    this.setState({ password: e.target.value });
  }

  compileFormData() {
    const { loginFunction } = this.props;
    const formData = this.state;
    loginFunction(formData);
  }

.We need to bind these functions, so back up in our constructor block, below the super line and above the state declaration, add this code:

    // bound functions
    this.compileFormData = this.compileFormData.bind(this);
    this.handleEmailChange = this.handleEmailChange.bind(this);
    this.handlePasswordChange = this.handlePasswordChange.bind(this);

.Last thing we need to do is update our form fields and submit button in our render block
.Here’s the change for the email field:

              <Input
                type="email"
                name="email"
                id="userEmail"
                placeholder="noreply@musiclist.com"
                value={this.state.email}
                onChange={this.handleEmailChange}
              />

              <Input
                type="password"
                name="password"
                id="userPassword"
                placeholder="password"
                value={this.state.password}
                onChange={this.handlePasswordChange}
              />

<Button onClick={this.compileFormData}>Log In</Button>

import React from 'react';
import { Button, Form, FormGroup, Label, Input } from 'reactstrap';

export default class LoginPage extends React.Component {
  constructor(props) {
    super(props);

    // bound functions
    this.compileFormData = this.compileFormData.bind(this);
    this.handleEmailChange = this.handleEmailChange.bind(this);
    this.handlePasswordChange = this.handlePasswordChange.bind(this);

    // component state
    this.state = {
      email: '',
      password: '',
    };
  }

  // update state as email value changes
  handleEmailChange(e) {
    this.setState({ email: e.target.value });
  }

  // update state as password value changes
  handlePasswordChange(e) {
    this.setState({ password: e.target.value });
  }

  compileFormData() {
    const { loginFunction } = this.props;
    const formData = this.state;
    loginFunction(formData);
  }

  render() {
    return (
      <div className="row justify-content-center">
        <div className="col-10 col-sm-7 col-md-5 col-lg-4">
          <Form>
            <FormGroup>
              <Label for="userEmail">Email</Label>
              <Input
                type="email"
                name="email"
                id="userEmail"
                placeholder="noreply@musiclist.com"
                value={this.state.email}
                onChange={this.handleEmailChange}
              />
            </FormGroup>
            <FormGroup>
              <Label for="userPassword">Password</Label>
              <Input
                type="password"
                name="password"
                id="userPassword"
                placeholder="password"
                value={this.state.password}
                onChange={this.handlePasswordChange}
              />
            </FormGroup>
            <Button onClick={this.compileFormData}>Log In</Button>
          </Form>
        </div>
      </div>
    );
  }
}

.Save this file, and open /src/components/Template.jsx
.We need to change line 6 so that instead of importing LoginPage.jsx, it imports LoginPageContainer.jsx, like this:

import LoginPage from './account/LoginPageContainer';

.Save that and open .babelrc
.We need to configure the env preset so it won't barf out an error when it tries to process async / await
.Just change the entire file to look like this:

{
  "presets": [
    "react",
    [
      "env", {
        "targets": {
          "browsers": ["last 2 Chrome versions"]
        }
      }
    ],
  ],
}

#Five Minute React 47 - Wiring Up Log-In Part 3

.This one’s going to run a bit long, so let’s get going
.First we’re going to create some actions
.In /src/actions create a file called authentication.js
.We’ll be using three action creator functions in this file
.Here they are:

export const loginAttempt = () => ({ type: 'AUTHENTICATION_LOGIN_ATTEMPT' });
export const loginFailure = error => ({ type: 'AUTHENTICATION_LOGIN_FAILURE', error });
export const loginSuccess = json => ({ type: 'AUTHENTICATION_LOGIN_SUCCESS', json });

.Note that the latter two functions are a little different than any action creators we’ve made so far, because they take arguments
.This will allow us to pass certain data on to our state
.Note also that with ES6 arrow functions, if you only have one argument, you don’t have to put parens around it
.If you have two or more, or if you have none, like loginAttempt then you need the parens
.It’s a little confusing but you’ll get used to it, especially if you installed ESLint for Sublime, because it will complain to you if you break convention.

.We’re done with this file
.Easy, right? Now let’s create a reducer to listen to those actions
.In /src/reducers, create a file named … well, authentication.js
.There’s a lot of filename overlap here
.Fortunately if you have multiple files with the same name opened in Sublime, the tabs will tell you where they’re located.

.This file needs to listen for our three actions
.It also needs to define a default state, which is a little more complex than the 0 we defined as the default state for our progress reducer
.So let’s start there with this code:

const initialState = {
  firstName: '',
  id: '',
  isLoggedIn: false,
  isLoggingIn: false,
  lastName: '',
  username: '',
};

export default function reducer(state = initialState, action) {
  switch (action.type) {
    case 'AUTHENTICATION_LOGIN_ATTEMPT': {
      const newState = Object.assign({}, state);
      newState.isLoggingIn = true;
      return newState;
    }
    case 'AUTHENTICATION_LOGIN_FAILURE': {
      const newState = {
        firstName: '',
        id: '',
        isLoggedIn: false,
        isLoggingIn: false,
        lastName: '',
        username: '',
      };
      return newState;
    }
    case 'AUTHENTICATION_LOGIN_SUCCESS': {
      const newState = Object.assign({}, state);
      newState.firstName = action.json.firstName;
      newState.id = action.json._id;
      newState.isLoggedIn = true;
      newState.isLoggingIn = false;
      newState.lastName = action.json.lastName;
      newState.username = action.json.username;
      return newState;
    }
    default: {
      return state;
    }
  }
}

.This is big and a little ugly
.There are utilities such as lodash or Immutable that we could use to shorten this code a little bit, and remove the need to use Object.assign() in order to ensure that we always work with brand new objects rather than directly manipulating the state variable, but for right now I’m going with verbose code so you can see exactly what’s happening
.Let’s take it case-by-case.

.Save this file and let’s wire it into our Store
.Open up /src/store/index.js
.Below line 4, add the following code:

import AuthenticationReducer from '../reducers/authentication';

  authentication: AuthenticationReducer,

.That’s it
.We’re just importing our reducer and adding it to the combineReducers function
.Save this file, and let’s move on
.Next up is /src/components/account/LoginPageContainer.jsx, and this is where the bulk of our new code’s going to happen.

import { Redirect } from 'react-router-dom';

import { loginAttempt, loginSuccess, loginFailure } from '../../actions/authentication';

.Now we need to connect them to the component, so scroll to the bottom of the file and find line 60:

    decrementProgressAction: decrementProgress,

    loginAttemptAction: loginAttempt,
    loginFailureAction: loginFailure,
    loginSuccessAction: loginSuccess,

    // component state
    this.state = {
      redirect: false,
    };

    const { decrementProgressAction, incrementProgressAction } = this.props;

    const {
      decrementProgressAction,
      incrementProgressAction,
      loginAttemptAction,
      loginFailureAction,
      loginSuccessAction,
    } = this.props;

    incrementProgressAction();

    // register that a login attempt is being made
    loginAttemptAction();

.This will change the isLoggingIn value in our Store from false to true
.In order to change it back to false, we’ll need to execute either loginSuccessAction or loginFailureAction
.To do this, we’re going to use the built in promises that fetch provides, which let us string .then() methods that it will execute sequentially as each one completes.

    const loginResponse = await fetch(

    await fetch(

    .then((response) => {
      if (response.status === 200) {
        return response.json();
      }
      return null;
    })

    .then((json) => {
      if (json) {
        loginSuccessAction(json);
        this.setState({ redirect: true });
      } else {
        loginFailureAction(new Error('Authentication Failed'));
      }
    })

.This is saying “now that we either have JSON, or null, check and see which we have and then fire the appropriate action.” So if we do indeed have JSON, then we fire off loginSuccessAction, passing the user JSON along, and then we set redirect to true in our component state (we’ll do the actual redirect below)
.If we have null, we fire loginFailureAction with a new error message, which, again, we’ll be displaying in a later tutorial.

    .catch((error) => {
      loginFailureAction(new Error(error));
    });

.This again fires loginFailureAction which in turn sets our state back to default
.Note that the closing semi-colon that we deleted a minute ago shows up here, closing the fetch block.

    console.log(loginResponse);

  render() {
    const { redirect } = this.state;

    if (redirect) {
      return (
        <Redirect to="/" />
      );
    }

    return (
      <div>
        <LoginPage loginFunction={this.attemptLogIn} />
      </div>
    );
  }

.Do you see what’s happening here? If our component state redirect variable is true, we render a Redirect component (which in turn just alerts our router to bounce us to the homepage)
.If the redirect variable is not true, we render our login page as expected
.Remember, we only set our redirect variable to true when a login is successful, so that user doesn’t need to be on the login page anymore.

import React from 'react';
import 'whatwg-fetch';
import { Redirect } from 'react-router-dom';

import { bindActionCreators } from 'redux';
import { connect } from 'react-redux';
import { incrementProgress, decrementProgress } from '../../actions/progress';
import { loginAttempt, loginSuccess, loginFailure } from '../../actions/authentication';

import LoginPage from './LoginPage';

export class LoginPageContainer extends React.Component {
  constructor(props) {
    super(props);

    // bound functions
    this.attemptLogIn = this.attemptLogIn.bind(this);

    // component state
    this.state = {
      redirect: false,
    };
  }

  async attemptLogIn(userData) {
    const {
      decrementProgressAction,
      incrementProgressAction,
      loginAttemptAction,
      loginFailureAction,
      loginSuccessAction,
    } = this.props;

    // turn on spinner
    incrementProgressAction();

    // register that a login attempt is being made
    loginAttemptAction();

    // contact login API
    await fetch(
      // where to contact
      '/api/authentication/login',
      // what to send
      {
        method: 'POST',
        body: JSON.stringify(userData),
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'same-origin',
      },
    )
    .then((response) => {
      if (response.status === 200) {
        return response.json();
      }
      return null;
    })
    .then((json) => {
      if (json) {
        loginSuccessAction(json);
        this.setState({ redirect: true });
      } else {
        loginFailureAction(new Error('Authentication Failed'));
      }
    })
    .catch((error) => {
      loginFailureAction(new Error(error));
    });

    // turn off spinner
    decrementProgressAction();
  }

  render() {
    const { redirect } = this.state;

    if (redirect) {
      return (
        <Redirect to="/" />
      );
    }

    return (
      <div>
        <LoginPage loginFunction={this.attemptLogIn} />
      </div>
    );
  }
}

function mapDispatchToProps(dispatch) {
  return bindActionCreators({
    incrementProgressAction: incrementProgress,
    decrementProgressAction: decrementProgress,
    loginAttemptAction: loginAttempt,
    loginFailureAction: loginFailure,
    loginSuccessAction: loginSuccess,
  }, dispatch);
}

export default connect(null, mapDispatchToProps)(LoginPageContainer);

#Five Minute React 48 - Displaying User Information

.Let’s jump right in by turning our incrementing/decrementing number into an actual loading spinner
.We’re going to do this entirely with CSS and no images, but first, we need some HTML
.Open up /src/components/Template.jsx
.Find our current props.progress display on line 14:

        <p>{props.progress}</p>

and nuke the entire thing from orbit like it was an alien-infested mining colony. Next up, just below line 18, our <section> tag, add this code:

        <div className="loader-wrapper" style={props.progress > 0 ? { display: 'block' } : { display: 'none' }}>
          <div className="loader-box">
            <div className="loader">Loading...</div>
          </div>
        </div>

.Save this file
.We’ll be coming back to it in a bit, but for now let’s add some CSS
.Open up /src/css/musiclist.scss and get ready to add a whole crapload of code
.We’re borrowing our CSS, with a few slight modifications, from Luke Haas, who created a bunch of css-only spinners.

/* Spinner */
.loader-wrapper {
  overflow: hidden;
  position: fixed;
  top: 10px;
  z-index: 90;
  width: 100%;
  text-align: center;
  display: none;

  .loader-box {
    width: 40px;
    height: 40px;
    overflow: hidden;
    margin: 0 auto;

    .loader,
    .loader:after {
      border-radius: 50%;
      width: 10em;
      height: 10em;
    }

    .loader {
      margin: 0;
      font-size: 3.5px;
      position: relative;
      text-indent: -9999em;
      border-top: 1.1em solid rgba(155,155,155, 0.2);
      border-right: 1.1em solid rgba(155,155,155, 0.2);
      border-bottom: 1.1em solid rgba(155,155,155, 0.2);
      border-left: 1.1em solid #999;
      -webkit-transform: translateZ(0);
      -ms-transform: translateZ(0);
      transform: translateZ(0);
      -webkit-animation: load8 1.1s infinite linear;
      animation: load8 1.1s infinite linear;
    }

    @-webkit-keyframes load8 {
      0% {
        -webkit-transform: rotate(0deg);
        transform: rotate(0deg);
      }
      100% {
        -webkit-transform: rotate(360deg);
        transform: rotate(360deg);
      }
    }

    @keyframes load8 {
      0% {
        -webkit-transform: rotate(0deg);
        transform: rotate(0deg);
      }
      100% {
        -webkit-transform: rotate(360deg);
        transform: rotate(360deg);
      }
    }
  } /* loader-box */
} /* loader-wrapper */

.Cool
.Let’s make our header swap between a “log in” link and some “Welcome, [firstName]” text
.Open up /src/components/TemplateContainer.jsx
.We’re going to need to map our authentication state to props, so under line 13, add the following:

    authentication: state.authentication,

  const { authentication, progress } = props;

    <Template progress={props.progress} />

    <Template progress={progress} authentication={authentication} />

.Save the file, and then head back to /src/components/Template.jsx
.We’re just going to continue bouncing our authentication prop on down the chain to the header, where we’ll handle display
.Let’s do some variable destructuring here, too
.Below line 9, add this code:

  const { authentication, progress } = props;

        <Header username="anonymous" />

        <Header username="anonymous" authentication={authentication} />

        <div className="loader-wrapper" style={props.progress > 0 ? { display: 'block' } : { display: 'none' }}>

        <div className="loader-wrapper" style={progress > 0 ? { display: 'block' } : { display: 'none' }}>

.We’re good here, so save the file
.Now that we’re passing the authentication block all the way down to the header, let’s use it
.Open up /src/components/shared/Header.jsx
.First we’re going to create two helper functions
.These guys don’t need access to this from our class, so they can just be free-standing functions that take an argument (or don’t)
.Below line 4, add a padding line and then add this code:

const renderLogin = () => <NavLink tag={Link} to="/account/login">Log In</NavLink>;
const renderGreeting = name => <span>Welcome, {name}</span>;

.Your class should start on line 8
.To it, we need to add some variable destructing just under the render() method, which with my spacing is line 25
.So, just below it, add this code:

    const { isLoggedIn, firstName } = this.props.authentication;

                <NavLink tag={Link} to="/account/login">Log In</NavLink>

                { isLoggedIn ? renderGreeting(firstName) : renderLogin() }

.If you’re logged out and on the homepage, and have hidden your developer tools with ctrl-h, you should see your log in link
.Click it, and perform a successful login
.You’ll see two things happen
.First, the spinner will probably flash on screen for a split second
.Second, once you’re forwarded back to the home page, you should see your welcome text using whatever value you entered for firstName when you created your admin user.

#Five Minute React 49 - Intro to Component Lifecycle

.Jump into sublime and open up /api/authentication.js
.I’ve been lax about keeping things alphabetical, here, so let’s reorder it quickly
.I like to do GETs first, then POSTs
.Change around your blocks so the GET to /logout comes first, then the POST to /login, then the POST to /register
.Hooray, organization!

// GET to /checksession
router.get('/checksession', (req, res) => {
  if (req.user) {
    return res.send(JSON.stringify(req.user));
  }
  return res.send(JSON.stringify({}));
});

.Now we need to hit this endpoint
.Save this file and let’s create some new actions
.Open /src/actions/authentication.js and add the following lines to the bottom of the file:

export const sessionCheckFailure = () => ({ type: 'AUTHENTICATION_SESSION_CHECK_FAILURE' });
export const sessionCheckSuccess = json => ({ type: 'AUTHENTICATION_SESSION_CHECK_SUCCESS', json });

.That’s easy enough, right? One action to send if our API returns no active session, and one action to send if it returns a user
.Save this file, and then move on to /src/reducers/authentication.js
.We need to add catches for our two new actions
.First, DELETE lines 17 to 27
.We’re going to shorten this file quite a bit, by piggybacking on existing code
.Now, under line 16, add the following:

    case 'AUTHENTICATION_LOGIN_FAILURE':
    case 'AUTHENTICATION_SESSION_CHECK_FAILURE': {
      const newState = Object.assign({}, initialState);
      return newState;
    }

.Here we’re taking advantage of how JavaScript switch statements let you use the same code for two or more different cases
.In this case, we want to do the same thing whether the session check fails or a login attempt fails: replace our user state with blank values
.We do that by borrowing the values defined in initialState above, but using Object.assign() to create a brand new object to return
.You should always return brand new objects in reducers, to help avoid corruption in your state data.

    case 'AUTHENTICATION_LOGIN_SUCCESS':  {

    case 'AUTHENTICATION_LOGIN_SUCCESS':
    case 'AUTHENTICATION_SESSION_CHECK_SUCCESS': {

.We’re good here
.Save the file and open up /src/components/TemplateContainer.jsx
.We’ve got a lot of work to do here, including converting this component from a pure function to a class
.First we need a couple of imports, so under line 1, add the following:

import { bindActionCreators } from 'redux';

import { sessionCheckFailure, sessionCheckSuccess } from '../actions/authentication';

.Now we need to connect those two new actions, so we need a mapDispatchToProps function
.Let’s add a padding line below line 12, and then put it on line 14
.Here’s the code:

function mapDispatchToProps(dispatch) {
  return bindActionCreators({
    sessionCheckFailureAction: sessionCheckFailure,
    sessionCheckSuccessAction: sessionCheckSuccess,
  }, dispatch);
}

.And of course we need to add mapDispatchToProps to our connect function on line 27, like this:

export default connect(mapStateToProps, mapDispatchToProps)(TemplateContainer);

function TemplateContainer(props) {

class TemplateContainer extends React.Component {

.We’ll need a constructor, so under line 7, add the following code:

  constructor(props) {
    super(props);
  }

.ESLint will complain that this constructor is useless
.Don’t worry, that won’t last
.Also, our return block is now broken, because it needs to be wrapped in a render() method
.Change lines 12-15 to look like this:

  render() {
    const { authentication, progress } = this.props;
    return (
      <Template progress={progress} authentication={authentication} />
    );
  }

.It’s time to write our method for checking sessions
.This one’s big, but very similar to the async method we wrote for our log-in page container
.Put it below the constructor, but above the render block
.Here it is:

  async checkSession() {
    const { sessionCheckFailureAction, sessionCheckSuccessAction } = this.props;
    // contact the API
    await fetch(
      // where to contact
      '/api/authentication/checksession',
      // what to send
      {
        method: 'GET',
        credentials: 'same-origin',
      },
    )
    .then((response) => {
      if (response.status === 200) {
        return response.json();
      }
      return null;
    })
    .then((json) => {
      if (json.username) {
        sessionCheckSuccessAction(json);
      } else {
        sessionCheckFailureAction();
      }
    })
    .catch((error) => {
      sessionCheckFailureAction(error);
    });
  }

.That credentials: 'same-origin' line is important
.Without it, fetch doesn’t send along the session cookie stored in the browser, which will make Express think the request is coming from a new session every time, so you’ll always get a blank object returned from your API.

    // bound functions
    this.checkSession = this.checkSession.bind(this);

.The second thing is that we need to actually fire checkSession! We’re going to do this using something called a component lifecycle method
.These are specially-named functions that React will automatically run at certain times as a component is mounted (that is: made active) and unmounted
.For example, our Log In page component is only mounted when we’re actively viewing the log in page
.When we’re viewing, say, the home page, the Log In page component is unmounted; React essentially forgets it exists until we navigate to it again
.This helps with memory management, among other things.

constructor()
componentWillMount()
render()
componentDidMount()

.This means if you put code in componentWillMount() it is guaranteed to run before the component renders, and if you put code in componentDidMount() it is guaranteed to run afterwards
.That’s super useful, and you’ll find yourself using component lifecycle methods frequently as you build React apps
.Today we only need one – we want to check for a session before we mount our Template Container
.It’s general practice to put lifecycle methods above custom methods, so, above the checkSession method, add the following:

  componentWillMount() {
    // Before the component mounts, check for an existing user session
    this.checkSession();
  }

import React from 'react';
import { bindActionCreators } from 'redux';
import { connect } from 'react-redux';
import Template from './Template';
import { sessionCheckFailure, sessionCheckSuccess } from '../actions/authentication';

class TemplateContainer extends React.Component {
  constructor(props) {
    super(props);

    // bound functions
    this.checkSession = this.checkSession.bind(this);
  }

  componentWillMount() {
    // Before the component mounts, check for an existing user session
    this.checkSession();
  }

  async checkSession() {
    const { sessionCheckFailureAction, sessionCheckSuccessAction } = this.props;
    // contact the API
    await fetch(
      // where to contact
      '/api/authentication/checksession',
      // what to send
      {
        method: 'GET',
        credentials: 'same-origin',
      },
    )
    .then((response) => {
      if (response.status === 200) {
        return response.json();
      }
      return null;
    })
    .then((json) => {
      if (json.username) {
        sessionCheckSuccessAction(json);
      } else {
        sessionCheckFailureAction();
      }
    })
    .catch((error) => {
      sessionCheckFailureAction(error);
    });
  }

  render() {
    const { authentication, progress } = this.props;
    return (
      <Template progress={progress} authentication={authentication} />
    );
  }
}

function mapDispatchToProps(dispatch) {
  return bindActionCreators({
    sessionCheckFailureAction: sessionCheckFailure,
    sessionCheckSuccessAction: sessionCheckSuccess,
  }, dispatch);
}

function mapStateToProps(state) {
  return {
    progress: state.progress,
    authentication: state.authentication,
  };
}

export default connect(mapStateToProps, mapDispatchToProps)(TemplateContainer);

.Save this file, then flip to a terminal window quickly and manually reset your server (if you’re running nodemon, just type rs and hit enter)
.This will make sure we’ve cleared any sessions
.Now head to your browser, and hard-refresh your page
.No user session, and a log in link
.That’s what we want.

#Five Minute React 50 - Logging Out

.First off, open up /src/actions/authentication.js
.We’re going to add two new action creator functions
.I like to keep things alphabetical, so add them below line 3
.Here they are:

export const logoutFailure = error => ({ type: 'AUTHENTICATION_LOGOUT_FAILURE', error });
export const logoutSuccess = () => ({ type: 'AUTHENTICATION_LOGOUT_SUCCESS' });

.That’s all we need here, and by now it should be pretty obvious what those two functions are doing
.We don’t have to pass anything with logoutSuccess because, well, there’s not going to be a returned user.

.Save this file and open up /src/reducers/authentication.js
.We need to listen for our two actions, here
.We can piggyback on the log-in failure and session check failure cases for a log-out success because they create the desired effect: an empty authentication object in our Store
.So, remove the opening brace from line 18 and then, below it, add this code:

    case 'AUTHENTICATION_LOGOUT_SUCCESS': {

    case 'AUTHENTICATION_LOGOUT_FAILURE': {
      // todo: handle error!
      return state;
    }

.We haven’t gotten to error handling yet
.That’s going to come soon, but after we do the cleanup I already mentioned
.For right now, we’re done with this file
.Save it, and let’s move on
.We’re going to create a container file for our Header, because we’re about to get logical up in here
.Create a new file in /src/components/shared called HeaderContainer.jsx
.We’re going to start, as usual, with a bunch of imports
.Here they are:

import React from 'react';
import { bindActionCreators } from 'redux';
import { connect } from 'react-redux';
import { incrementProgress, decrementProgress } from '../../actions/progress';
import { logoutFailure, logoutSuccess } from '../../actions/authentication';

import Header from './Header';

class HeaderContainer extends React.Component {
  constructor(props) {
    super(props);

    this.logUserOut = this.logUserOut.bind(this);
  }

  render() {
    const { authentication } = this.props;
    return (
      <Header authentication={authentication} logUserOut={this.logUserOut} />
    );
  }
}

.You’ll probably note that we’re binding a “logUserOut” function that doesn’t actually exist (and also referencing it in our Header component in the render block)
.So let’s create that
.Under your constructor block but above the render block, add the following
.It should look pretty familiar:

  async logUserOut() {
    const {
      decrementProgressAction,
      incrementProgressAction,
      logoutFailureAction,
      logoutSuccessAction,
    } = this.props;

    // turn on spinner
    incrementProgressAction();

    // contact the API
    await fetch(
      // where to contact
      '/api/authentication/logout',
      // what to send
      {
        method: 'GET',
        credentials: 'same-origin',
      },
    )
    .then((response) => {
      if (response.status === 200) {
        return logoutSuccessAction();
      }
      return logoutFailureAction(`Error: ${response.status}`);
    })
    .catch((error) => {
      logoutFailureAction(error);
    });

    // turn off spinner
    decrementProgressAction();
  }

.Anyway, I’m getting ahead of things again
.For now, we need to connect these actions to Redux, which means a mapDispatchToProps and a connect
.These lines go below your function:

function mapDispatchToProps(dispatch) {
  return bindActionCreators({
    incrementProgressAction: incrementProgress,
    decrementProgressAction: decrementProgress,
    logoutFailureAction: logoutFailure,
    logoutSuccessAction: logoutSuccess,
  }, dispatch);
}

export default connect(null, mapDispatchToProps)(HeaderContainer);

.That’s it for this file
.Save it
.Now we need to change our Template over from calling our Header, to our Header Container, so open /src/components/Template.jsx and let’s make a few quick changes
.Line 4 changes from:

import Header from './shared/Header';

import HeaderContainer from './shared/HeaderContainer';

        <Header authentication={authentication} />

        <HeaderContainer authentication={authentication} />

.That’s it
.Save the file, and open up /src/components/shared/Header.jsx
.We need to make some modifications here in order to create and wire up a log out link
.First we have to move renderGreeting into our class
.I’ll explain why in a second
.Delete line 6 entirely, and then under your constructor block, add the following:

  renderGreeting(name) {
    return (
      <span>
        Welcome, {name} | <a href="/logout" onClick={this.logOutClick}>Log Out</a>
      </span>
    );
  }

.That this.logOutclick is why we need this functionality moved into the class
.We’re about to create that method, and referencing it in an external function would be a pain.

.Let’s create it
.Just above renderGreeting (but still below the constructor), add the following:

  logOutClick(e) {
    e.preventDefault();
    const { logUserOut } = this.props;
    logUserOut();
  }

.So … this seems weird, right? Why not just call logUserOut right from the link’s onClick attribute? The reason is because we can’t catch events in the parent container, so we’d get forwarded to /logout (a page that doesn’t exist) whenever we clicked
.This would be a problem no matter if you used a pound sign, or any other URL in there
.So in order to catch the click and run preventDefault() on it, we need this helper function.

    this.toggleNavbar = this.toggleNavbar.bind(this);

    this.logOutClick = this.logOutClick.bind(this);
    this.renderGreeting = this.renderGreeting.bind(this);

                { isLoggedIn ? renderGreeting(firstName) : renderLogin() }

add a this to renderGreeting, like this:

                { isLoggedIn ? this.renderGreeting(firstName) : renderLogin() }

#Five Minute React 51 - Asynchronous Actions

.Let’s start with a quick fix, though
.I’m tired of Nodemon reloading our node server every time we change a .js file that’s intended for the front-end! So, create a file at the top level called nodemon.json
.It should look like this:

{
  "verbose": true,
  "ignore": ["src/*"]
}

$ npm add redux-thunk@2.2.0

and hitting enter. Once that’s installed, restart your server with nodemon npm start. You should be all set! No longer will the entire express server reset every time you save an action, reducer, etc.

.Head back to Sublime and let’s get into React stuff
.First we need to create a root reducer file, which is basically just a top-level file the combines all of our reducers
.We’re currently doing this right in the Store, but it’s better to do it in a separate file because it’s both cleaner and makes it easier to keep hot-reloading on reducers working
.So, in /src/reducers, create a file called index.js, and add this code:

import { combineReducers } from 'redux';
import AuthenticationReducer from '../reducers/authentication';
import ProgressReducer from '../reducers/progress';

const reducers = {
  authentication: AuthenticationReducer,
  progress: ProgressReducer,
};

export default combineReducers(reducers);

.Now that we’re exporting this functionality from here, we need to remove it from our Store file and import it there instead, so save this file, open up /src/store/index.js, and let’s get to work
.First off, add a new line at the very top of the file to reference the module we just installed:

import thunkMiddleware from 'redux-thunk';

.As this implies, Redux-Thunk is middleware for Redux, meaning it runs in the middle of Redux’s various operations
.In this case, it’s going to allow us to pass around the dispatch function and call it manually instead of having Redux call it for us
.This opens up asynchronous code within the actions because now Redux is no longer in charge of deciding what gets dispatched, and when
.Of course, that means we now have to make those decisions
.Fortunately, it’s not too tough.

.Moving on, we can remove combineReducers from the imports on line 2, because we’re now using that in /src/reducers/index.js and won’t need it here anymore
.Leave the other three methods, though
.We also need to change line 3 a bit
.Instead of getting the logger directly from redux-logger, we want their createLogger method instead
.This will help us set things up to play nicely with Redux-Thunk.

.There should be a blank link between line 3 and 5, separating imports that pull things out of modules from imports that pull directly from our code
.Keep that blank line, but above the DevTools import, we need to bring in our combined reducers, so add this code:

import combinedReducers from '../reducers';

.We can now also delete lines 7 and 8 since we’re importing combinedReducers instead of importing each reducer manually
.So now, your imports should use a total of six lines and look like this:

import thunkMiddleware from 'redux-thunk';
import { applyMiddleware, createStore, compose } from 'redux';
import { createLogger } from 'redux-logger';

import combinedReducers from '../reducers';
import DevTools from '../components/shared/DevTools';

.Just below that, on lines 8-11, is the now-duplicate combineReducers code that we no longer want
.Nuke that entirely, and replace it with this single line:

const loggerMiddleware = createLogger();

.Now we need to adjust our enhancer block to include our thunkMiddleware and loggerMiddleware variables
.Here’s the entire block:

const enhancer = compose(
  applyMiddleware(
    thunkMiddleware,
    loggerMiddleware,
  ),
  DevTools.instrument(),
);

    module.hot.accept('../reducers/progress', () =>
      store.replaceReducer(ProgressReducer),

    module.hot.accept('../reducers', () =>
      store.replaceReducer(combinedReducers),

.Save this file and let’s head on to /src/components/shared/HeaderContainer.jsx
.This file’s about to get a lot smaller! We’re going to move all of the API stuff over to our action file
.The way I would do it is to cut-and-paste, then adjust, so … let’s do that
.Grab the entire async logUserOut block, from line 16 to line 49, and cut it
.Then open /src/actions/authentication.js and just paste that block into the bottom of the file
.Don’t save it yet since we’re not done here, but flip back to /src/components/shared/HeaderContainer.jsx.

.Now that we’re not handling actions in our components, we don’t need to mapDispatchToProps, so you can delete lines 24 to 31
.You don’t even need to cut ‘em, because we don’t need them in our action file
.Just vaporize them, leaving only ashes in the wind and the lamentations of those who loved them to mark their place.

.This also means we can edit our final line (which with my spacing should currently be line 24)
.We still need to connect the component in order to gain access to dispatch, which, again, is provided by the Redux-Thunk middleware, but we can shorten the line a bit since we’re no longer passing mapDispatchToProps
.Here’s the new line:

export default connect()(HeaderContainer);

.Excellent
.Now head back to the top of the file and let’s get rid of some imports we no longer need
.Delete line 2, line 4 and line 5 entirely
.This should leave you with just the React and connect imports
.We need to add one more just below those
.Here’s the code:

import { logUserOut } from '../../actions/authentication';

.We haven’t finished writing that function yet, but we’ll get there
.For now, you may notice a problem: we’re referencing a nonexistent this.logUserOut repeatedly in our class
.We can’t just change it to logUserOut because that’s not quite how Redux-Thunk works, so here’s what we need to do
.First, between our constructor and render blocks, add the following:

  logUserOutFunction() {
    const { dispatch } = this.props;
    dispatch(logUserOut());
  }

.This is why we still need that connect line
.It’s injecting dispatch into our props
.Handy! OK, now we need to change line 11 to bind that method instead of the old one
.Just add “Function” to the two instances of logUserOut like this:

    this.logUserOutFunction = this.logUserOutFunction.bind(this);

.And, finally, we need to reference that function on line 22, our call to Header, like this:

      <Header authentication={authentication} logUserOutFunction={this.logUserOutFunction} />

.And with that, we’ve reduced the size and complexity of our HeaderContainer file significantly
.We need to make a very small change to the Header itself, so save this file, then open up /src/components/shared/Header.jsx.

.First things first, ESLint is complaining about the order of our methods, so move renderGreeting down below toggleNavbar
.This is just good practice, keeping functions that spit out JSX down close to the render block
.With that done, all we need to do is change lines 22 and 23 from:

    const { logUserOut } = this.props;
    logUserOut();

    const { logUserOutFunction } = this.props;
    logUserOutFunction();

.Phew … wipe the sweat from your brow, save this file, and let’s head back to /src/actions/authentication.js
.At the top of the file, add this code:

import { decrementProgress, incrementProgress } from './progress';

// Action Creators

.Below it, leave an empty line and then add this above the logUserOut function you pasted in:

// Log User Out

export function logUserOut() {

.Don’t worry, we’ll be bringing that async back on the very next line, so just below line 13, add the following:

  return async (dispatch) => {

.See? Now we have proper indentation for the rest of the function, but we do need to add a semi-colon to line 47, and then add a new close brace on line 48 to close the function
.With that done, we can delete lines 15 to 21
.We don’t need them anymore, since we’re no longer in a component file and no longer dealing with props
.Note that we’re returning a function here
.This is necessary for Redux-Thunk to work, and what allows us to push dispatch down to where we need it
.Speaking of needing dispatch, let’s change our spinner actions
.Remember, Redux is no longer handling that functionality for us, so we have to do it ourselves
.Change line 16 to:

    dispatch(incrementProgress());

    return dispatch(decrementProgress());

.Since that’s the final line of our function, we’re returning it so Redux knows we’re done and it can move on
.Our .then block needs to change a bit
.We no longer want to return, here, so we need an else
.Replace lines 29 to 32:

      if (response.status === 200) {
        return logoutSuccessAction();
      }
      return logoutFailureAction(`Error: ${response.status}`);

      if (response.status === 200) {
        dispatch(logoutSuccess());
      } else {
        dispatch(logoutFailure(`Error: ${response.status}`));
      }

      logoutFailureAction(error);

      dispatch(logoutFailure(error));

#Five Minute React 52 - Refactoring Log-In

.Start by opening /src/actions/authentication.js
.At the top, add in our pollyfill which helps make sure fetch() works in more browsers:

import 'whatwg-fetch';

.Leave that file for a bit and switch over to /src/components/account/LoginPageContainer.jsx
.Go ahead and delete the whatwg-fetch import at the top, since we’re not going to be using it here anymore
.Then it’s time to cut-n-paste again
.Highlight lines 24 to 73—our entire attemptLogin method—and cut ‘em
.Then head back to /src/actions/authentications.js, add a padding line below line 11, and type this comment:

// Log User In

  async attemptLogIn(userData) {

export function logUserIn(userData) {

  return async (dispatch) => {

// Log User In
export function logUserIn(userData) {
  return async (dispatch) => {
    // turn on spinner
    dispatch(incrementProgress());

    // register that a login attempt is being made
    dispatch(loginAttempt());

    // contact login API
    await fetch(
      // where to contact
      '/api/authentication/login',
      // what to send
      {
        method: 'POST',
        body: JSON.stringify(userData),
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'same-origin',
      },
    )
    .then((response) => {
      if (response.status === 200) {
        return response.json();
      }
      return null;
    })
    .then((json) => {
      if (json) {
        dispatch(loginSuccess(json));
      } else {
        dispatch(loginFailure(new Error('Authentication Failed')));
      }
    })
    .catch((error) => {
      dispatch(loginFailure(new Error(error)));
    });

    // turn off spinner
    return dispatch(decrementProgress());
  };
}

.With that done, save the file, and head back to /src/components/account/LoginPageContainer.jsx
.We’ve performed surgery on this file, and as with all surgery, you need to sew up the holes once you’ve cut them
.At least, I’m pretty sure that’s how it works
.I am not a surgeon, and if you ever see me snapping on gloves in your operating room, you should leap from the table and run screaming down the hall, even if your hospital gown shows off your butt to everyone you pass.

import React from 'react';
import { connect } from 'react-redux';
import { Redirect } from 'react-router-dom';

import LoginPage from './LoginPage';

import { logUserIn } from '../../actions/authentication';

.Next, we can delete the component state from our constructor
.“But how are we going to know to redirect our user,” you ask? Well, when we built our authentication reducer, we brilliantly added an “isLoggedIn” boolean into our user object
.We’re going to map that state to props, and check against that instead, in just a minute
.For now, just delete lines 14 to 18.

.Much like with logging out, we still need a small method to pass down to LoginPage as a prop, so below the constructor but above the render block, add the following:

  logUserInFunction(userData) {
    const { dispatch } = this.props;
    dispatch(logUserIn(userData));
  }

    this.logUserInFunction = this.logUserInFunction.bind(this);

        <LoginPage loginFunction={this.logUserInFunction} />

.Now skip down to the end of the file, and delete the entire mapDispatchToProps block
.We’re going to replace it with the following code:

function mapStateToProps(state) {
  return {
    authentication: state.authentication,
  };
}

export default connect(mapStateToProps)(LoginPageContainer);

.Note: we replaced the null with mapStateToProps and got rid of mapDispatchToProps, which is why connect has gone from taking two arguments to just one
.Because connect expects mapStateToProps first, we have to pass null in order for it to move on to mapDispatchToProps
.But now we’re passing mapStateToProps , and because of the way function arguments work, we don’t have to bother specifying null for anything that follows, because simply by not defining them, we get the same result.

    const { authentication } = this.props;

    if (authentication.isLoggedIn) {

#Five Minute React 53 - Final Action Refactoring

.Ready to move one more fetch block into our authentication action file? This should be old hat by now, so let’s breeze through it
.Open up /src/components/TemplateContainer.jsx and grab the whole async block from line 20 to line 48
.Cut it, and then open /src/actions/authentication.js
.Add a padding line below line 11, and then add the following:

// Check User Session

export function checkSession() {

  return async (dispatch) => {

.Then jump down and add a semi-colon at the end of line 43, and add a line with a closing brace just below that
.Next, remove line 16 entirely
.No props needed here! After that, remove the word “Action” from the three functions that use it (eg: sessionCheckSuccessAction(json); becomes sessionCheckSuccess(json);), and wrap those same three functions in dispatches (eg: sessionCheckSuccess(json); becomes dispatch(sessionCheckSuccess(json));.

.Now, the way this function happens to work, we don’t return a progress spinner decrement at the very end
.For consistency, I like to instead return on each of the three dispatches
.It’s not strictly necessary – Redux will continue on its merry way regardless, but it does allow us to trim a few lines, which is nice
.So add return in front of each of the three dispatch functions.

      if (json.username) {
        return dispatch(sessionCheckSuccess(json));
      } else {
        return dispatch(sessionCheckFailure());
      }

      if (json.username) {
        return dispatch(sessionCheckSuccess(json));
      }
      return dispatch(sessionCheckFailure());

    .catch((error) => {
      return dispatch(sessionCheckFailure(error));
    });

    .catch(error => dispatch(sessionCheckFailure(error)));

.We’re done with this file
.Save it and head back to /src/components/TemplateContainer.jsx
.Let’s start by cleaning up our imports
.Adjust the top of the file to look like this:

import React from 'react';
import { connect } from 'react-redux';
import { checkSession } from '../actions/authentication';

import Template from './Template';

.Your class export should still begin on line 7
.Skip down below that to mapDispatchToProps (should be lines 28 to 33), and get rid of that block entirely
.Then change the final line of the file, now line 35, to this code:

export default connect(mapStateToProps)(TemplateContainer);

.Last thing we need to do is call our checkSession action, which requires a small method in our class
.Below componentWillMount, but above render, add the following lines:

  checkUserSession() {
    const { dispatch } = this.props;
    dispatch(checkSession());
  }

    this.checkUserSession = this.checkUserSession.bind(this);

.And then change the call in componentWillMount, on line 17, appropriately:

    this.checkUserSession();

.Open /src/components/account/LoginPage.jsx
.We need to add a function to handle keypresses, so let’s do that
.In between handleEmailChange and handlePasswordChange, add this function:

  // catch enter clicks
  handleKeyPress(target) {
    if (target.charCode === 13) {
      this.compileFormData();
    }
  }

    this.handleEmailChange = this.handleEmailChange.bind(this);
    this.handlePasswordChange = this.handlePasswordChange.bind(this);

    this.handleKeyPress = this.handleKeyPress.bind(this);

                onKeyPress={this.handleKeyPress}

#Five Minute React 54 - Building A Registration Page

.We’re going to do this in sort of a strange way, by starting at the top level, importing a component that doesn’t exist yet, then creating that component, and then doing the same thing again
.So start off by opening /src/components/Template.jsx
.Below line 7, add the following:

import RegisterPage from './account/RegisterPageContainer';

          <Route exact path="/account/register" component={RegisterPage} />

.Save this file, and we’re done here
.Obviously, we now need to create /src/components/account/RegisterPageContainer.jsx … so do that! This page is almost identical to /src/components/account/LoginPageContainer.jsx, and not terribly long, so I’m going to just give it to you all at once:

import React from 'react';
import { connect } from 'react-redux';

import RegisterPage from './RegisterPage';

export class RegisterPageContainer extends React.Component {
  constructor(props) {
    super(props);

    // bound functions
    this.registerFunction = this.registerFunction.bind(this);
  }

  registerFunction(userData) {
    const { dispatch } = this.props;
    // dispatch(registerUser(userData));
    console.log(userData);
  }

  render() {
    return (
      <div>
        <RegisterPage registerFunction={this.registerFunction} />
      </div>
    );
  }
}

export default connect()(RegisterPageContainer);

.As you can see, we import React and Redux, connect our container to Redux so that we can use dispatch, and then write a little function to pass down to the register form that registers a user … or, more accurately for the moment, console logs the incoming user data, because we haven’t actually written any actions or reducers to handle registration
.That’ll come in the next tutorial.

.Once you’re set here, save the file, and then create a new one in /src/components/account/ called RegisterPage.jsx
.This is where we’ll be putting our form fields and stuff
.Let’s start with our imports
.Here they are:

import React from 'react';
import { Button, Form, FormGroup, Label, Input } from 'reactstrap';

export default class ProfilePage extends React.Component {
  constructor(props) {
    super(props);

    // bound functions

    // component state
    this.state = {
      email: '',
      firstName: '',
      lastName: '',
      password: '',
      username: '',
    };
  }

  render() {
    return (
      <div className="row justify-content-center">
        <div className="col-10 col-sm-7 col-md-5 col-lg-4">
        </div>
      </div>
    );
  }
}

.This, obviously, will create an empty page with nothing in it, which isn’t particularly useful! So let’s fill that page in with form elements
.This is a big bunch of code, but it’s just a little introductory text, five input fields, and a button
.So between those div tags (lines 22 and 23), add the following:

          <p>
            Want to get started saving your favorite bands to MusicList?
            Create an account!
          </p>
          <Form>
            <FormGroup>
              <Label for="email">Email</Label>
              <Input
                id="email"
                name="email"
                onChange={this.handleInputChange}
                onKeyPress={this.handleKeyPress}
                placeholder="noreply@musiclist.com"
                type="email"
                value={this.state.email}
              />
            </FormGroup>

            <FormGroup>
              <Label for="password">Password</Label>
              <Input
                id="password"
                name="password"
                onChange={this.handleInputChange}
                onKeyPress={this.handleKeyPress}
                placeholder="password"
                type="password"
                value={this.state.password}
              />
              <span>
                We recommend a password service like&nbsp;
                <a href="https://www.lastpass.com/" target="_blank" rel="noopener noreferrer">LastPass</a>
                &nbsp;or <a href="https://1password.com/" target="_blank" rel="noopener noreferrer">1Password</a>
              </span>
            </FormGroup>

            <FormGroup>
              <Label for="username">Username</Label>
              <Input
                id="username"
                name="username"
                onChange={this.handleInputChange}
                onKeyPress={this.handleKeyPress}
                placeholder="CaptainCode"
                type="text"
                value={this.state.username}
              />
            </FormGroup>

            <FormGroup>
              <Label for="firstName">First Name</Label>
              <Input
                id="firstName"
                name="firstName"
                onChange={this.handleInputChange}
                onKeyPress={this.handleKeyPress}
                placeholder="Jamie"
                type="text"
                value={this.state.firstName}
              />
            </FormGroup>

            <FormGroup>
              <Label for="lastName">Last Name</Label>
              <Input
                id="lastName"
                name="lastName"
                onChange={this.handleInputChange}
                onKeyPress={this.handleKeyPress}
                placeholder="Smith"
                type="text"
                value={this.state.lastName}
              />
            </FormGroup>

            <Button color="primary" onClick={this.compileFormData}>Register</Button>
          </Form>

.The weirdest thing here is those nbsp tags in the span under the password input
.We have to do this because we’re breaking the line into multiple chunks
.JSX is still JavaScript, and JavaScript doesn’t care about line breaks, so unfortunately unlike with HTML, a linebreak doesn’t necessarily turn into a space
.Except sometimes it does! The JSX interpreter is a little weird
.So you have to put those nbsp tags in those exact places to get the spacing you want.

.Now we need some functions
.Our handleKeypress function that checks to see if the enter key was pressed will be identical to the one we wrote for LoginPage.jsx, but we’re doing something a little different with handling changes to the form fields
.Instead of writing a function for each field, we’re going to write a generic function which will use the target’s id to update values in the state
.Note that all of our inputs’ id attributes are identical to the component state values we defined (eg: email, password, etc).

.So, here are your three functions
.Put this code between your constructor block and your render block:

  // Put everything together and send it up to the register function
  compileFormData() {
    const { registerFunction } = this.props;
    const formData = this.state;
    registerFunction(formData);
  }

  // Handle input changes
  handleInputChange(e) {
    this.setState({ [e.currentTarget.id]: e.target.value });
  }

  // catch enter clicks
  handleKeyPress(target) {
    if (target.charCode === 13) {
      target.preventDefault();
      this.compileFormData();
    }
  }

.As always, we’ll need to bind these functions so that they inherit this from the class, so under line 8, add the following code:

    this.compileFormData = this.compileFormData.bind(this);
    this.handleInputChange = this.handleInputChange.bind(this);
    this.handleKeyPress = this.handleKeyPress.bind(this);

.That’s it! Save the file
.We’ve got a little extra time here, so I’m going to show you how to hide the redux dev tools by default
.They’re very useful when testing actions, but having the window always open when the page refreshes is a bit much
.Open up /src/components/shared/DevTools.jsx and change line 10 from:

    defaultIsVisible

    defaultIsVisible={false}

.Save that file and head for a browser
.Point it at locahost:3000/account/register and witness the glory of your new register page (and note that the redux dev tools don’t show up until you hit ctrl-h)
.You can fill in the inputs, and if you have your console open, when you click the button or press enter, you’ll see it console log out the values
.Step one is complete
.Now we need to submit this to the API and actually register a new user
.We’ll do that in the next tutorial
.See you there!

#Five Minute React 55 - Sending to the Registration API

.Let’s start by heading over to Sublime and opening /routes/api/authentication.js
.Remember, we already built our API endpoint back in tutorial 37
.We’re going to need to modify it a bit though
.First off, remove the user argument from the callback function in line 56, like this:

  User.register(newUser, req.body.password, (err) => {

    // Otherwise, for now, send back a JSON object with the new user's info
    return res.send(JSON.stringify(user));

    // Otherwise log them in
    return passport.authenticate('local')(req, res, () => {
      // If logged in, we should have user info to send back
      if (req.user) {
        return res.send(JSON.stringify(req.user));
      }
      // Otherwise return an error
      return res.send(JSON.stringify({ error: 'There was an error logging in' }));
    });

.Save that file, and move on to /src/components/actions/authentication.js
.We’re going to create two new action creator functions up at the top, and then a function to register the user with the API down at the bottom
.Below line 9, add the following two lines:

export const registrationFailure = () => ({ type: 'AUTHENTICATION_REGISTRATION_FAILURE' });
export const registrationSuccess = () => ({ type: 'AUTHENTICATION_REGISTRATION_SUCCESS' });

.Then head all the way to the bottom of the file (it should end on line 120)
.Our registration function is very similar to logUserIn, so I think you’ll be able to handle all of the code at once
.Here it is:

// Register a User
export function registerUser(userData) {
  return async (dispatch) => {
    // turn on spinner
    dispatch(incrementProgress());

    // contact the API
    await fetch(
      // where to contact
      '/api/authentication/register',
      // what to send
      {
        method: 'POST',
        body: JSON.stringify(userData),
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'same-origin',
      },
    )
    .then((response) => {
      if (response.status === 200) {
        return response.json();
      }
      return null;
    })
    .then(async (json) => {
      if (json) {
        await dispatch(loginSuccess(json));
        await dispatch(registrationSuccess());
      } else {
        dispatch(registrationFailure(new Error('Registration Failed')));
      }
    })
    .catch((error) => {
      dispatch(registrationFailure(new Error(error)));
    });

    // turn off spinner
    return dispatch(decrementProgress());
  };
}

.The key thing to note here is that we’ve added another async / await setup once our API returns our user JSON after successfully registering and logging them in
.That way, we ensure that the loginSuccess action creator runs first (which puts the user data in our state) and then the registrationSuccess action creator runs … which doesn’t do anything yet because we haven’t modified our reducer to listen for it
.Generally, action creators are very fast, and these will almost always operate sequentially, but they are technically asynchronous functions, so better safe than sorry.

.Save this file and head for /src/reducers/authentication.js
.It’s time to do that listening we were just talking about
.First off, below line 6, we need a new addition to our authentication object:

  registrationSucceeded: false,

case 'AUTHENTICATION_LOGOUT_FAILURE':

    case 'AUTHENTICATION_REGISTRATION_FAILURE': {

    case 'AUTHENTICATION_REGISTRATION_SUCCESS': {
      const newState = Object.assign({}, state);
      newState.registrationSucceeded = true;
      return newState;
    }

.This is why we wanted to make sure the login action runs first
.That way state will be full of nice user info, rather than the empty values from initialState
.Then we just change registrationSucceeded to true, and we’re good to go
.Save this file and let’s head into the home stretch
.Open up /src/components/account/RegisterPageContainer.jsx
.Under line 2, let’s import our registration action like this:

import { registerUser } from '../../actions/authentication';

const mapStateToProps = state => ({ authentication: state.authentication });

.This is a condensed version of the mapStateToProps function we’ve used elsewhere, using ES6 implicit returns
.It’s just saying “return the authentication part of the Store as props.” We need to pass this function to connect, so modify the final line of the file to look like this:

export default connect(mapStateToProps)(RegisterPageContainer);

.Now let’s fix our register function on line 15
.Delete the console.log on line 18 entirely, and uncomment line 17
.That’s it! Hooray, foresight
.Directly under line 20, our render() block, add the following:

    const { isLoggedIn } = this.props.authentication;

    // User needs to be logged out to register
    if (isLoggedIn) {
      return (<p>Please log out before registering a new user</p>);
    }

    // Otherwise display the form

    return (
      <div>
        <RegisterPage registerFunction={this.registerFunction} />
      </div>
    );

    return <RegisterPage registerFunction={this.registerFunction} />;

.Nice and clean
.You might be wondering why I don’t also do single-line, bracket-less if statements
.The answer is because I don’t wanna! Unlike return, if statements don’t take a semi-colon at the end, which can lead to all sorts of issues if you go bracket-less and then add additional lines without paying attention
.I prefer to use the brackets, and if the line is more than a few characters long (eg: if (user) { return true }) then I prefer to span it out over multiple lines.

import React from 'react';
import { connect } from 'react-redux';
import { registerUser } from '../../actions/authentication';

import RegisterPage from './RegisterPage';

export class RegisterPageContainer extends React.Component {
  constructor(props) {
    super(props);

    // bound functions
    this.registerFunction = this.registerFunction.bind(this);
  }

  registerFunction(userData) {
    const { dispatch } = this.props;
    dispatch(registerUser(userData));
  }

  render() {
    const { isLoggedIn } = this.props.authentication;

    // User needs to be logged out to register
    if (isLoggedIn) {
      return (
.Please log out before registering a new user
);
    }

    // Otherwise display the form
    return ;
  }
}

const mapStateToProps = state => ({ authentication: state.authentication });

export default connect(mapStateToProps)(RegisterPageContainer);

.Now we can head over to a browser
.Let’s log in first and make sure we get our “yo, you gotta log out” message
.So run a successful login, and then head for localhost:3000/account/register
.Yep, there’s our message
.Excellent
.Now click “log out” in the header and witness React auto-change you over to the registration form
.Sexy!

.In the next tutorial, we’ll handle forwarding to the success page, setting the registrationSucceeded value back to false, and a little bit of cleanup
.Until then!

#Five Minute React 56 - Registration Success Page

mongo

use musiclist

to switch to your MusicList database (if you decided to name your db something else, use that, and if you need a list, type show dbs). If you remember the username you registered, you can skip to the deleting step. If not, you can get a list of the users you’ve created by typing:

db.users.find()

.Anyway, I used CaptainCode as my test username, so I’m going to delete that account
.You should replace the username in the following code with whatever username you used!

db.users.remove({ 'username': 'CaptainCode' })

.WriteResult({ "nRemoved" : 1 })

db.users.find()

again. Your test user should be gone. If it is, good. If not, uh … try again! Once your test user is successfully deleted, you can leave the MongoDB client by typing exit and then head for Sublime Text. It’s time to start coding!

.First thing, create a file in /src/components/account/ called RegistrationSuccessPage.jsx
.This is a really simple page that doesn’t need to do anything, so we can get away with using a pure function
.We’re still going to need a container, though, because we’re going to be firing off an action
.But we’ll get to that
.For now, here’s everything this file needs, in its entirety:

import React from 'react';

export default function Sidebar() {
  return (
    <div className="row justify-content-center">
      <div className="col-10 col-sm-7 col-md-5 col-lg-4">
        <p>
          Registration successful. You are now logged in.
        </p>
        <p>
          Thanks for signing up!
        </p>
      </div>
    </div>
  );
}

.Save this file and you’re done with it
.Create a file in /src/components/account/ called RegistrationSuccessPageContainer.jsx
.This one’s going to dispatch an action we haven’t actually written yet
.Here are the imports:

import React from 'react';
import { connect } from 'react-redux';
import { registrationSuccessViewed } from '../../actions/authentication';

import RegistrationSuccessPage from './RegistrationSuccessPage';

export class RegistrationSucessPageContainer extends React.Component {
  componentWillMount() {
    const { dispatch } = this.props;
    dispatch(registrationSuccessViewed());
  }

  render() {
    return (
      <div>
        <RegistrationSuccessPage />
      </div>
    );
  }
}

export default connect()(RegistrationSucessPageContainer);

import React from 'react';
import { connect } from 'react-redux';
import { registrationSuccessViewed } from '../../actions/authentication';

import RegistrationSuccessPage from './RegistrationSuccessPage';

export class RegistrationSucessPageContainer extends React.Component {
  componentWillMount() {
    const { dispatch } = this.props;
    dispatch(registrationSuccessViewed());
  }

  render() {
    return (
      <div>
        <RegistrationSuccessPage />
      </div>
    );
  }
}

export default connect()(RegistrationSucessPageContainer);

.Save this file, and let’s create that action
.Open up /src/actions/authentication.js and under line 11, add the following code:

export const registrationSuccessViewed = () => ({ type: 'AUTHENTICATION_REGISTRATION_SUCCESS_VIEWED' });

.Now we need our reducer to listen for this action
.Open up /src/reducers/authentication.js
.Underneath line 44, add the following code:

    case 'AUTHENTICATION_REGISTRATION_SUCCESS_VIEWED': {
      const newState = Object.assign({}, state);
      newState.registrationSucceeded = false;
      return newState;
    }

.Speaking of forwarding, we need to add that code
.Save your reducer, and open up /src/components/account/RegisterPageContainer.jsx
.Under line 2, add an import for Redirect, like this:

import { Redirect } from 'react-router-dom';

.Next, change line 22 to grab registrationSucceeded from our authentication props, like this:

const { isLoggedIn, registrationSucceeded } = this.props.authentication;

    // Forward to a success page
    if (registrationSucceeded) {
      return (
        <Redirect to="/account/registration-success" />
      );
    }

.That’s all here, so save the file
.There’s only two things left that we need to do
.The first is add the new page to our routing, and the second is add a register link to the header for logged-out users
.So, open up /src/components/Template.jsx
.Under line 8, import the page container like this:

import RegistrationSuccessPage from './account/RegistrationSuccessPageContainer';

          <Route exact path="/account/registration-success" component={RegistrationSuccessPage} />

.That’s all that’s required, so save that file and open up /src/components/shared/Header.jsx
.First we need to change our renderLogin function on line 5
.Replace that one line with these ones:

const renderLogin = () => (
  <Nav className="ml-auto" navbar>
    <NavItem>
      <NavLink tag={Link} to="/account/login">Log In</NavLink>
    </NavItem>
    <NavItem>
      <NavLink tag={Link} to="/account/register">Register</NavLink>
    </NavItem>
  </Nav>
);

.We have to move the <nav> tag up into this function because of React’s mildly annoying need to always have discreet blocks of JSX wrapped in a single tag
.This means a tiny bit of duplication as we’ll also be changing some code below to render the <nav> tag, but I found that the Bootstrap navbar is a little squirrely and doesn’t always react well to things like the old “just throw some spans around it” trick, so this proved to be the best solution.

      <span>
        Welcome, {name} | <a href="/logout" onClick={this.logOutClick}>Log Out</a>
      </span>

      <Nav className="ml-auto" navbar>
        <NavItem>
          Welcome, {name} | <a href="/logout" onClick={this.logOutClick}>Log Out</a>
        </NavItem>
      </Nav>

          <Collapse isOpen={this.state.isOpen} navbar>
                { isLoggedIn ? this.renderGreeting(firstName) : renderLogin() }
          </Collapse>

#Five Minute React 57 - Error Handling

.Instead, we’re going to make “error” a top-level part of the Store, like “authentication” and “progress”
.This will also show off a cool feature of Redux: more than one reducer can listen for the same action, and then manipulate different parts of the Store accordingly
.So while our account reducer is doing one thing on, say, AUTHENTICATION_LOGIN_FAILURE, our error reducer can be doing something else, and our application state will change in two places at once.

.Create a new file in /src/actions called error.js and fill it with the following lines:

// Action Creators
export const clearError = () => ({ type: 'ERROR_CLEARED' });

.ESLint will complain about having no default export here, but you can ignore that
.It’s likely at a future date we’ll be adding more action creators to this file, so we’re sticking with explicit exports here
.For today, there’s nothing else to do, so save the file, and create a new file in /src/reducers also called error.js
.This one’s a bit bigger
.We’re going to watch for three authentication actions, plus the new one we just defined in the previous file
.Here’s the code:

const initialState = {
  isError: false,
  error: {},
};
export default function reducer(state = initialState, action) {
  switch (action.type) {
    case 'AUTHENTICATION_LOGIN_FAILURE':
    case 'AUTHENTICATION_LOGOUT_FAILURE':
    case 'AUTHENTICATION_REGISTRATION_FAILURE': {
      const newState = Object.assign({}, initialState);
      newState.isError = true;
      newState.error = action.error;
      return newState;
    }
    case 'ERROR_CLEARED': {
      const newState = Object.assign({}, initialState);
      return newState;
    }
    default: {
      return state;
    }
  }
}

.Save this file
.Open /src/reducers/authentication.js and delete line 37:

      // todo: handle error!

.Since we are, in fact, handling the error
.Just not here
.Save that file, and move on to /src/actions/authentication.js
.We need to clean a couple of things up, here, so change line 78 to:

        dispatch(loginFailure(new Error('Email or Password Incorrect. Please Try again.')));

        dispatch(logoutFailure(new Error(response.status)));

      dispatch(logoutFailure(new Error(error)));

        dispatch(registrationFailure(new Error('Registration Failed. Please try again.')));

.And we’re set
.Now we’re consistently sending JavaScript Error objects out when problems happen, which is good
.Save this file, and open up /src/reducers/index.js
.We need to add our error reducer to all of the reducers being bundled up for the Store, so below line 2, add the following:

import ErrorReducer from '../reducers/error';

  error: ErrorReducer,

.Looking good
.Save the file, and we’re done wiring up the guts of our error reporting system
.Now we need to focus on display! To do that, we’re going to create an ErrorBox component and a container for it, and connect the container so that we can make the error box closeable (by firing that ERROR_CLEARED action we just set up).

.Let’s start with the error box itself
.Create a file in /src/components/shared called ErrorBox.jsx
.We can go pure function here, so the code’s pretty straightforward
.Here it is:

import React from 'react';
import { Alert } from 'reactstrap';

export default function ErrorBox(props) {
  const { closeErrorFunction } = props;
  const { error, isError } = props.errorStore;
  return (
    <div className="row justify-content-center">
      <div className="col-6">
        <Alert color="danger" isOpen={isError} toggle={closeErrorFunction}>
          <strong>Error:</strong> {error.message}
        </Alert>
      </div>
    </div>
  );
}

.As you can see, we’re going to need to provide some props for this function to use
.We’ll do that in the container, so save this file and then create a new file, also in /src/components/shared called ErrorBoxContainer.jsx
.We need to use a class here so we can define a method to pass down for clearing the error box
.It’s still a pretty short file
.Feeling up to just looking at the whole thing at once? I’m confident you can handle it
.Here it is:

import React from 'react';
import { connect } from 'react-redux';
import { clearError } from '../../actions/error';

import ErrorBox from './ErrorBox';

class ErrorBoxContainer extends React.Component {
  constructor(props) {
    super(props);

    this.closeError = this.closeError.bind(this);
  }

  closeError() {
    const { dispatch } = this.props;
    dispatch(clearError());
  }

  render() {
    const { errorStore } = this.props;
    return (
      <ErrorBox errorStore={errorStore} closeErrorFunction={this.closeError} />
    );
  }
}

function mapStateToProps(state) {
  return { errorStore: state.error };
}

export default connect(mapStateToProps)(ErrorBoxContainer);

.Real quick, here’s what we’re doing
.We’re grabbing our error state from the Store (which, because we’re using connect, also gives us access to dispatch)
.Then we create a small function to dispatch our clearError action creator, which we’ve imported from the action file we created earlier
.Finally, we call an instance of ErrorBox and pass it the information from the Store, and the function, which it will use to display information and allow users to dismiss the error if they’ve fixed the problem … or, I suppose, if they’re just like “whatever, man, who cares?”

.Save this file
.We’ve got one last thing to do, and that’s call our error box somewhere
.I suggest at the top level of the template, because that way it’ll be available on every page
.To do that, open up /src/Template.jsx
.Underneath line 3, import our container with this code:

import ErrorBox from './shared/ErrorBoxContainer';

          <ErrorBox />

#Five Minute React 58 - Front-End Validation

.Let’s get started
.We’re going to use a 3rd party module for front-end validation that’s built specifically to work with Reactstrap
.It’s called Availity reactstrap Validation and we install it by heading for a terminal window or command prompt, switching to our musiclist directory, and typing:

$ npm add availity-reactstrap-validation@1.4.3

.With that done, switch back to Sublime (or your editor of choice) and open up /src/components/account/LoginPage.jsx
.We’ll start with the simpler of our two forms
.The first thing we need to do is adjust our imports, so change line 2 to these two lines:

import { AvForm, AvGroup, AvInput, AvFeedback } from 'availity-reactstrap-validation';
import { Button, Label } from 'reactstrap';

.The various Av-based components are wrappers for reactstrap components that allow for validation, so we no longer need to import the reactstrap components (the availity components do that for us), except for Button and Label because those aren’t changing.

.Next up, find your compileFormData method on line 39 and replace the whole thing with the following:

  // Handle submission once all form data is valid
  handleValidSubmit() {
    const { loginFunction } = this.props;
    const formData = this.state;
    loginFunction(formData);
  }

.This is the same function, just re-named (and I added a comment for clarity)
.This also means we need to delete line 10, which binds our now non-existent compileFormData function
.So nuke that line and then, below line 12, add the following:

    this.handleValidSubmit = this.handleValidSubmit.bind(this);

.Now head down to our render block and change lines 50 and 51 from:

          <Form>
            <FormGroup>

          <AvForm onValidSubmit={this.handleValidSubmit}>
            <AvGroup>

.That AvForm line is especially important because by including our handleValidSubmit function, we tell it what to do when the validated form is submitted
.Lines 53 to 61 make up our email input
.We need to make a few changes here, including switching to AvInput, adding a required attribute, and organizing our attributes alphabetically
.Here’s the entire code block:

              <AvInput
                id="userEmail"
                name="email"
                onChange={this.handleEmailChange}
                onKeyPress={this.handleKeyPress}
                placeholder="noreply@musiclist.com"
                required
                type="email"
                value={this.state.email}
              />

              <AvFeedback>A valid email is required to log in.</AvFeedback>

            </AvGroup>

            <AvGroup>
              <Label for="userPassword">Password</Label>
              <AvInput
                id="userPassword"
                name="password"
                onChange={this.handlePasswordChange}
                onKeyPress={this.handleKeyPress}
                placeholder="password"
                required
                type="password"
                value={this.state.password}
              />
              <AvFeedback>Password is required to log in</AvFeedback>
            </AvGroup>

.Then change line 79, our Button line, to the following:

            <Button color="primary">Log In</Button>

.We don’t need the OnClick anymore because AvForm will fire this.handleValidSubmit automatically
.Last thing we need to do is change line 80 to:

          </AvForm>

.That’s it for this file
.Save it, and let’s head over to /src/components/account/RegisterPage.jsx
.We’re doing basically the same set of changes here, just more of them
.So change line 2 to the following two lines:

import { AvForm, AvGroup, AvInput, AvFeedback } from 'availity-reactstrap-validation';
import { Button, Label } from 'reactstrap';

.Then delete the compileFormData method on lines 24 to 29, and below the end of the handleKeypress method on line 35, add the following:

  // Handle submission once all form data is valid
  handleValidSubmit() {
    const { registerFunction } = this.props;
    const formData = this.state;
    registerFunction(formData);
  }

.Then go back up, delete line 10 (our binding for compileFormData) and below what is now line 11, add the following:

    this.handleValidSubmit = this.handleValidSubmit.bind(this);

.Now on to our render block
.I’m not going to step you through changing each field
.My suggestion is to try doing them all yourself based on what you learned from changing LoginPage.jsx, and then check the code below to make sure you made all the changes
.Here’s the entire render block.

  render() {
    return (
      <div className="row justify-content-center">
        <div className="col-10 col-sm-7 col-md-5 col-lg-4">
          <p>
            Want to get started saving your favorite bands to MusicList?
            Create an account! All fields are required.
          </p>
          <AvForm onValidSubmit={this.handleValidSubmit}>
            <AvGroup>
              <Label for="email">Email</Label>
              <AvInput
                id="email"
                name="email"
                onChange={this.handleInputChange}
                onKeyPress={this.handleKeyPress}
                placeholder="noreply@musiclist.com"
                required
                type="email"
                value={this.state.email}
              />
              <AvFeedback>A valid email is required to register.</AvFeedback>
            </AvGroup>

            <AvGroup>
              <Label for="password">Password</Label>
              <AvInput
                id="password"
                minLength="8"
                name="password"
                onChange={this.handleInputChange}
                onKeyPress={this.handleKeyPress}
                placeholder="password"
                required
                type="password"
                value={this.state.password}
              />
              <AvFeedback>Passwords must be at least eight characters in length</AvFeedback>
              <span>
                We recommend a password service like&nbsp;
                <a href="https://www.lastpass.com/" target="_blank" rel="noopener noreferrer">LastPass</a>
                &nbsp;or <a href="https://1password.com/" target="_blank" rel="noopener noreferrer">1Password</a>
              </span>
            </AvGroup>

            <AvGroup>
              <Label for="username">Username</Label>
              <AvInput
                id="username"
                name="username"
                onChange={this.handleInputChange}
                onKeyPress={this.handleKeyPress}
                placeholder="CaptainCode"
                required
                type="text"
                value={this.state.username}
              />
              <AvFeedback>A username is required to register</AvFeedback>
            </AvGroup>

            <AvGroup>
              <Label for="firstName">First Name</Label>
              <AvInput
                id="firstName"
                name="firstName"
                onChange={this.handleInputChange}
                onKeyPress={this.handleKeyPress}
                placeholder="Jamie"
                required
                type="text"
                value={this.state.firstName}
              />
              <AvFeedback>A first name is required to register</AvFeedback>
            </AvGroup>

            <AvGroup>
              <Label for="lastName">Last Name</Label>
              <AvInput
                id="lastName"
                name="lastName"
                onChange={this.handleInputChange}
                onKeyPress={this.handleKeyPress}
                placeholder="Smith"
                required
                type="text"
                value={this.state.lastName}
              />
              <AvFeedback>A last name is required to register</AvFeedback>
            </AvGroup>

            <Button color="primary">Register</Button>
          </AvForm>
        </div>
      </div>
    );
  }

#Five Minute React 59 - Back-End Validation

.Let’s jump in
.Open /routes/api/authentication.js
.Find our register function starting on line 45
.Change line 46 to the following:

router.post('/register', async (req, res) => {

  // First, check and make sure the email doesn't already exist
  const query = User.findOne({ email: req.body.email });
  const foundUser = await query.exec();
  if (foundUser) { return res.send(JSON.stringify({ error: 'Email or username already exists' })); }

  if (!foundUser) {

  // return an error if all else fails
  return res.send(JSON.stringify({ error: 'There was an error registering the user' }));

.Last but not least, add a return in front of line 62, like this:

    return User.register(newUser, req.body.password, (err) => {

        return res.send(JSON.stringify({ error: 'There was an error registering the user' }));

.We’re good to go here
.Save the file, and let’s fix some error issues
.One thing you may have noticed is that the error box never goes away unless the user clicks the close icon
.This can lead to confusing things like failing a login (bringing up the error box), then succeeding, and still having the error box floating there telling you the login failed
.That’s what we in the business like to call “really bad UX.” We’re going to fix that by calling our clearError action at certain times when running other actions
.We’re also going to massage some of the errors sent by our registration function.

.To start, open up /src/actions/authentication.js and below line 2, import our clearError action like this:

import { clearError } from './error';

export const registrationFailure = error => ({ type: 'AUTHENTICATION_REGISTRATION_FAILURE', error });

.Now head for our logUserIn function
.This is one place where we’re going to clear the error if fired
.So below line 48, add this code:

    // clear the error box if it's displayed
    dispatch(clearError());

.Scroll to the logUserOut function and do the same thing, adding the exact same code underneath line 96
.Then do it again for the registerUser function, underneath line 131.

      if (json && json.username) {

        dispatch(registrationFailure(new Error(json.error.message ? 'Email or username already exists' : json.error)));

      dispatch(registrationFailure(new Error(error.message || 'Registration Failed. Please try again.')));

.We’re set, so save the file and let’s move on to /src/components/shared/ErrorBox.jsx
.We’ve only got a single line to change here
.It’s line 11, and when you’re done it should look like this:

          <strong>Error:</strong> {error && error.message ? error.message : 'An undefined error occurred' }

#Five Minute React 60 - Reset Password Part 1

.Let’s start by opening /models/user.js
.We’re only adding one line here, and it comes under line 10
.Here it is:

  passwordReset: { type: String, select: false },

.The select: false part will keep it from showing up when we retrieve the user object elsewhere in the code, unless we specifically ask for it
.Handy, huh?

.Save that file and move on to /src/actions/authentication.js
.Underneath line 13, let’s add two new action creators with these lines:

export const passwordResetHashCreated = () => ({ type: 'AUTHENTICATION_PASSWORD_RESET_HASH_CREATED' });
export const passwordResetHashFailure = () => ({ type: 'AUTHENTICATION_PASSWORD_RESET_HASH_FAILURE' });

// Send email to API for hashing
export function createHash(email) {
  return async (dispatch) => {
    // contact the API
    await fetch(
      // where to contact
      '/api/authentication/saveresethash',
      // what to send
      {
        method: 'POST',
        body: JSON.stringify({ email }),
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'same-origin',
      },
    )
    .then((response) => {
      if (response.status === 200) {
        return response.json();
      }
      return null;
    })
    .then((json) => {
      if (json.username) {
        return dispatch(passwordResetHashCreated(json));
      }
      return dispatch(passwordResetHashFailure(new Error('Something went wrong. Please try again.')));
    })
    .catch(error => dispatch(passwordResetHashFailure(error)));
  };
}

.As you can see, we’ll need to pass an email address to our function, so that it can send it along to the API
.We’ll do that shortly
.First, let’s build our API routine
.Save this file and open up /routes/api/authentication.js
.First, at the very top above everything else, add this line:

const crypto = require('crypto');

// POST to saveresethash
router.post('/saveresethash', async (req, res) => {
  let result;
  try {
    // check and make sure the email exists
    const query = User.findOne({ email: req.body.email });
    const foundUser = await query.exec();

    // If the user exists, save their password hash
    const timeInMs = Date.now();
    const hashString = `${req.body.email}${timeInMs}`;
    const secret = 'alongrandomstringshouldgohere';
    const hash = crypto.createHmac('sha256', secret)
                       .update(hashString)
                       .digest('hex');
    foundUser.passwordReset = hash;

    foundUser.save((err) => {
      if (err) { result = res.send(JSON.stringify({ error: 'Something went wrong while attempting to reset your password. Please Try again' })); }
      result = res.send(JSON.stringify({ success: true }));
    });
  } catch (err) {
    // if the user doesn't exist, error out
    result = res.send(JSON.stringify({ error: 'Something went wrong while attempting to reset your password. Please Try again' }));
  }
  return result;
});

.We’re doing something a little different, here
.This is a slightly better way to use aysnc / await than what we’re doing in the other routines (which we should probably refactor)
.By defining a variable, result, and then using it to await a function’s returned value, we can use try / catch blocks even with asynchronous functions
.Cool
.This cuts down on the if (result) and if (!result) stuff we’ve been doing elsewhere
.It also keeps our API from sending JSON back to our action even while the rest of the API function is still doing stuff
.Good times!

.Let’s also take a look at that hash a little more carefully
.Node has several hashing algorithms built in, so we didn’t have to install any modules to do this
.We’re first creating a string using the email address and a JavaScript timestamp, which would result in something like noreply@closebrace.com1507130167693
.Then we’re hashing it, using a random string for further entropy and asking for hex-based output
.The result will look something like this:

33b2441b79e5ee7c0e2148e35fef167188e1721adaee0815ba832bcee5a5ef79

.All right, we’re good here
.Save the file, and then create a new file in /src/components/account/ called ResetPasswordPageContainer.jsx
.This is where the logic will go, first for requesting a password reset and, again, in a later tutorial, for actually performing it.

import React from 'react';
import { connect } from 'react-redux';
import { createHash } from '../../actions/authentication';

import ResetPasswordPage from './ResetPasswordPage';

export class ResetPasswordPageContainer extends React.Component {
  constructor(props) {
    super(props);

    // bound functions
    this.resetPasswordRequest = this.resetPasswordRequest.bind(this);
  }

  resetPasswordRequest(email) {
    const { dispatch } = this.props;
    dispatch(createHash(email));
  }

  render() {
    return (
      <ResetPasswordPage resetPasswordFunction={this.resetPasswordRequest} />
    );
  }
}

export default connect()(ResetPasswordPageContainer);

.This should all look pretty familiar at this point
.We pull in our createHash function from our action file, then we use it in a little method that takes an email address as an argument, and pass that method on to our page component
.Now we need to make that page component, so save this file, and then create a new file in /src/components/account called ResetPasswordPage.jsx
.Add the following code:

import React from 'react';
import { AvForm, AvGroup, AvInput, AvFeedback } from 'availity-reactstrap-validation';
import { Button, Label } from 'reactstrap';

export default class ResetPasswordPage extends React.Component {
  constructor(props) {
    super(props);

    // bound functions
    this.handleEmailChange = this.handleEmailChange.bind(this);
    this.handleKeyPress = this.handleKeyPress.bind(this);
    this.handleValidSubmit = this.handleValidSubmit.bind(this);

    // component state
    this.state = {
      email: '',
    };
  }

  // update state as email value changes
  handleEmailChange(e) {
    this.setState({ email: e.target.value });
  }

  // catch enter clicks
  handleKeyPress(target) {
    if (target.charCode === 13) {
      this.handleValidSubmit();
    }
  }

  // Handle submission once all form data is valid
  handleValidSubmit() {
    const { resetPasswordFunction } = this.props;
    const formData = this.state;
    resetPasswordFunction(formData.email);
  }

  render() {
    return (
      <div className="row justify-content-center">
        <div className="col-10 col-sm-7 col-md-5 col-lg-4">
          <p>
            If you‘d like to reset your password, please enter your email here
            and a link to do so will be sent to the address you enter.
          </p>
          <AvForm onValidSubmit={this.handleValidSubmit}>
            <AvGroup>
              <Label for="userEmail">Email</Label>
              <AvInput
                id="userEmail"
                name="email"
                onChange={this.handleEmailChange}
                onKeyPress={this.handleKeyPress}
                placeholder="noreply@musiclist.com"
                required
                type="email"
                value={this.state.email}
              />
              <AvFeedback>A valid email is required to reset your password.</AvFeedback>
            </AvGroup>
            <Button color="primary">Reset Password</Button>
          </AvForm>
        </div>
      </div>
    );
  }
}

.This is highly similar to our log-in page, just without the password input
.So similar in fact that it’d probably behoove us to talk about storing helper methods like handleKeyPress in a separate file so they can be shared between multiple components … but that’s another tutorial.

.Save the file and open /src/components/Template.jsx
.We need to add a route so we can actually get to the page we just built
.Below line 10 add this code:

import ResetPasswordPage from './account/ResetPasswordPageContainer';

          <Route exact path="/account/reset-password" component={ResetPasswordPage} />

.That’s it
.Save the file and head for a browser
.Make sure your server’s running, and do a hard-refresh because we changed action files, which don’t hot reload
.Then head for localhost:3000/account/reset-password and bask in the glory of your new form
.Then open your Network console, because right now that’s the only way you’re going to see that anything’s happening!

#Five Minute React 61 - Reset Password Part 2

.Start by opening up /src/actions/authentication.js
.We need an action creator here that we’ll use to clear our “hey, they submitted the form, so show them new text” state, on the off chance they want to see the form again
.So below line 13, add this code:

export const passwordResetClear = () => ({ type: 'AUTHENTICATION_PASSWORD_RESET_CLEAR' });

export const passwordResetHashFailure = error => ({ type: 'AUTHENTICATION_PASSWORD_RESET_HASH_FAILURE', error });

    // clear the error box if it's displayed
    dispatch(clearError());

    // turn on spinner
    dispatch(incrementProgress());

    // turn off spinner
    return dispatch(decrementProgress());

.We also need to fix our createHash function so that it’s looking for the proper JSON response
.Right now it’s searching the JSON for username on line 79 … but we’re not returning a username
.We’re just returning a success boolean, so let’s check for that
.Change line 79 to this:

      if (json.success) {

.Also if, like me, you happen to have two blank lines between the end of this function and the comment at the top of the logUserIn function, delete that
.You’re done with this file
.Save it
.Now we need to listen for the actions we’re passing via Redux’s dispatch function and actually do something when they occur, so open /src/reducers/authentication.js

  isPasswordReset: false,

    case 'AUTHENTICATION_PASSWORD_RESET_CLEAR':
    case 'AUTHENTICATION_PASSWORD_RESET_HASH_FAILURE': {
      const newState = Object.assign({}, state);
      newState.isPasswordReset = false;
      return newState;
    }
    case 'AUTHENTICATION_PASSWORD_RESET_HASH_CREATED': {
      const newState = Object.assign({}, state);
      newState.isPasswordReset = true;
      return newState;
    }

.That’s it for this one, but we also want to throw an error when a failure happens, so save this file and then open up /src/reducers/error.js
.This one’s easy
.We’re just adding another case line to the first big block in the switch statement, so remove the opening brace from line 10 (which might be line 9 if you don’t have a space between your initialState object and your export line … which you should, so if you don’t have one, put it in!) and then below it, add this code:

    case 'AUTHENTICATION_PASSWORD_RESET_HASH_FAILURE': {

.There we go
.Save the file, and let’s bounce to /src/components/account/ResetPasswordPageContainer.jsx
.Let’s start by importing our new clearing function from our action file, so change line 3 to this:

import { createHash, passwordResetClear} from '../../actions/authentication';

  clearPasswordResetFunction() {
    const { dispatch } = this.props;
    dispatch(passwordResetClear());
  }

.That method uses this, so we need to bind it
.Under line 11 (the comment line), add this code:

    this.clearPasswordResetFunction = this.clearPasswordResetFunction.bind(this);

.We need to get our isPasswordReset boolean from the Store, so underneath line 31, add a padding line and declare a quick mapStateToProps function like this:

const mapStateToProps = state => ({ authentication: state.authentication });

and then change line 35, our export line, to include it, like this:

export default connect(mapStateToProps)(ResetPasswordPageContainer);

.Finally, we need to pass a few more props down to ResetPasswordPage, so under line 26, snag isPasswordReset from this.props like this:

    const { isPasswordReset } = this.props.authentication;

      <ResetPasswordPage
        clearPasswordResetFunction={this.clearPasswordResetFunction}
        isPasswordReset={isPasswordReset}
        resetPasswordFunction={this.resetPasswordRequest}
      />

.Great! That’s all we need here
.Save the file, and open up /src/components/account/ ResetPasswordPage.jsx
.Need to make a couple of tweaks here, too
.For starters, let’s clear out the email address box if the component re-renders, which it will only do if a submission was successful
.The easiest way to do this is with a handy React lifecycle method, componentWillReceiveProps, which runs before the render and lets you see what props are coming in
.Below line 18, add a spacing line and then the following:

  // clear out the email form if we're rendering the success message
  componentWillReceiveProps(nextProps) {
    const { isPasswordReset } = nextProps;
    if (isPasswordReset) {
      this.setState({ email: '' });
    }
  }

  // show the form again so a new email can be sent
  clearPasswordReset(e) {
    e.preventDefault();
    const { clearPasswordResetFunction } = this.props;
    clearPasswordResetFunction();
  }

    this.clearPasswordReset = this.clearPasswordReset.bind(this);

.Now we need to head for our render block, so we can check whether isPasswordreset is true or false, and display different stuff depending on its state
.To that end, add the following below line 55:

    const { isPasswordReset } = this.props;

    if (isPasswordReset) {
      return (
        <div className="row justify-content-center">
          <div className="col-10 col-sm-7 col-md-5 col-lg-4">
            <p>
              An email has been sent to the address you provided containing a link to reset
              your password. Please click that link to proceed with setting a new password.
            </p>
            <p>
              <a href="/account/reset-password" onClick={this.clearPasswordReset}>Re-send Email</a>
            </p>
          </div>
        </div>
      );
    }

.Right
.Save this file
.Our last little tweak is to add a “forgot your password?” link to the Log-In page, so open /src/components/account/LoginPage.jsx and, below line 3, add this line:

import { Link } from 'react-router-dom';

              <span><Link to="/account/reset-password">Forgot your password?</Link></span>

#Five Minute React 62 - Setting Up SMTP

.First, though, a question: do you have a user for your MusicList app that has the same email address that you just added to the list of authorized users, or the email address that you used when you signed up with Mailgun? If not, you’re going to need to register a new user using that email address
.That’s not hard … just go to localhost:3000 and click the register link, then fill in the info
.This step’s necessary because, well, we can’t reset the password associated with an email address that doesn’t exist in our DB!

$ npm add mailgun-js@0.13.1

.And let it do its thing
.Then it’s off to Sublime Text, where we need to make some changes to /routes/api/authentication.js
.For starters, below line 2, add the following:

const mailgun = require('mailgun-js')({
  apiKey: '',
  domain: '',
});

apiKey: 'key-c7930afd4e505703001da49370b403fa',
domain: 'sandboxdd91bae839780f8a25c8bbe5a98c7636.mailgun.org',

.Anyway, it’s fine for now
.Let’s move on to our POST to saveresethash on line 88
.Specifically, we’re going to add some code to generate and send an email
.Starting below line 106, add a padding line, and then this code:

      // Put together the email
      const emailData = {
        from: 'CloseBrace <postmaster@sandboxcc80cfa391224d5d83e5aba2d09b7590.mailgun.org>',
        to: foundUser.email,
        subject: 'Reset Your Password',
        text: `A password reset has been requested for the MusicList account connected to this email address. If you made this request, please click the following link: https://musiclist.com/account/change-password/${foundUser.passwordReset} ... if you didn't make this request, feel free to ignore it!`,
        html: `<p>A password reset has been requested for the MusicList account connected to this email address. If you made this request, please click the following link: <a href="https://musiclist.com/account/change-password/${foundUser.passwordReset}&quot; target="_blank">https://musiclist.com/account/change-password/${foundUser.passwordReset}</a>.</p><p>If you didn't make this request, feel free to ignore it!</p>`,
      };

.Pretty obvious what’s going on here, right? It’s just the information our SMTP server will need to send the email
.The only things to note, really, are that we’re pulling the email address and password reset hash from foundUser, which makes sense since we want to send the email to an existing user
.If we just sent to the address coming in via the form, we might be emailing people who don’t even have accounts with our service.

      // Send it
      mailgun.messages().send(emailData, (error, body) => {
        if (error || !body) {
          result = res.send(JSON.stringify({ error: 'Something went wrong while attempting to send the email. Please try again.' }));
        } else {
          result = res.send(JSON.stringify({ success: true }));
        }
      });

      result = res.send(JSON.stringify({ success: true }));

.That’s it for code
.Save the file, make sure your server’s running, and head for a browser
.Either click the log-in link and then the forgot password link, or just navigate to localhost:3000/account/reset-password
.Fill in the form using an email address that a) exists in your DB and b) is authorized to receive Mailgun test emails, and then submit
.You should get the success message, so check your inbox for the email your app should’ve generated
.If all’s gone well, it should show up within a minute or so (usually much less).

#Five Minute React 63 - Securing Secrets

.Cool, glad we’re all in agreement
.Let’s go
.First off, create a new file in the top level of your musiclist project and name it config.json
.This will contain all the various pieces of information we don’t want to be storing on Github
.Here’s what it should look like … although, of course, my actual values are different than these sample values, and you should use your actual values here.

{
  "crypto": {
    "secret": "sda46ufgh239d7fjhwi0sejhrgw4ersjdf8u7eweoi42hg0siojg"
  },
  "expressSession" : {
    "secret": "bmoe5r8hb98fhsbso93ikdfgbs0u4sfg89dhsogsd09fy4pf9fdh"
  },
  "mailgun": {
    "apiKey": "key-a6831fad9c681569479ab46734f662a8",
    "domain": "sandboxfa58bac976052d5e93f1cfa0b54c5337.mailgun.org"
  }
}

.Save that file, and create another new file at the top level called config.js
.This file will be in version control, and it ingests our JSON and makes it usable by the rest of our app
.Here’s the code:

const fs = require('fs');

const configPath = './config.json';
const parsed = JSON.parse(fs.readFileSync(configPath, 'UTF-8'));

// We have to export each object in order to access them separately
exports.crypto = parsed.crypto;
exports.expressSession = parsed.expressSession;
exports.mailgun = parsed.mailgun;
exports.port = parsed.port;

.That’s it, though it’s important to remember that if and when we add further items to config.json, we’ll need to create an export for them here
.Anyway, save this file and let’s put it to use
.Open up /app.js
.First, let’s organize our imports at the top alphabetically by reordering lines 1 through 18
.Sadly you can’t just highlight the whole block and hit F5 (for Mac) or F9 (for Windows) in Sublime text to organize them alphabetically because the object we’re passing to expressSession confuses things, so you’ll have to do it manually
.When you’re done, it should look like this:

const bodyParser = require('body-parser');
const cookieParser = require('cookie-parser');
const express = require('express');
const expressSession = require('express-session')({
  secret: 'random strings here are good',
  resave: false,
  saveUninitialized: true,
});
const favicon = require('serve-favicon');
const LocalStrategy = require('passport-local').Strategy;
const logger = require('morgan');
const mongoose = require('mongoose');
const passport = require('passport');
const path = require('path');
const webpack = require('webpack');
const webpackConfig = require('./webpack.config');
const webpackDevMiddleware = require('webpack-dev-middleware');
const webpackHotMiddleware = require('webpack-hot-middleware');

const appConfig = require('./config.js');

  secret: appConfig.expressSession.secret,

.That’s it for this file
.Save it, and open /api/routes/authentication.js
.We’re going to replace a couple of lines here, too, but first we need to make the same addition at the very top of the file, except with an adjusted directory structure:

const appConfig = require('../../config.js');

  apiKey: appConfig.mailgun.apiKey,
  domain: appConfig.mailgun.domain,

    const secret = appConfig.crypto.secret;

        from: `CloseBrace <postmaster@${appConfig.mailgun.domain}>`,

.Now, let’s make sure our JSON file gets ignored
.Open up .gitignore, and at the bottom of the file add these lines:

# Application Configuration
config.json

git status

git add -A

git commit -m "whatever commit message you want"

git push

#Five Minute React 64 - Save Password Part 1

.So let’s start by creating a new file in /src/components/account called ChangePasswordPage.jsx
.This will hold our form
.Let’s start with the imports:

import React from 'react';
import { AvForm, AvGroup, AvInput, AvFeedback } from 'availity-reactstrap-validation';
import { Button, Label } from 'reactstrap';

export default class ChangePasswordPage extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    return (
      <div className="row justify-content-center">
        <div className="col-10 col-sm-7 col-md-5 col-lg-4">
        </div>
      </div>
    );
  }
}

          <p>
            Please enter and confirm a new password below to change the
            password associated with this email address.
          </p>

          <AvForm onValidSubmit={this.handleValidSubmit}>

            <AvGroup>
              <Label for="password">Password</Label>
              <AvInput
                id="password"
                minLength="8"
                name="password"
                onChange={this.handleInputChange}
                onKeyPress={this.handleKeyPress}
                placeholder="password"
                required
                type="password"
                value={this.state.password}
              />
              <AvFeedback>Passwords must be at least eight characters in length</AvFeedback>
            </AvGroup>

            <AvGroup>
              <Label for="password">Confirm Password</Label>
              <AvInput
                id="passwordCheck"
                minLength="8"
                name="passwordCheck"
                onChange={this.handleInputChange}
                onKeyPress={this.handleKeyPress}
                placeholder="password again"
                required
                type="password"
                validate={{ match: { value: 'password' } }}
                value={this.state.passwordCheck}
              />
              <AvFeedback>Passwords must match</AvFeedback>
            </AvGroup>

            <Button color="primary">Change Password</Button>

          </AvForm>

  // Handle input changes
  handleInputChange(e) {
    this.setState({ [e.currentTarget.id]: e.target.value });
  }

  // catch enter clicks
  handleKeyPress(target) {
    if (target.charCode === 13) {
      target.preventDefault();
      this.handleValidSubmit();
    }
  }

  // Handle submission once all form data is valid
  handleValidSubmit() {
    const formData = this.state;
    // todo: handle submit
  }

    // bound functions
    this.handleInputChange = this.handleInputChange.bind(this);
    this.handleKeyPress = this.handleKeyPress.bind(this);
    this.handleValidSubmit = this.handleValidSubmit.bind(this);

    // component state
    this.state = {
      password: '',
      passwordCheck: '',
    };

import React from 'react';
import { AvForm, AvGroup, AvInput, AvFeedback } from 'availity-reactstrap-validation';
import { Button, Label } from 'reactstrap';

export default class ChangePasswordPage extends React.Component {
  constructor(props) {
    super(props);

    // bound functions
    this.handleInputChange = this.handleInputChange.bind(this);
    this.handleKeyPress = this.handleKeyPress.bind(this);
    this.handleValidSubmit = this.handleValidSubmit.bind(this);

    // component state
    this.state = {
      password: '',
      passwordCheck: '',
    };
  }

  // Handle input changes
  handleInputChange(e) {
    this.setState({ [e.currentTarget.id]: e.target.value });
  }

  // catch enter clicks
  handleKeyPress(target) {
    if (target.charCode === 13) {
      target.preventDefault();
      this.handleValidSubmit();
    }
  }

  // Handle submission once all form data is valid
  handleValidSubmit() {
    const formData = this.state;
    // todo: handle submit
  }

  render() {
    return (
      <div className="row justify-content-center">
        <div className="col-10 col-sm-7 col-md-5 col-lg-4">
          <p>
            Please enter and confirm a new password below to change the
            password associated with this email address.
          </p>

          <AvForm onValidSubmit={this.handleValidSubmit}>

            <AvGroup>
              <Label for="password">Password</Label>
              <AvInput
                id="password"
                minLength="8"
                name="password"
                onChange={this.handleInputChange}
                onKeyPress={this.handleKeyPress}
                placeholder="password"
                required
                type="password"
                value={this.state.password}
              />
              <AvFeedback>Passwords must be at least eight characters in length</AvFeedback>
            </AvGroup>

            <AvGroup>
              <Label for="password">Confirm Password</Label>
              <AvInput
                id="passwordCheck"
                minLength="8"
                name="passwordCheck"
                onChange={this.handleInputChange}
                onKeyPress={this.handleKeyPress}
                placeholder="password again"
                required
                type="password"
                validate={{ match: { value: 'password' } }}
                value={this.state.passwordCheck}
              />
              <AvFeedback>Passwords must match</AvFeedback>
            </AvGroup>

            <Button color="primary">Change Password</Button>

          </AvForm>
        </div>
      </div>
    );
  }
}

.Save your file, and create a new one in /src/components/account/ called ChangePasswordPageContainer.jsx
.This one’s a lot shorter right now, since we’re not going to handle connecting to the API in this tutorial, so here’s all of it:

import React from 'react';
import { connect } from 'react-redux';

import ChangePasswordPage from './ChangePasswordPage';

export class ChangePasswordPageContainer extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    const { hash } = this.props.match.params;
    return (
      <ChangePasswordPage hash={hash} />
    );
  }
}

export default connect()(ChangePasswordPageContainer);

.ESLint will complain about a useless class, here, but don’t worry – in the next tutorial we’ll be making it useful
.For now, we’re set here, so go ahead and save this file too
.Then open up /src/Template.jsx
.We need to add a route so we can see our new page
.First, above line 4, add the following:

import ChangePasswordPage from './account/ChangePasswordPageContainer';

          <Route path="/account/change-password/:hash" component={ChangePasswordPage} />

.This will populate that “hash” parameter we’re referencing on line 12 of ChangePasswordPageContainer.jsx, and which we’ll eventually send to the API to determine which user we’re updating.

.Save this file and we’re done with the front-end for now
.You can fire up a browser and head for localhost:3000/account/change-password, and see the page
.OR CAN YOU?! No, you can’t, because it only shows up if you provide it a hash
.For now, you can use any random gibberish, like localhost:3000/account/change-password/asdfghjk and you’ll be able to see the form, and confirm that its validation is working.

.We’ve still got some time, so let’s build our API endpoint
.Open up /routes/api/authentication.js
.We need a routine that compares the hash against the database in order to determine which user to update, and then does so … assuming it finds a user that matches the hash, anyway
.Underneath line 87, add a padding line, and then here’s the code:

// POST to savepassword
router.post('/savepassword', async (req, res) => {
  let result;
  try {
    // look up user in the DB based on reset hash
    const query = User.findOne({ passwordReset: req.body.hash });
    const foundUser = await query.exec();

    // If the user exists save their new password
    if (foundUser) {
      // user passport's built-in password set method
      foundUser.setPassword(req.body.password, (err) => {
        if (err) {
          result = res.send(JSON.stringify({ error: 'Password could not be saved. Please try again' }));
        } else {
          // once the password's set, save the user object
          foundUser.save((error) => {
            if (error) {
              result = res.send(JSON.stringify({ error: 'Password could not be saved. Please try again' }));
            } else {
              // Send a success message
              result = res.send(JSON.stringify({ success: true }));
            }
          });
        }
      });
    }
  } catch (err) {
    // if the hash didn't bring up a user, error out
    result = res.send(JSON.stringify({ error: 'Reset hash not found in database' }));
  }
  return result;
});

.As you can see, this does a lookup based on the hash
.If it finds a user, it moves on
.If not, it gives an error
.Assuming a user is found, it uses Passport’s built-in setPassword method, which will generate a new hash and salt and all that for the user’s password (remember: we don’t ever store plain-text passwords)
.Assuming that doesn’t bomb out—which it really never should, but better safe than sorry—we save the user to the database with its new password and, again, barring any DB errors, pass on some success JSON.

#Five Minute React 64.5 - Fix The Production Build

.As it turns out, it’s very difficult for Babel to transpile ES2017 features if you’re only running the ES2015 plugin
.Since async / await is an ES2017 addition, it wasn’t getting transpiled … which is fine in development, since both our server and our browser can run ES2017, but is significantly less fine in production because UglifyJS, which compresses our JavaScript to save file size, has no idea what to do with async and thus gives up while throwing an error
.Because we’re using NoEmitOnErrorsPlugin in our Webpack build, this means it doesn’t write out the file at all, even in uncompressed form, which breaks the build (in case you’re new to development, breaking the build is a cardinal sin).

.So let’s fix it! Open up /webpack.config.js and head for line 34
.This is our test block for JSX files
.It looks like this:

      {
        test: /\.jsx?$/,
        exclude: /(node_modules|bower_components|public\/)/,
        loader: 'babel-loader',
      },

      {
        test: /\.jsx?$/,
        exclude: /(node_modules|bower_components|public\/)/,
        loader: 'babel-loader',
        query: {
          presets: ['env'],
        },
      },

      {
        test: /\.js?$/,
        exclude: /(node_modules|bower_components|public\/)/,
        loader: 'babel-loader',
        query: {
          presets: ['env'],
        },
      },

#Five Minute React 65 - Save Password Part 2

.Let’s do that first
.Open up /routes/api/authentication.js
.Head for line 115, which closes an if block
.We need to add an else here
.So change the line to look like this:

    } else {

      result = res.send(JSON.stringify({ error: 'Reset hash not found in database.' }));
    }

    result = res.send(JSON.stringify({ error: 'There was an error connecting to the database.' }));

.That’s all we need to do here
.Save the file, and open up /src/actions/authentication.js
.We need to add a couple of action creators, and a function to talk to the API
.Below line 16, add the following lines:

export const passwordSaveFailure = error => ({ type: 'AUTHENTICATION_PASSWORD_SAVE_FAILURE', error });
export const passwordSaveSuccess = () => ({ type: 'AUTHENTICATION_PASSWORD_SAVE_SUCCESS' });

.With that done, head for the bottom of the file
.Our savePassword function looks a lot like the other functions in this file that talk to the API, so I’m going to hand it to you all at once
.Here’s the code:

// Save a user's password
export function savePassword(data) {
  return async (dispatch) => {
    // clear the error box if it's displayed
    dispatch(clearError());

    // turn on spinner
    dispatch(incrementProgress());

    // contact the API
    await fetch(
      // where to contact
      '/api/authentication/savepassword',
      // what to send
      {
        method: 'POST',
        body: JSON.stringify(data),
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'same-origin',
      },
    )
    .then((response) => {
      if (response.status === 200) {
        return response.json();
      }
      return null;
    })
    .then(async (json) => {
      if (json && json.success) {
        dispatch(passwordSaveSuccess());
      } else {
        dispatch(passwordSaveFailure(new Error(json.error.message ? 'There was an error saving the password. Please try again' : json.error)));
      }
    })
    .catch((error) => {
      dispatch(passwordSaveFailure(new Error(error.message || 'There was an error saving the password. Please try again.')));
    });

    // turn off spinner
    return dispatch(decrementProgress());
  };
}

.Save this file, and let’s head for /src/components/account/ChangePasswordPageContainer.jsx
.Now that we have a function for saving the password, let’s import it just below line 2, like this:

import { savePassword } from '../../actions/authentication';

  sendPassword(formData) {
    const { dispatch } = this.props;
    const data = {
      hash: this.props.match.params.hash,
      password: formData.password,
    };
    dispatch(savePassword(data));
  }

    // bound functions
    this.sendPassword = this.sendPassword.bind(this);

.Previously we were sending the hash down to SavePasswordPage as a prop, but we don’t really need to do that since we’d just have to send it back up on form submission
.Our new helper method takes care of that already, but we do need to send that down as a prop, so we can change line 27 to the following:

      <ChangePasswordPage sendPasswordFunction={this.sendPassword} />

.And we can delete line 25 entirely
.Don’t need it
.Once you’ve done that, we’re done with this file
.Save it, and open up /src/components/account/ChangePasswordPage.jsx
.Let’s use the new function we’re passing down
.This is a two-line addition
.Just below line 36, delete the comment line and add the following code:

    const { sendPasswordFunction } = this.props;
    sendPasswordFunction(formData);

.That’s it! I love when things are easy
.Save this file, and let’s make sure we handle any errors that are getting thrown
.Open up /src/reducers/error.js
.This is another easy change
.Remove the opening brace from line 11, and directly below it, add this line:

    case 'AUTHENTICATION_PASSWORD_SAVE_FAILURE': {

.Head for a browser
.If you still have your latest reset password hash email, you can navigate directly to localhost:3000/account/change-password/whateverthehashwas
.If you don’t have the email, you can either look up your reset hash in the MongoDB console with db.users.find() or you can send yourself a new reset password email.

.That’s it for today
.In the next tutorial we’ll wrap things up by making it clear to the user what’s going on, which is always a plus
.After that, we’ll be done with /account for a while and will be moving into the “music” part of MusicList
.Pretty exciting, huh?

#Five Minute React 66 - Save Password Part 3

.So let’s do this
.Open up /src/actions/authentication.js
.We’re going to add a single action creator here that we’ll use for a little state manipulation magic
.Below line 16, add the following:

export const passwordSaveClear = () => ({ type: 'AUTHENTICATION_PASSWORD_SAVE_CLEAR' });

.That’s all you need
.Save the file, and move on to /src/reducers/authentication.js
.We need to track whether the user just saved a new password or not, so under line 5, add this code:

  isPasswordChanged: false,

    case 'AUTHENTICATION_PASSWORD_SAVE_CLEAR': {
      const newState = Object.assign({}, state);
      newState.isPasswordChanged = false;
      return newState;
    }
    case 'AUTHENTICATION_PASSWORD_SAVE_SUCCESS': {
      const newState = Object.assign({}, state);
      newState.isPasswordChanged = true;
      return newState;
    }

.We’ll be able to use these state changes to adjust presentation in our component, much the way we did on the password reset page
.Save this file and open up /src/components/account/ChangePasswordPageContainer.jsx
.We need to add a lifecycle function here that’ll run our clearing action whenever this component unmounts (which happens any time the app’s not displaying it)
.First up, change line 3 like this:

import { passwordSaveClear, savePassword } from '../../actions/authentication';

  // Clear password changed state on unmount
  componentWillUnmount() {
    const { dispatch } = this.props;
    dispatch(passwordSaveClear());
  }

.Let’s also take a second to clean up and optimize our sendPassword function a bit
.There’s no real reason to be sending up all of the form data from the page component when all we really need is the password
.Change line 21 to this:

  sendPassword(password) {

      password,

var myObj = {
  password: password,
}

.Anyway, head down to your render function and below line 30, add this code:

    const { authentication } = this.props;

      <ChangePasswordPage
        authentication={authentication}
        sendPasswordFunction={this.sendPassword}
      />

.Some of you may be going “wait, we’re not passing down authentication via props … we must need to mapStateToProps to get that.” Yep! Let’s do it
.Below line 39, add a padding line, and then this code:

const mapStateToProps = state => ({ authentication: state.authentication });

export default connect(mapStateToProps)(ChangePasswordPageContainer);

.We’re all set here
.Save the file, and open up /src/components/account/ChangePasswordPage.jsx
.We’re going to add some text with a link, so below line 1, add the following:

import { Link } from 'react-router-dom';

.Next we need to change handleValidSubmit to just send the password, so change line 39 to this:

    sendPasswordFunction(formData.password);

.Then jump to your render block and below line 42, add this code:

    const { isPasswordChanged, isLoggedIn } = this.props.authentication;

.Now we’re going to drop in a couple of different possible returns
.This is the same basic thing that we did on the reset password page
.In this case, though, we’re going to check for both our isPasswordChanged state variable, and also isLoggedIn, which will let us give different text to users who are or are not logged in (there’s not much point in encouraging a logged-in user to log in, after all)
.This isn’t really necessary right now since we don’t have a path for logged-in users to change their password yet (we’ll do that eventually, but not before we tackle some music-related stuff), but it’s better to just do it now.

    // If they just changed a password and AREN'T logged in
    if (isPasswordChanged && !isLoggedIn) {
      return (
        <div className="row justify-content-center">
          <div className="col-10 col-sm-7 col-md-5 col-lg-4">
            <p>
              Your changes have been saved, and you can
              now <Link to="/account/login">log in</Link> with
              the new password.
            </p>
          </div>
        </div>
      );
    }

    // If they just changed a password and ARE logged in
    if (isPasswordChanged && isLoggedIn) {
      return (
        <div className="row justify-content-center">
          <div className="col-10 col-sm-7 col-md-5 col-lg-4">
            <p>
              Your new password has been saved.
            </p>
          </div>
        </div>
      );
    }

#Five Minute React 67 - Setting Up An External API

.Don’t worry about the other two fields
.Just go ahead and create the application
.Once you do, you’ll be given a consumer key and secret, and some URLs that will allow you to make requests
.Awesome! Let’s get some of this info into our app config
.Flip over to Sublime Text and open /config.json
.Below line 4, add a new section for Discogs, like this (obviously, use your own data here instead of this sample data):

  "discogs": {
    "key": "HJYbPXSTxoqAlbMRneAp",
    "secret": "OAcURQBaneVjufVpzXjkexMriSPaNHGL"
  },

.Save that file and open up /config.js
.Under line 7, export our new block like this:

exports.discogs = parsed.discogs;

.Save that file, and switch to a command prompt or terminal window
.In your musiclist directory, type:

$ npm add disconnect@1.2.1

.Let it run, and you’re good to go here
.I recommend restarting your server just to be safe
.Then switch back to Sublime, and let’s … well, we could start with a bunch of stuff, here, but let’s go with creating an Album model which we’ll use to save albums to the DB
.We don’t actually have to do this, since as mentioned we could just always use Discog’s API, but storing stuff on our own DB is a) generally faster than hitting an external API and b) a good way to stay below that 60-requests-per-minute cap.

.The Discogs’ API spits out an absolute S#!^-ton of data
.More than we need for our simple app
.By using a model, we can pick and choose what to store
.Mongoose will ignore anything that doesn’t fit into the model
.So, create a new file in /models named album.js and add the following code:

const mongoose = require('mongoose');

const Schema = mongoose.Schema;

const Album = new Schema({
  title: String,
  discogId: Number,
  artists: [Schema.Types.Mixed],
  thumb: String,
  country: String,
  formats: [Schema.Types.Mixed],
  genres: [Schema.Types.Mixed],
  images: [Schema.Types.Mixed],
  labels: [Schema.Types.Mixed],
  notes: String,
  released: String,
  styles: [String],
  tracklist: [Schema.Types.Mixed],
  year: Number,
});

module.exports = mongoose.model('Album', Album);

.Oh, and by the way, those Schema types in square braces? That means “an array full of this type of stuff” (and mixed means “basically anything” which includes objects)
.So for example images is going to be an array full of objects with a bunch of image information in them
.styles is going to be an array of strings.

#Five Minute React 68 - Search Albums

.First, let’s create an API endpoint for searching the Discogs database
.We’re doing this in a slightly weird manner because the disconnect module doesn’t play well with front-end code, so we’re going to contact our API, which will then reach out to the Discogs API
.Don’t worry, it’s not too complicated
.Head for /routes/api/ and create a file called albums.js
.In that file, insert the following imports and related functionality:

const appConfig = require('../../config.js');
const Discogs = require('disconnect').Client;
const express = require('express');
const mongoose = require('mongoose');

const router = express.Router();

// configure mongoose promises
mongoose.Promise = global.Promise;

// configure Discogs
const discogsClient = new Discogs('MusicList-closebrace/0.1', {
  consumerKey: appConfig.discogs.key,
  consumerSecret: appConfig.discogs.secret,
});
const discogsDB = discogsClient.database();

// POST to /search
router.post('/search', async (req, res) => {
  // Contact Discogs API
  await discogsDB.search(req.body, (err, data) => {
    if (err) {
      const error = new Error(err);
      return res.json(error);
    }
    return res.json(data);
  });
});

module.exports = router;

.That’s it
.We’ll handle telling Discogs what to search for in our action file
.Speaking of which, save this file and then create a new one in /src/actions called albums.js
.This one’s a little longer, but it’s going to look very familiar
.Some action creators, and then a method that uses fetch to POST to the API
.Here are the imports and action creators:

import 'whatwg-fetch';
import { decrementProgress, incrementProgress } from './progress';
import { clearError } from './error';

// Action Creators
export const albumSearchClear = () => ({ type: 'MUSIC_ALBUM_SEARCH_CLEAR' });
export const albumSearchFailure = error => ({ type: 'MUSIC_ALBUM_SEARCH_FAILURE', error });
export const albumSearchSuccess = json => ({ type: 'MUSIC_ALBUM_SEARCH_SUCCESS', json });

// Search Albums
export function searchAlbums(searchText) {
  return async (dispatch) => {
    // clear the error box if it's displayed
    dispatch(clearError());

    // turn on spinner
    dispatch(incrementProgress());

    // Build packet to send to Discogs API
    const searchQuery = {
      q: searchText,
      type: 'master',
      format: 'album',
    };

    // Send packet to our API, which will communicate with Discogs
    await fetch(
      // where to contact
      '/api/albums/search',
      // what to send
      {
        method: 'POST',
        body: JSON.stringify(searchQuery),
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'same-origin',
      },
    )
    .then((response) => {
      if (response.status === 200) {
        return response.json();
      }
      return null;
    })
    .then((json) => {
      if (json.results) {
        return dispatch(albumSearchSuccess(json));
      }
      return dispatch(albumSearchFailure(new Error(json.error)));
    })
    .catch(error => dispatch(albumSearchFailure(new Error(error))));

    // turn off spinner
    return dispatch(decrementProgress());
  };
}

.The only thing to note here is the data packet we’re sending to Discogs, which is using type: 'master' and format: 'album'
.This is important because if we didn’t set the type to master, we’d get every single version of an album, instead of the Discogs master listing for it
.As an example, I looked up the recent release “Villains” by Queens of the Stone Age, and there are 37 versions of that album alone (many of them just differing by what country they were released in)
.So if you searched for an artist like, say, The Beatles, without setting your type to master, you’d probably get thousands of results
.Not very useful!

.Save this file, and now we need a reducer to listen to our actions
.So, in /src/reducers/, create yet another file called albums.js, and in it, add the following code:

const initialState = [];
export default function reducer(state = initialState, action) {
  switch (action.type) {
    case 'MUSIC_ALBUM_SEARCH_SUCCESS': {
      const newState = action.json.results.slice();
      return newState;
    }
    case 'MUSIC_ALBUM_SEARCH_CLEAR': {
      const newState = initialState.slice();
      return newState;
    }
    default: {
      return state;
    }
  }
}

.And of course we need to catch the failure action as well, so save that file and open /src/reducers/error.js
.Remove the close brace from line 12 and directly below it, add this line:

    case 'MUSIC_ALBUM_SEARCH_FAILURE': {

.We’re good here
.Save the file and open /src/reducers/index.js
.We need to add our new reducer to the Store, so under line 1, add this code:

import AlbumsReducer from '../reducers/albums';

  albums: AlbumsReducer,

.That’s all we need here, so save the file and head for /app.js
.We need to wire up our new API route
.That’s going to happen on line 23, but while we’re here let’s clean up and alphabetize this entire block
.I suggest this code:

// Route Files
const api = require('./routes/api/index');
const albums = require('./routes/api/albums');
const authentication = require('./routes/api/authentication');
const index = require('./routes/index');
const users = require('./routes/api/users');

app.use('/api/albums', albums);

.While you’re at it, move the authentication line up above the users line for alphabetical ordering purposes
.Good
.We’re done here! Save the file, and let’s create a new folder in /src/components called albums
.Then, in that folder, create a new file called AlbumsPageContainer.jsx
.This is going to look very familiar at this point
.Here it is:

import React from 'react';
import { connect } from 'react-redux';
import { albumSearchClear, searchAlbums } from '../../actions/albums';

import AlbumsPage from './AlbumsPage';

export class AlbumsPageContainer extends React.Component {
  constructor(props) {
    super(props);

    // bound functions
    this.searchAlbumsFunction = this.searchAlbumsFunction.bind(this);
  }

  componentWillUnmount() {
    const { dispatch } = this.props;
    dispatch(albumSearchClear());
  }

  searchAlbumsFunction(searchText) {
    const { dispatch } = this.props;
    dispatch(searchAlbums(searchText));
  }

  render() {
    const { albums } = this.props;
    return (
      <AlbumsPage
        albums={albums}
        searchAlbumsFunction={this.searchAlbumsFunction}
      />
    );
  }
}

const mapStateToProps = state => ({ albums: state.albums });

export default connect(mapStateToProps)(AlbumsPageContainer);

.Save the file and create another new file in /src/components/albums called—you guessed it!—AlbumsPage.jsx
.This is probably the longest chunk of code I’ve ever given you guys other than a “here’s what the whole file should look like” wrapup … so here we go!

import React from 'react';
import { AvForm, AvGroup, AvInput, AvFeedback } from 'availity-reactstrap-validation';
import { Button, Label } from 'reactstrap';

// helpers
const listAlbums = albums => albums.map(album =>
  (
    <p key={album.id}>
      <img src={album.thumb} alt="album thumbnail" />
      <strong>Title: {album.title}</strong><br />
    </p>
  ),
);

export default class AlbumsPage extends React.Component {
  constructor(props) {
    super(props);

    // bound functions
    this.handleSearchChange = this.handleSearchChange.bind(this);
    this.handleKeyPress = this.handleKeyPress.bind(this);
    this.handleValidSubmit = this.handleValidSubmit.bind(this);

    // component state
    this.state = {
      searchText: '',
    };
  }

  // update state as search value changes
  handleSearchChange(e) {
    this.setState({ searchText: e.target.value });
  }

  // catch enter clicks
  handleKeyPress(target) {
    if (target.charCode === 13) {
      this.handleValidSubmit();
    }
  }

  // Handle submission once all form data is valid
  handleValidSubmit() {
    const { searchAlbumsFunction } = this.props;
    const formData = this.state;
    searchAlbumsFunction(formData.searchText);
  }

  render() {
    const { albums } = this.props;
    return (
      <div>
        <div className="row justify-content-center">
          <div className="col-10 col-sm-7 col-md-5 col-lg-4">
            <AvForm onValidSubmit={this.handleValidSubmit}>
              <AvGroup>
                <h2><Label for="search">Search Albums</Label></h2>
                <p>
                  Find albums you own and add them to your MusicList.
                  You can search by album title or artist name.
                </p>
                <AvInput
                  id="search"
                  name="search"
                  onChange={this.handleSearchChange}
                  onKeyPress={this.handleKeyPress}
                  placeholder="Queens of the Stone Age"
                  required
                  type="text"
                  value={this.state.searchText}
                />
                <AvFeedback>Required</AvFeedback>
              </AvGroup>
              <Button color="primary">Search Albums</Button>
            </AvForm>
          </div>
        </div>
        <div className="row">
          <div className="col-12 col-sm-12">
            { albums && albums.length > 0 ? <div><hr /><h2>Albums</h2></div> : null }
            { albums && albums.length > 0 ? listAlbums(albums) : null }
          </div>
        </div>
      </div>
    );
  }
}

.Most of this should be super-familiar, but let’s take a look at two things
.First is our listAlbums helper on line 6
.This takes an array of albums, then loops through it using Array.map to spit back out JSX for each album in the array
.This is wildly handy, and we’ll be using similar helpers all over the place
.Notice that it’s using not one but two ES6 implicit returns
.If you need a refresher on those, we talked about them in depth in Tutorial 41.

.All right, last thing: we need to add this new page to our Template file for routing
.So save this file, and open up /src/components/Template.jsx
.Below line 3, add this code:

import AlbumsPage from './albums/AlbumsPageContainer';

          <Route exact path="/albums" component={AlbumsPage} />

.Save the file and you’re done
.Well, almost
.Due to the version-locking we’re doing, if you were to refresh right now, your browser console would be spammed with terrifying errors
.This is because our DevTools logger has a bug that makes it very unhappy if you use an array for initialState in your reducer
.To fix this bug, head to your terminal or command prompt, kill your server, and type:

$ npm add --dev redux-devtools-dock-monitor@1.1.3 redux-devtools-log-monitor@1.4.0

.Once that runs, restart your server
.We've built a whole bunch of stuff
.The API endpoint, actions and reducers, and a page to control them all
.Let’s check in a browser and make sure this thing works
.Restart your server for safety, and when it’s ready, refresh your site
.Then head for localhost:3000/albums
.You should see your search box, awaiting input
.Type in the name of your favorite band
.Unless they’re a J-Pop/Ska fusion band from Norway, Discogs will probably have an album of theirs in the DB
.Actually, they still might! You should see a really ugly list of albums pop up
.Nice! Next step: making that list a bit prettier, and a lot more functional
.See you then!

#Five Minute React 69 - Add Album Front-End

.Open up /src/components/albums/AlbumsPage.jsx
.We’re going to add some functions, update a few others, and improve the cosmetics of our output significantly
.First let’s import a Reactstrap table by changing line 3 to this:

import { Button, Label, Table } from 'reactstrap';

const formatTitle = (discogsTitle, value) => discogsTitle.split(' - ')[value];
const formatGenre = discogsGenre => discogsGenre.join(', ');

.Next we’re going to move listAlbums into our class, because it turns out we’re going to need to access some props (they’ll show up in the next tutorial)
.So cut what are now lines 8 to 15, these guys:

const listAlbums = albums => albums.map(album =>
  (
    <p key={album.id}>
      <img src={album.thumb} alt="album thumbnail" />
      <strong>Title: {album.title}</strong><br />
    </p>
  ),
);

.And paste them in below what is now line 41, the end of our handleValidSubmit function
.Then modify them to look like this:

  listAlbums(albums) {
    return albums.map(album =>
      (
        <tr key={album.id}>
          <td><img src={album.thumb} alt="album thumbnail" width="80" height="80" /></td>
          <td>{formatTitle(album.title, 1)}</td>
          <td>{formatTitle(album.title, 0)}</td>
          <td>{formatGenre(album.genre)}</td>
          <td>
            <Button color="primary" outline id={album.id} onClick={this.addAlbum}>
              Add To My List
            </Button>
          </td>
        </tr>
      ));
  }

.You may notice we’re generating table rows here
.That means we also need to generate the table itself, but we can’t do that in the listAlbums function because it’d create a separate table for every individual album
.So instead, add a new function in between handleValidSubmit and listAlbums like this:

  createTable(albums) {
    return (
      <Table striped responsive>
        <thead>
          <tr>
            <th />
            <th>Title</th>
            <th>Artist</th>
            <th>Genre(s)</th>
            <th />
          </tr>
        </thead>
        <tbody>
          { this.listAlbums(albums) }
        </tbody>
      </Table>
    );
  }

.Then, below listAlbums (which should end on line 77 right now), let’s add a simple function for adding an album, which will use a prop that we’re not passing down yet … but that’s OK
.Here’s the code:

  // Add an album to the user's list
  addAlbum(e) {
    const { addAlbumFunction } = this.props;
    // get id from button and send to the API
    addAlbumFunction(e.target.id);
  }

    this.addAlbum = this.addAlbum.bind(this);
    this.createTable = this.createTable.bind(this);
    this.handleSearchChange = this.handleSearchChange.bind(this);
    this.handleKeyPress = this.handleKeyPress.bind(this);
    this.handleValidSubmit = this.handleValidSubmit.bind(this);
    this.listAlbums = this.listAlbums.bind(this);

            { albums && albums.length > 0 ? <div><hr /><h2>Albums</h2></div> : null }
            { albums && albums.length > 0 ? listAlbums(albums) : null }

            { albums && albums.length > 0 ? <h2>Albums</h2> : null }
            <div className="row">
              <div className="col-sm-12 col-lg-12">
                { albums && albums.length > 0 ? this.createTable(albums) : null }
              </div>
            </div>

.We’re good here
.Save the file and open /src/components/AlbumsPageContainer.jsx
.Below line 1, add this:

import { bindActionCreators } from 'redux';

import { addAlbum, albumSearchClear, searchAlbums } from '../../actions/albums';

.We’ll create that additional action in a minute
.In the meantime, let’s use Redux’s built-in mapDispatchToProps functionality to reduce the need for helper functions that just dispatch action creators
.Delete lines 21 to 24, our entire searchAlbumsFunction block, entirely
.We don’t actually need it
.This also means we don’t need our constructor anymore, so delete lines 9 to 14 while you’re at it
.Then just above line 25, our mapStateToProps function, add this code:

const mapDispatchToProps = dispatch => bindActionCreators({
  addAlbumFunction: addAlbum,
  searchAlbumsFunction: searchAlbums,
  dispatch,
}, dispatch);

.Note: we have to explicitly map dispatch in here because of how Redux works
.If you don’t define mapDispatchToProps it automatically sends dispatch along as a prop, but if you define it manually, it leaves it up to you to send it
.Note that we’re also gaining access to searchAlbums here instead of through the helper function we just deleted, as well as giving ourselves access to the addAlbum function we’re about to create
.Cool
.Change line 33 to this:

export default connect(mapStateToProps, mapDispatchToProps)(AlbumsPageContainer);

    const { addAlbumFunction, albums, searchAlbumsFunction } = this.props;

        addAlbumFunction={addAlbumFunction}
        albums={albums}
        searchAlbumsFunction={searchAlbumsFunction}

.Save this file and let’s create that addAlbum function
.Open /src/actions/albums.js
.Below line 5, add two new action creators:

export const albumAddFailure = error => ({ type: 'MUSIC_ALBUM_ADD_FAILURE', error });
export const albumAddSuccess = json => ({ type: 'MUSIC_ALBUM_ADD_SUCCESS', json });

// Add an Album
export function addAlbum(id) {
  return async (dispatch) => {
    // clear the error box if it's displayed
    dispatch(clearError());

    // turn on spinner
    dispatch(incrementProgress());

    // Send packet to our API, which will communicate with Discogs
    await fetch(
      // where to contact
      '/api/albums/add',
      // what to send
      {
        method: 'POST',
        body: JSON.stringify({ id }),
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'same-origin',
      },
    )
    .then((response) => {
      if (response.status === 200) {
        return response.json();
      }
      return null;
    })
    .then((json) => {
      if (json.email) {
        return dispatch(albumAddSuccess(json));
      }
      return dispatch(albumAddFailure(new Error(json)));
    })
    .catch(error => dispatch(albumAddFailure(new Error(error))));

    // turn off spinner
    return dispatch(decrementProgress());
  };
}

.Head for a browser, navigate to localhost:3000/albums and perform a new search
.You should see your table full of albums come up, with an “add album” button for each
.Obviously there’s a great deal of UX improvement you could do here, such as adding checkboxes to add multiple albums at once, but this tutorial is about creating a barebones app
.So, for the sake of brevity we’re going to stick to what we’ve got
.It still looks a whole lot better than it did!

#Five Minute React 70 - Add Album Back-End

.First, let’s adjust our User model so that we can save arrays of IDs for albums and artists
.Open up /models/User.js and, first off, under line 6, add these two lines:

  albums: [Schema.Types.Mixed],
  artists: [Schema.Types.Mixed],

.Open up /routes/api/albums.js
.Below line 4, import our User model like this:

const User = require('../../models/user.js');

.Then head down to line 17, add a padding line, and let’s get started on our /add route
.There’s some stuff happening in this route that we haven’t done before, so I’m going to do this one piece-by-piece
.Here’s the route container:

// POST to /add
router.post('/add', async (req, res) => {
});

  // Make sure a user's actually logged in
  if (!req.user) {
    return res.json({ error: 'User not logged in' });
  }

  // Wrap discogs API call in a promise so we can use async / await
  const discogsGetMaster = albumId => new Promise((resolve) => {
    discogsDB.getMaster(albumId, (err, data) => {
      resolve(data);
    });
  });

.The Discogs API is callback-based, which means nesting functions
.That’s fine, mildly annoying compared to async / await, so we’re wrapping the API call in our own function which returns an ES2015 promise, then resolves that promise once we have data to send
.Now we can use that with async / await, which we’ll do below in a try / catch block.

  const albumId = parseInt(req.body.id, 10);
  let result;

  try {
    // Get album info from discogs AI
    const albumInfo = await discogsGetMaster(albumId);

    // Find the user we want to save to
    const query = User.findOne({ email: req.user.email });
    const foundUser = await query.exec();

    // Sanity Check! Is the album already added?
    const albumIndex = foundUser.albums.indexOf(albumInfo.id);
    if (albumIndex < 0) {
      foundUser.albums.push(albumInfo.id);
    }

    // Sanity Check 2! Is the artist already added?
    for (let i = 0; i < albumInfo.artists.length; i += 1) {
      const artistIndex = foundUser.artists.indexOf(albumInfo.artists[i].id);
      if (artistIndex < 0) {
        foundUser.artists.push(...albumInfo.artists.map(artist => artist.id));
      }
    }

    foundUser.save((error) => {
      if (error) {
        result = res.json({ error: 'Album could not be saved. Please try again.' });
      } else {
        result = res.json(foundUser);
      }
    });
  } catch (err) {
    result = res.json({ error: 'There was an error saving the album to the database. Please try again.' });
  }

  return result;

.What we’re doing here should be pretty clear
.We hit the Discogs API, await its result, get the user record associated with the logged-in user, and then we make sure the album and artist aren’t already saved to the user’s profile
.If they’re not, we go ahead and save the album and artist IDs to the user’s DB reacord via the User object, throwing the requisite errors if things go wrong
.Straightforward!

.For now, we’re good, so save the file and move on to /src/reducers
.We’re going to create a new file here called user.js which we’ll use to contain state information about a user that doesn’t include any authentication details
.Here’s the code:

const initialState = {
  albums: [],
  artists: [],
};

export default function reducer(state = initialState, action) {
  switch (action.type) {
    case 'AUTHENTICATION_LOGIN_SUCCESS':
    case 'AUTHENTICATION_SESSION_CHECK_SUCCESS': {
      const newState = Object.assign({}, state);
      newState.albums = action.json.albums;
      newState.artists = action.json.artists;
      return newState;
    }
    case 'MUSIC_ALBUM_ADD_SUCCESS': {
      const newState = Object.assign({ }, state);
      newState.albums = action.json.albums;
      return newState;
    }
    default: {
      return state;
    }
  }
}

.This should be pretty straightforward
.We’re updating the state when a user adds an album, but also when we do our initial session check or when a user logs in, which means we populate the user’s album IDs into the state right away, which means when we display search results we can identify which albums the user’s already added and mark them as such
.Save this file
.We need to include it in the Store, which means opening /src/reducers/index.js and adding this code under line 5:

import UserReducer from '../reducers/user';

  user: UserReducer,

.That’s it for that one, so save it, and open up /src/components/albums/AlbumsPageContainer.jsx
.Let’s grab our user information from the Store and send it down to the Albums page as a prop
.To do that, change line 32 to this code:

const mapStateToProps = state => ({ albums: state.albums, user: state.user });

    const { addAlbumFunction, albums, searchAlbumsFunction, user } = this.props;

        user={user}

.Save this file and then open up /src/components/albums/AlbumsPage.jsx
.Find line 65 and, below it, add the following:

    const { user } = this.props;

            <Button color="primary" outline id={album.id} onClick={this.addAlbum}>
              Add To My List
            </Button>

            { user.albums.indexOf(album.id) < 0 ?
              <Button color="primary" outline id={album.id} onClick={this.addAlbum}>
                Add To My List
              </Button> :
              <span>Already Listed</span>
            }

#Five Minute React 71 - Saving Music Data Locally

.So let’s get started with two easy changes
.First, open /models/album.js and replace line 7, which has an incorrectly spelled key (way to go, me!) with the following:

  discogsId: { type: Number, unique: true },

.The unique thing is important
.We’re setting discogsId as a unique index, which means the database will throw an error if we try to submit two albums with the same id
.We’re going to run a check for this anyway, but it’s still a useful backup to have.

.Save this file, and then create a new file in /models called artist.js
.We’re going to save a subset of the artist data that Discogs provides to our database, just like with albums
.Here’s the code:

const mongoose = require('mongoose');

const Schema = mongoose.Schema;

const Artist = new Schema({
  discogsId: { type: Number, unique: true },
  images: [Schema.Types.Mixed],
  members: [Schema.Types.Mixed],
  name: String,
  namevariations: [String],
  profile: String,
  urls: [String],
});

module.exports = mongoose.model('Artist', Artist);

.Save this file, and head for /routes/api/albums.js
.This is where the major changes come in, and there’s a lot of them
.I spent a bunch of time writing and rewriting this code, trying to get something that worked reliably with async / await and didn’t have to do a ton of looping and nesting functions
.Took a while, but I got there! I’ve created a bunch of helper functions to help keep things clean, and we’re wrapping all of our Discogs calls in promises to better facilitate awaiting them.

const Album = require('../../models/album.js');
const Artist = require('../../models/artist.js');

// Check if album exists and if not, save it
const saveAlbum = async (albumInfo) => {
  let errors = false;
  const albumQuery = await Album.findOne({ discogsId: albumInfo.id });
  if (!albumQuery) {
    const albumInfoModified = Object.assign({ discogsId: albumInfo.id }, albumInfo);
    const newAlbum = new Album(albumInfoModified);
    await newAlbum.save((error) => {
      if (error) { errors = true; }
    });
  }
  if (errors) {
    return false;
  }
  return true;
};

.Note that we’re adding our discogsId field during the Object.assign step
.This is important because otherwise the first album we ever add will have a “null” value for that field, and since it’s unique, no further albums can be added, since they’ll also have null as a value, and Mongoose will go “nah, there’s already one in there with that value” and reject the addition.

// Check each artist in an array to see if it exists and if not, save it
const saveArtists = async (artists) => {
  const formattedArtists = artists.map((artist) => {
    const newArtist = Object.assign({ discogsId: artist.id }, artist);
    return newArtist;
  });
  try {
    const result = await new Promise((resolve) => {
      Artist.insertMany(
        formattedArtists,
        { ordered: false },
        (error) => {
          if (error && error.code !== 11000) {
            resolve(false);
          }
          resolve(true);
        },
      );
    });
    return result;
  } catch (error) {
    if (error.code !== 11000) {
      return false;
    }
    return true;
  }
};

.We’re using MongoDB’s built-in insertMany method, here, but there’s a small problem with that
.By default, the method craps out if any part of your array matches an existing record, and stops adding any additional artists who are listed
.So if you’re adding a collaboration album between Kendrick Lamar and, uh … Twenty One Pilots, or something, and you already have Kendrick in your database, Twenty One Pilots won’t get added due to Mongoose throwing an error.

.BUT WAIT! We can fix that, sort of, with that {ordered: false} line
.This tells the database to keep accepting further entries even if it rejects one or more of them as already existing
.This is fantastic, and would be even more fantastic if Mongo and Mongoose didn’t still throw an error
.Because they do, we have to wrap it in a try/catch block to keep script execution running, and we need to check for error code eleven thousand, because that’s the error we want to ignore.

.OK, moving on into the actual POST, which if your spacing matches mine, should now start on line 64
.The following dozen lines remain the same, but we need to add some internal helpers here, too
.Below line 76, add a padding line, and then these two functions:

  // Get a single artist from Discogs
  const discogsGetArtist = artistId => new Promise((resolve) => {
    discogsDB.getArtist(artistId, (err, data) => {
      resolve(data);
    });
  });

  // Loop through artists and hit the Discogs API for each
  const getArtists = async (artists) => {
    const results = artists.map((artist) => {
      const artistInfo = discogsGetArtist(artist.id);
      return artistInfo;
    });
    return Promise.all(results);
  };

.We avoid using await in a loop, here, because it’s bad practice
.Basically, if you do that, the loop hangs until the response comes back, and then continues moving
.Instead, we use Promise.all to tell our code that we want to make an asynchronous hit for each artist, and when they’ve all returned, pass along the final results
.This wouldn’t work if we hadn’t wrapped our Discogs call in a promise, but we did!

.Now we need to add some additional steps to our try / catch block
.Below line 100 (which is a padding line), add this code:

    // Save it to the MusicList DB if it's not already there
    const albumSaved = await saveAlbum(albumInfo);
    if (!albumSaved) { return JSON.stringify(new Error('There was a problem saving the album to the database.')); }

    // Go through the album's artists and get their full info from Discogs
    const artistsInfo = await getArtists(albumInfo.artists);

    // Save the artists to the MusicList DB if they're not already there
    const artistsSaved = await saveArtists(artistsInfo);
    if (!artistsSaved) { return JSON.stringify(new Error('There was a problem saving the artist to the database.')); }

.As you can see, we’re awaiting several results here and then doing stuff once we have it
.We’re also in a few cases erroring out if things break
.The hope is that they won’t, of course, but we’d rather not have them just failing in the background with no notice.

.We’re set here
.The rest of the code is the same
.Save this file
.Now hop over to a terminal window and fire up your MongoDB client by typing mongo
.We’re going to delete our existing albums collection entirely, so type the following:

use musiclist

db.albums.drop()

.We need to do this because we initialized the collection already, but with the wrong settings for discogsId
.It may not strictly be necessary, but it’s more of a precautionary measure.

.Now let’s blank out any albums we previously added to our test user
.The easiest way to do this is the following line, except replacing YOURUSERNAME with, well, your username.

db.users.update({ username: "YOURUSERNAME" }, {$set: { albums: [], artists: [] }})

.Once you’ve run that, we should be all set
.Here’s how we’re going to test this: leave your mongo console open for a bit and switch to a browser
.Hard-refresh your page for safety, and then log in and head for /albums
.Do a search on an artist you like who has at least two albums
.Then add at least two albums to your list by clicking the buttons
.As in the previous tutorial, you’ll see the “Already listed” text appear, which is great.

db.artists.find().length()

db.artists.find()

db.albums.find().length()

#Five Minute React 72 - Search and Add Artists

.Ready? Let’s get artist searching and adding working! In /routes/api create a new file called artists.js
.This is going to be a lot like the albums route, but slightly simplified because when a user adds an artist, we don’t have to loop through all that artist’s albums, because obviously you can be a fan of an artist without owning every single one of their releases.

const Artist = require('../../models/artist.js');
const appConfig = require('../../config.js');
const Discogs = require('disconnect').Client;
const express = require('express');
const mongoose = require('mongoose');
const User = require('../../models/user.js');

const router = express.Router();

// configure mongoose promises
mongoose.Promise = global.Promise;

// configure Discogs
const discogsClient = new Discogs('MusicList-closebrace/0.1', {
  consumerKey: appConfig.discogs.key,
  consumerSecret: appConfig.discogs.secret,
});
const discogsDB = discogsClient.database();

.Then we need a saveArtist helper
.Here it is:

// Check if artist exists and if not, save it
const saveArtist = async (artistInfo) => {
  let errors = false;
  const artistQuery = await Artist.findOne({ discogsId: artistInfo.id });
  if (!artistQuery) {
    const artistInfoModified = Object.assign({ discogsId: artistInfo.id }, artistInfo);
    const newArtist = new Artist(artistInfoModified);
    await newArtist.save((error) => {
      if (error) { errors = true; }
    });
  }
  if (errors) {
    return false;
  }
  return true;
};

.Follow that up with an addArtist function, like this:

// POST to /add
router.post('/add', async (req, res) => {
  // Make sure a user's actually logged in
  if (!req.user) {
    return res.json({ error: 'User not logged in' });
  }

  // Get a single artist from Discogs
  const discogsGetArtist = artistId => new Promise((resolve) => {
    discogsDB.getArtist(artistId, (err, data) => {
      resolve(data);
    });
  });

  const artistId = parseInt(req.body.id, 10);
  let result;

  try {
    // Get artist info from discogs AI
    const artistInfo = await discogsGetArtist(artistId);

    // Save it to the MusicList DB if it's not already there
    const artistSaved = await saveArtist(artistInfo);
    if (!artistSaved) { return JSON.stringify(new Error('There was a problem saving the artist to the database.')); }

    // Find the user we want to save to
    const query = User.findOne({ email: req.user.email });
    const foundUser = await query.exec();

    // Sanity Check! Is the artist already added?
    const artistIndex = foundUser.artists.indexOf(artistInfo.id);
    if (artistIndex < 0) {
      foundUser.artists.push(artistInfo.id);
    }

    foundUser.save((error) => {
      if (error) {
        result = res.json({ error: 'Artist could not be saved. Please try again.' });
      } else {
        result = res.json(foundUser);
      }
    });
  } catch (err) {
    result = res.json({ error: 'There was an error saving the artist to the database. Please try again.' });
  }

  return result;
});

// POST to /search
router.post('/search', async (req, res) => {
  // Contact Discogs API
  await discogsDB.search(req.body, (err, data) => {
    if (err) {
      const error = new Error(err);
      return res.json(error);
    }
    return res.json(data);
  });
});

module.exports = router;

.Total line count is 99, including the padding line at the end of the file
.Save the file, and open app.js
.Below line 25, add this code:

const artists = require('./routes/api/artists');

app.use('/api/artists', artists);

.That’s it
.Save the file, and let’s create a file in /src/components/actions called artists.js
.This one’s near-identical to albums.js except that every instance of “album” has been replaced with “artist”
.Here are our imports and action creators:

import 'whatwg-fetch';
import { decrementProgress, incrementProgress } from './progress';
import { clearError } from './error';

// Action Creators
export const artistAddFailure = error => ({ type: 'MUSIC_ARTIST_ADD_FAILURE', error });
export const artistAddSuccess = json => ({ type: 'MUSIC_ARTIST_ADD_SUCCESS', json });
export const artistSearchClear = () => ({ type: 'MUSIC_ARTIST_SEARCH_CLEAR' });
export const artistSearchFailure = error => ({ type: 'MUSIC_ARTIST_SEARCH_FAILURE', error });
export const artistSearchSuccess = json => ({ type: 'MUSIC_ARTIST_SEARCH_SUCCESS', json });

.And here’s our addArtist function:

// Add an Artist
export function addArtist(id) {
  return async (dispatch) => {
    // clear the error box if it's displayed
    dispatch(clearError());

    // turn on spinner
    dispatch(incrementProgress());

    // Send packet to our API, which will communicate with Discogs
    await fetch(
      // where to contact
      '/api/artists/add',
      // what to send
      {
        method: 'POST',
        body: JSON.stringify({ id }),
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'same-origin',
      },
    )
    .then((response) => {
      if (response.status === 200) {
        return response.json();
      }
      return null;
    })
    .then((json) => {
      if (json.email) {
        return dispatch(artistAddSuccess(json));
      }
      return dispatch(artistAddFailure(new Error(json.error)));
    })
    .catch(error => dispatch(artistAddFailure(new Error(error))));

    // turn off spinner
    return dispatch(decrementProgress());
  };
}

.And finally our searchArtists function:

// Search Artists
export function searchArtists(searchText) {
  return async (dispatch) => {
    // clear the error box if it's displayed
    dispatch(clearError());


    dispatch(incrementProgress());

    // Build packet to send to Discogs API
    const searchQuery = {
      q: searchText,
      type: 'artist',
    };

    // Send packet to our API, which will communicate with Discogs
    await fetch(
      // where to contact
      '/api/artists/search',
      // what to send
      {
        method: 'POST',
        body: JSON.stringify(searchQuery),
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'same-origin',
      },
    )
    .then((response) => {
      if (response.status === 200) {
        return response.json();
      }
      return null;
    })
    .then((json) => {
      if (json.results) {
        return dispatch(artistSearchSuccess(json));
      }
      return dispatch(artistSearchFailure(new Error(json.error)));
    })
    .catch(error => dispatch(artistSearchFailure(new Error(error))));

    // turn off spinner
    return dispatch(decrementProgress());
  };
}

.Total line count, including the padding line at the end, should be 101
.We’re good here
.You should have a firm grasp of what this stuff is doing by now
.If something’s confusing, drop me a line and we’ll figure it out! Save the file, and move on to /src/reducers where we’ll create a new file called artists.js
.Here’s all of the code:

const initialState = [];
export default function reducer(state = initialState, action) {
  switch (action.type) {
    case 'MUSIC_ARTIST_SEARCH_SUCCESS': {
      const newState = action.json.results.slice();
      return newState;
    }
    case 'MUSIC_ARTIST_SEARCH_CLEAR': {
      const newState = initialState.slice();
      return newState;
    }
    default: {
      return state;
    }
  }
}

.WHAM! That’s it for this one, so save it, and open up /src/reducers/user.js
.We’re just adding a new case block, here, so below line 19, add this code:

    case 'MUSIC_ARTIST_ADD_SUCCESS': {
      const newState = Object.assign({ }, state);
      newState.artists = action.json.artists;
      return newState;
    }

.Then save that file, because you’re sooo done with it
.Open up /src/reducers/error.js and let’s make sure we’re reporting errors well
.We actually forgot this step with album addition, so we’ll fix that here too
.Replace line 13 with the following four lines:

    case 'MUSIC_ALBUM_ADD_FAILURE':
    case 'MUSIC_ALBUM_SEARCH_FAILURE':
    case 'MUSIC_ARTIST_ADD_FAILURE':
    case 'MUSIC_ARTIST_SEARCH_FAILURE': {

.Now when something breaks, we won’t have to head for the console to at least get an idea of what’s going on
.Save this file, and open /src/reducers/index.js
.We need to add our artists reducer to the store, so below line 2 add this code:

import ArtistsReducer from '../reducers/artists';

  artists: ArtistsReducer,

.You’re good here, so save the file
.Create a new folder in /src/components called artists and then within that, a new file called ArtistsPageContainer.jsx
.This is going to look a whole lot like AlbumsPageContainer.jsx … you may notice a theme, here
.This is all of the code:

import React from 'react';
import { bindActionCreators } from 'redux';
import { connect } from 'react-redux';
import { addArtist, artistSearchClear, searchArtists } from '../../actions/artists';

import ArtistsPage from './ArtistsPage';

export class ArtistsPageContainer extends React.Component {

  componentWillUnmount() {
    const { dispatch } = this.props;
    dispatch(artistSearchClear());
  }

  render() {
    const { addArtistFunction, artists, searchArtistsFunction, user } = this.props;
    return (
      <ArtistsPage
        addArtistFunction={addArtistFunction}
        artists={artists}
        searchArtistsFunction={searchArtistsFunction}
        user={user}
      />
    );
  }
}

const mapDispatchToProps = dispatch => bindActionCreators({
  addArtistFunction: addArtist,
  searchArtistsFunction: searchArtists,
  dispatch,
}, dispatch);
const mapStateToProps = state => ({ artists: state.artists, user: state.user });

export default connect(mapStateToProps, mapDispatchToProps)(ArtistsPageContainer);

.Now save that and create a file in /src/components/artists called ArtistsPage.jsx
.There are some changes here because it’s a slightly simpler set of data to display
.We don’t need to loop through genres, and we don’t need to split up the “title” of the artist (it’s still called that even though what it means is “name”.

import React from 'react';
import { AvForm, AvGroup, AvInput, AvFeedback } from 'availity-reactstrap-validation';
import { Button, Label, Table } from 'reactstrap';

export default class ArtistsPage extends React.Component {
  constructor(props) {
    super(props);

    // bound functions
    this.addArtist = this.addArtist.bind(this);
    this.createTable = this.createTable.bind(this);
    this.handleSearchChange = this.handleSearchChange.bind(this);
    this.handleKeyPress = this.handleKeyPress.bind(this);
    this.handleValidSubmit = this.handleValidSubmit.bind(this);
    this.listArtists = this.listArtists.bind(this);

    // component state
    this.state = {
      searchText: '',
    };
  }

.Then we need our three handle methods:

  // update state as search value changes
  handleSearchChange(e) {
    this.setState({ searchText: e.target.value });
  }

  // catch enter clicks
  handleKeyPress(target) {
    if (target.charCode === 13) {
      this.handleValidSubmit();
    }
  }

  // Handle submission once all form data is valid
  handleValidSubmit() {
    const { searchArtistsFunction } = this.props;
    const formData = this.state;
    searchArtistsFunction(formData.searchText);
  }

  createTable(artists) {
    return (
      <Table striped responsive>
        <thead>
          <tr>
            <th />
            <th>Artist</th>
            <th />
          </tr>
        </thead>
        <tbody>
          { this.listArtists(artists) }
        </tbody>
      </Table>
    );
  }

  listArtists(artists) {
    const { user } = this.props;
    return artists.map(artist =>
      (
        <tr key={artist.id}>
          <td><img src={artist.thumb} alt="artist thumbnail" width="80" height="80" /></td>
          <td>{artist.title}</td>
          <td>
            { user.artists.indexOf(artist.id) < 0 ?
              <Button color="primary" outline id={artist.id} onClick={this.addArtist}>
                Add To My List
              </Button> :
              <span>Already Listed</span>
            }
          </td>
        </tr>
      ));
  }

.Then there’s our addArtist method:

  // Add an artist to the user's list
  addArtist(e) {
    const { addArtistFunction } = this.props;
    // get id from button and send to the API
    addArtistFunction(e.target.id);
  }

  render() {
    const { artists } = this.props;
    return (
      <div>
        <div className="row justify-content-center">
          <div className="col-10 col-sm-7 col-md-5 col-lg-4">
            <AvForm onValidSubmit={this.handleValidSubmit}>
              <AvGroup>
                <h2><Label for="search">Search Artists</Label></h2>
                <p>
                  Find artists you own and add them to your MusicList.
                </p>
                <AvInput
                  id="search"
                  name="search"
                  onChange={this.handleSearchChange}
                  onKeyPress={this.handleKeyPress}
                  placeholder="Lorde"
                  required
                  type="text"
                  value={this.state.searchText}
                />
                <AvFeedback>Required</AvFeedback>
              </AvGroup>
              <Button color="primary">Search Artists</Button>
            </AvForm>
          </div>
        </div>
        <div className="row">
          <div className="col-12 col-sm-12">
            { artists && artists.length > 0 ? <h2>Artists</h2> : null }
            <div className="row">
              <div className="col-sm-12 col-lg-12">
                { artists && artists.length > 0 ? this.createTable(artists) : null }
              </div>
            </div>
          </div>
        </div>
      </div>
    );
  }
}

.Anyway, one last file to edit
.Save this one, and let’s tell our Template that these new pages exist
.Head for /src/components/Template.jsx and, below line 4, add this code:

import ArtistsPage from './artists/ArtistsPageContainer';

          <Route exact path="/artists" component={ArtistsPage} />

.You’re good to go
.Save, and let’s test
.Head for a browser, navigate to localhost:3000, refresh the page, make sure you’re logged in, and then go to /artists
.Search for an artist you like, and they should come up
.Once they’re there, try adding one, and it should work just like the albums did
.Success!

#Five Minute React 73 - View a User's List

.First, open up /routes/api/users.js
.Add a padding line below line 5, and then we’re going to create a lookup routine which will return a username and any album and artist IDs associated with it
.Here’s the code:

// POST to /find
router.post('/find', (req, res, next) => {
  // Get the requested user
  User.findOne({ username: req.body.username }, (err, user) => {
    if (err) {
      return res.json({ error: err });
    }
    if (!user) {
      return res.json({ error: 'Username not found' });
    }
    const { username, albums, artists } = user;
    return res.json({ username, albums, artists });
  });
});

.That’s all we need here
.Save the file and then open /routes/api/albums.js
.If you have an accidental padding line after line 143, delete that, which will make ESLint stop complaining
.Then, below that final closing brace (now on line 144), add a padding line, and this code:

// POST to /populate
router.post('/populate', (req, res, next) => {
  // Get album data from an array
  Album.find({
    discogsId: { $in: req.body },
  }, (err, albums) => {
    if (err) {
      return res.json({ error: err.message });
    }
    return res.json(albums);
  });
});

.This will take a list of Album IDs and get the full album data for each one, then send it back as JSON
.Sweet
.Save this file, and let’s do the same thing for artists
.Open up /routes/api/artists.js and add a padding line below line 84, followed by this code:

// GET to /populate
router.post('/populate', (req, res, next) => {
  // Get artist data from an array
  Artist.find({
    discogsId: { $in: req.body },
  }, (err, artists) => {
    if (err) {
      return res.json({ error: err.message });
    }
    return res.json(artists);
  });
});

.Save the file and our API is set for now
.Head for /src/actions/albums.js
.Below line 10, add these two action creators:

export const albumsPopulateFailure = error => ({ type: 'MUSIC_ALBUMS_POPULATE_FAILURE', error });
export const albumsPopulateSuccess = json => ({ type: 'MUSIC_ALBUMS_POPULATE_SUCCESS', json });

.Then, below line 54, add a padding line, and our populateAlbums function:

// Populate Album data
export function populateAlbums(albums) {
  return async (dispatch) => {
    // clear the error box if it's displayed
    dispatch(clearError());

    // turn on spinner
    dispatch(incrementProgress());

    // Hit the API
    await fetch(
      '/api/albums/populate',
      {
        method: 'POST',
        body: JSON.stringify(albums),
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'same-origin',
      },
    )
    .then((response) => {
      if (response.status === 200) {
        return response.json();
      }
      return null;
    })
    .then((json) => {
      if (!json.error) {
        return dispatch(albumsPopulateSuccess(json));
      }
      return dispatch(albumsPopulateFailure(new Error(json.error)));
    })
    .catch(error => dispatch(albumsPopulateFailure(new Error(error))));

    // turn off spinner
    return dispatch(decrementProgress());
  };
}

.This hits the API route we just set up that returns full album data
.We need to do the same thing for artists, so save this file and open /src/actions/artists.js
.Once again, below line 10, add two action creators:

export const artistsPopulateFailure = error => ({ type: 'MUSIC_ARTISTS_POPULATE_FAILURE', error });
export const artistsPopulateSuccess = json => ({ type: 'MUSIC_ARTISTS_POPULATE_SUCCESS', json });

// Populate Artist data
export function populateArtists(artists) {
  return async (dispatch) => {
    // clear the error box if it's displayed
    dispatch(clearError());

    // turn on spinner
    dispatch(incrementProgress());

    // Hit the API
    await fetch(
      '/api/artists/populate',
      {
        method: 'POST',
        body: JSON.stringify(artists),
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'same-origin',
      },
    )
    .then((response) => {
      if (response.status === 200) {
        return response.json();
      }
      return null;
    })
    .then((json) => {
      if (!json.error) {
        return dispatch(artistsPopulateSuccess(json));
      }
      return dispatch(artistsPopulateFailure(new Error(json.error)));
    })
    .catch(error => dispatch(artistsPopulateFailure(new Error(error))));

    // turn off spinner
    return dispatch(decrementProgress());
  };
}

.Save the file, and create a new file in /src/actions called users.js
.We’re going to use this to do a user lookup, and to clear the user’s list whenever that component unmounts
.Here’s the code in its entirety:

import 'whatwg-fetch';
import { decrementProgress, incrementProgress } from './progress';
import { clearError } from './error';

// Action Creators
export const userClearList = () => ({ type: 'USER_CLEAR_LIST' });
export const userLookupFailure = error => ({ type: 'USER_LOOKUP_FAILURE', error });
export const userLookupSuccess = json => ({ type: 'USER_LOOKUP_SUCCESS', json });

// Look up a user
export function userLookup(username) {
  return async (dispatch) => {
    // clear the error box if it's displayed
    dispatch(clearError());

    // turn on spinner
    dispatch(incrementProgress());

    // API call
    await fetch(
      '/api/users/find',
      {
        method: 'POST',
        body: JSON.stringify({ username }),
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'same-origin',
      },
    )
    .then((response) => {
      if (response.status === 200) {
        return response.json();
      }
      return null;
    })
    .then((json) => {
      if (json.username) {
        return dispatch(userLookupSuccess(json));
      }
      return dispatch(userLookupFailure(new Error(json.error)));
    })
    .catch(error => dispatch(userLookupFailure(new Error(error))));

    // turn off spinner
    return dispatch(decrementProgress());
  };
}

.This stuff should all be old hat for you at this point! Save this file, and let’s make some reducers
.In fact, let’s start with a brand new “list” reducer
.In /src/reducers create a file called list.js and add this code to it:

const initialState = {
  username: '',
  albums: [],
  albumsPopulated: [],
  artists: [],
  artistsPopulated: [],
};

export default function reducer(state = initialState, action) {
  switch (action.type) {
    case 'MUSIC_ALBUMS_POPULATE_FAILURE': {
      const newState = Object.assign({}, state);
      newState.albumsPopulated = [];
      return newState;
    }
    case 'MUSIC_ALBUMS_POPULATE_SUCCESS': {
      const newState = Object.assign({}, state);
      newState.albumsPopulated = action.json;
      return newState;
    }
    case 'MUSIC_ARTISTS_POPULATE_FAILURE': {
      const newState = Object.assign({}, state);
      newState.artistsPopulated = [];
      return newState;
    }
    case 'MUSIC_ARTISTS_POPULATE_SUCCESS': {
      const newState = Object.assign({}, state);
      newState.artistsPopulated = action.json;
      return newState;
    }
    case 'USER_CLEAR_LIST':
    case 'USER_LOOKUP_FAILURE': {
      const newState = Object.assign({}, initialState);
      return newState;
    }
    case 'USER_LOOKUP_SUCCESS': {
      const newState = Object.assign({}, state);
      newState.username = action.json.username;
      newState.albums = action.json.albums;
      newState.artists = action.json.artists;
      return newState;
    }
    default: {
      return state;
    }
  }
}

.Just to keep things clear: albums and artists will contain simply an array of Discogs IDs
.albumsPopulated and artistsPopulated will contain the full album and artist data that we look up via our API, using those IDs.

.Save this file, and open up /src/reducers/error.js
.Make sure your big list of cases starting on line 8 is alphabetized, and then under line 14 add this case:

    case 'MUSIC_ALBUMS_POPULATE_FAILURE':

    case 'MUSIC_ARTISTS_POPULATE_FAILURE':
    case 'USER_LOOKUP_FAILURE': {

.Save this file and move on to /src/reducers/index.js
.Under line 5, import our new reducer like this:

import ListReducer from '../reducers/list';

  list: ListReducer,

.Save that file, and we’re headed into the home stretch
.Time to build some components! First off, in /src/components, create a new folder called list
.Within that folder, create a file called ListPageContainer.jsx
.Here are our imports and the opening of the class:

import React from 'react';
import { bindActionCreators } from 'redux';
import { connect } from 'react-redux';
import { populateAlbums } from '../../actions/albums';
import { populateArtists } from '../../actions/artists';
import { userClearList, userLookup } from '../../actions/users';

import ListPage from './ListPage';

class ListPageContainer extends React.Component {
  constructor(props) {
    super(props);

    this.state = {
      albumsChecked: false,
      artistsChecked: false,
    };
  }

  componentWillMount() {
    // Before the component mounts, look up the user
    const { match, userLookupFunction } = this.props;
    userLookupFunction(match.params.username);
  }

  componentWillReceiveProps(nextProps) {
    const { populateAlbumsFunction, populateArtistsFunction } = this.props;
    const { list } = nextProps;
    if (list.username !== '' && !this.state.albumsChecked) {
      populateAlbumsFunction(list.albums);
      this.setState({ albumsChecked: true });
    }
    if (list.username !== '' && !this.state.artistsChecked) {
      this.setState({ artistsChecked: true });
      populateArtistsFunction(list.artists);
    }
  }

  componentWillUnmount() {
    const { userClearListFunction } = this.props;
    userClearListFunction();
  }

  render() {
    const { list } = this.props;
    if (list.username === '') {
      return (<p />);
    }

    return (
      <ListPage
        username={list.username}
        albums={list.albumsPopulated}
        artists={list.artistsPopulated}
      />
    );
  }
}

const mapDispatchToProps = dispatch => bindActionCreators({
  populateAlbumsFunction: populateAlbums,
  populateArtistsFunction: populateArtists,
  userClearListFunction: userClearList,
  userLookupFunction: userLookup,
  dispatch,
}, dispatch);

const mapStateToProps = state => ({
  list: state.list,
});

export default connect(mapStateToProps, mapDispatchToProps)(ListPageContainer);

.Save this file and let’s build some simple display routines
.Create a file in /src/components/list called ListPage.jsx, and add the following code:

import React from 'react';

const formatAlbums = albums => albums.map(album => (
  <p key={album.discogsId}>
    <em>{album.title}</em> by
    {album.artists[0].name}
  </p>
));
const formatArtists = artists => artists.map(artist => <p key={artist.discogsId}>{artist.name}</p>);

export default class ArtistsPage extends React.Component {
  constructor(props) {
    super(props);
  }

  render() {
    const { username, albums, artists } = this.props;
    return (
      <div className="row">
        <div className="col-12 col-sm-12">
          <h2>{ username }‘s Profile</h2>
          <h3>Artists They Like</h3>
          <div>
            { artists.length > 0 ? formatArtists(artists) : null }
          </div>
          <h3>Albums They Own</h3>
          <div>
            { albums.length > 0 ? formatAlbums(albums) : null }
          </div>
        </div>
      </div>
    );
  }
}

.Save this file and open /src/components/Template.jsx
.Under line 9, add this code:

import ListPage from './list/ListPageContainer';

          <Route path="/list/:username" component={ListPage} />

#Five Minute React 74 - Improving Music Lists

.Let’s start with some CSS that’ll come in handy
.Open /src/css/musiclist.scss and, at the end of the file, add this code:

/* Flexbox tables */
table.flex {
  tr {
    display: flex;

    th, td {
      flex-basis: 25%;

      &.thumb {
        flex-basis: auto;
        width: 100px;
        text-align: center;
        padding: 10px;

        img {
          width: 80px;
        }
      }
    }
  }
}

.Now let’s make those tables
.Save this file and open /src/components/list/ListPageContainer.jsx
.We need to pass some authentication information down to our component
.Below line 68, grab authentication from the Store like this:

  authentication: state.authentication,

    const { authentication, list } = this.props;

        authentication={authentication}

.Save this file and open /src/components/list/ListPage.jsx
.We’re going to add two methods here that are similar to ones we wrote for the artists and albums pages, and generate a table
.However, these methods will be smart enough to take a list of either of those two things and generate a table from them
.This is, obviously, a better approach that writing four separate methods, two for artists and two for albums
.We need to import some stuff from ReactStrap, so, below line 1, add this code:

import { Button, Table } from 'reactstrap';

  createTable(items) {
    return (
      <Table striped responsive className="flex">
        <thead>
          <tr>
            <th className="thumb" />
            <th>{ items.type === 'album' ? 'Title' : 'Name' }</th>
            <th>{ items.type === 'album' ? 'Artist' : 'Active Members' }</th>
            <th>{ items.type === 'album' ? 'Genre(s)' : ' ' }</th>
            <th />
          </tr>
        </thead>
        <tbody>
          { this.listItems(items) }
        </tbody>
      </Table>
    );
  }

.Now, below that method, which ends on line 34, add a padding line, and then our listItems method, like this:

  listItems(items) {
    const { authentication, username } = this.props;
    return items.list.map(item =>
      (
        <tr key={item.discogsId}>
          <td className="thumb"><img src={item.images[0] ? item.images[0].uri : ''} alt="item thumbnail" /></td>
          <td>{ items.type === 'album' ? item.title : item.name }</td>
          <td>{ items.type === 'album' ? item.artists[0].name : formatMembers(item.members) }</td>
          <td>{ items.type === 'album' ? formatGenre(item.genres) : ' ' }</td>
          <td>
            { username === authentication.username ?
              <Button
                color="secondary"
                onClick={() => this.deleteItem(item.discogsId, items.type)}
                outline
              >
                Remove From List
              </Button> :
              null
            }
          </td>
        </tr>
      ));
  }

.You may also note that this uses several functions that don’t actually exist yet, such as formatMembers
.Let’s fix that
.Up at the top of the file, from lines 4 to 10, we’ve got some basic formatting functions
.We’re going to nuke those in favor of the more specific ones called by our new methods
.So highlight this entire block:

const formatAlbums = albums => albums.map(album => (
  <p key={album.discogsId}>
    <em>{album.title}</em> by
    {album.artists[0].name}
  </p>
));
const formatArtists = artists => artists.map(artist => <p key={artist.discogsId}>{artist.name}</p>);

const formatGenre = discogsGenre => discogsGenre.join(', ');
const formatMembers = (discogsMembers) => {
  const activeMembers = discogsMembers.filter(member => member.active);
  const memberNames = activeMembers.map(member => member.name);
  return memberNames.join(', ');
};

.Now we’re going to create a not-yet-implemented deleteItem method
.Below our constructor, which now ends on line 14, add a padding line, and this code:

  deleteItem(id, type) {
    console.log(id, type);
  }

    const albumsFormatted = { type: 'album', list: albums };
    const artistsFormatted = { type: 'artist', list: artists };

            { artists && artists.length > 0 ? this.createTable(artistsFormatted) : null }

            { albums && albums.length > 0 ? this.createTable(albumsFormatted) : null }

.You should be good to go, here, so let’s make sure things are working
.Save the file, head for a browser, and visit localhost:3000/list/yourusername
.You should see the artists and albums you’ve added, now in a prettier format
.If you log in, you should also see delete buttons, which will console log some information when you click them.

.Open /src/components/shared/Header.jsx and, first, change line 45 to these three lines:

          <span className="nav-link">Welcome, {name}
           | <a href="/logout" onClick={this.logOutClick}>Log Out</a>
          </span>

.Yes, it’s a little weird to wrap non-link text in a nav-link class, but it’ll help keep things looking right.

    const { isLoggedIn, firstName, username } = this.props.authentication;

            <Nav className="ml-auto" navbar>
              <NavItem>
                <NavLink tag={Link} to="/albums">Albums</NavLink>
              </NavItem>
              <NavItem>
                <NavLink tag={Link} to="/artists">Artists</NavLink>
              </NavItem>
              { username && username !== '' ?
                <NavItem>
                  <NavLink tag={Link} to={`/list/${username}`}>My List</NavLink>
                </NavItem>
              : null }
            </Nav>

.We’ve got a little more time so let’s make one more improvement
.Save this file and then open /src/components/artists/ArtistsPageContainer.jsx
.Right now the artist search page shows “add to my list” buttons even when a user’s not logged in
.That sucks! To fix it, we need to pass down authentication as a prop, so change line 33 to these five lines:

const mapStateToProps = state => ({
  authentication: state.authentication,
  artists: state.artists,
  user: state.user,
});

    const { addArtistFunction, authentication, artists, searchArtistsFunction, user } = this.props;

        authentication={authentication}

.Save that file and open /src/components/artists/ArtistsPage.jsx
.Add a padding line below line 57 and then add this method:

  generateButton(user, artist) {
    return (
      user.artists.indexOf(artist.id) < 0 ?
        <Button color="primary" outline id={artist.id} onClick={this.addArtist}>
          Add To My List
        </Button> :
        <span>Already Listed</span>
    );
  }

    const { user, authentication } = this.props;

          <td>{authentication.username.length > 0 ? this.generateButton(user, artist) : null}</td>

.Save the file, and open /src/components/albums/AlbumsPageContainer.jsx
.We’re going to do exactly the same thing here
.Change line 33 to this:

const mapStateToProps = state => ({
  albums: state.albums,
  authentication: state.authentication,
  user: state.user,
});

    const { addAlbumFunction, albums, authentication, searchAlbumsFunction, user } = this.props;

        authentication={authentication}

.Save the file, and hop over to /src/components/albums/AlbumsPage.jsx
.Same deal here: identical changes
.First, add a padding line below line 63 and then our generateButton function like this:

  generateButton(user, album) {
    return (
      user.albums.indexOf(album.id) < 0 ?
        <Button color="primary" outline id={album.id} onClick={this.addAlbum}>
          Add To My List
        </Button> :
        <span>Already Listed</span>
    );
  }

    const { authentication, user } = this.props;

          <td>{authentication.username.length > 0 ? this.generateButton(user, album) : null}</td>

#Five Minute React 75 - Wire Up Remove Buttons

.Open /routes/api/albums.js and head for line 144, which ends our getArtists method
.Below it, add a padding line and the following route code:

// POST to /delete
router.post('/delete', (req, res, next) => {
  User.findOne({ username: req.user.username }, (err, foundUser) => {
    // Run filter against the array, returning only those that don't match the passed ID
    const newAlbums = foundUser.albums.filter(album => album !== req.body.albumId);
    foundUser.update({ $set: { albums: newAlbums } }, (error) => {
      if (error) {
        return res.json(JSON.stringify({ error: 'There was an error removing the album from the user\'s profile' }));
      }
      return res.json({ albums: newAlbums });
    });
  });
});

.We use a nice built-in method for JavaScript Arrays here, Array.filter, which lets you designate a function to check each value against, and builds a new array only out of those values which your function returns
.So in this case we run through the user’s list of album IDs and return all of them except the one we’re trying to delete
.Then we update the user in the database with the new, truncated list of albums.

.That’s it here
.Save the file, open /routes/api/artists.js, find line 84, and below it add the same exact thing except, well, for artists
.Here’s the code:

// POST to /delete
router.post('/delete', (req, res, next) => {
  User.findOne({ username: req.user.username }, (err, foundUser) => {
    // Run filter against the array, returning only those that don't match the passed ID
    const newArtists = foundUser.artists.filter(artist => artist !== req.body.artistId);
    foundUser.update({ $set: { artists: newArtists } }, (error) => {
      if (error) {
        return res.json(JSON.stringify({ error: 'There was an error removing the artist from the user\'s profile' }));
      }
      return res.json({ artists: newArtists });
    });
  });
});

.Save this file and we’re done on the backend
.Now we move on to actions, so open up /src/actions/albums.js
.Below line 7 add these two new action creators:

export const albumDeleteFailure = error => ({ type: 'MUSIC_ALBUM_DELETE_FAILURE', error });
export const albumDeleteSuccess = json => ({ type: 'MUSIC_ALBUM_DELETE_SUCCESS', json });

.And then add a padding line after line 56
.We’re going to create a deleteAlbum function which is also going to repopulate the albums in the Store once it runs, in order to keep what we’re seeing on the page in line with what’s happening at the database level
.Remember: the only thing stored in the user data is a list of album or artist IDs
.We have to run a populate with those IDs to get a list full of actual information.

// Delete an album from user's list
export function deleteAlbum(albumId) {
  return async (dispatch) => {
    // clear the error box if it's displayed
    dispatch(clearError());

    // turn on spinner
    dispatch(incrementProgress());

    // Hit the API
    await fetch(
      '/api/albums/delete',
      {
        method: 'POST',
        body: JSON.stringify({ albumId }),
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'same-origin',
      },
    )
    .then((response) => {
      if (response.status === 200) {
        return response.json();
      }
      return null;
    })
    .then((json) => {
      if (!json.error) {
        dispatch(populateAlbums(json.albums)); // eslint-disable-line
      }
      return json;
    })
    .then((json) => {
      if (!json.error) {
        return dispatch(albumDeleteSuccess(json));
      }
      return dispatch(albumDeleteFailure(new Error(json.error)));
    })
    .catch(error => dispatch(albumDeleteFailure(new Error(error))));

    // turn off spinner
    return dispatch(decrementProgress());
  };
}

.As you can see, we have an extra .then in which we run the album population and just pass the json along down the chain to be handled … unless there’s an error, in which case we don’t bother to repopulate because nothing has changed
.Also I disabled ESLint on that one line because it was complaining about populateAlbums coming after this function, but I prefer alphabetical order in my actions.

.Save this file and open /src/actions/artists.js
.Time to do the same exact thing here, except with artists
.Start by adding these two action creators below line 7:

export const artistDeleteFailure = error => ({ type: 'MUSIC_ARTIST_DELETE_FAILURE', error });
export const artistDeleteSuccess = json => ({ type: 'MUSIC_ARTIST_DELETE_SUCCESS', json });

// Delete an artist from user's list
export function deleteArtist(artistId) {
  return async (dispatch) => {
    // clear the error box if it's displayed
    dispatch(clearError());

    // turn on spinner
    dispatch(incrementProgress());

    // Hit the API
    await fetch(
      '/api/artists/delete',
      {
        method: 'POST',
        body: JSON.stringify({ artistId }),
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'same-origin',
      },
    )
    .then((response) => {
      if (response.status === 200) {
        return response.json();
      }
      return null;
    })
    .then((json) => {
      if (!json.error) {
        dispatch(populateArtists(json.artists)); // eslint-disable-line
      }
      return json;
    })
    .then((json) => {
      if (!json.error) {
        return dispatch(artistDeleteSuccess(json));
      }
      return dispatch(artistDeleteFailure(new Error(json.error)));
    })
    .catch(error => dispatch(artistDeleteFailure(new Error(error))));

    // turn off spinner
    return dispatch(decrementProgress());
  };
}

.Not much to say that hasn’t already been said, so let’s move on! Save the file, and let’s do some reducing
.Open /src/reducers/error.js first
.Below line 13, add this code:

    case 'MUSIC_ALBUM_DELETE_FAILURE':

    case 'MUSIC_ARTIST_DELETE_FAILURE':

.Save the file, and open /src/reducers/list.js
.We need to catch our delete actions here, so below line 10, add this code:

    case 'MUSIC_ALBUM_DELETE_SUCCESS': {
      const newState = Object.assign({}, state);
      newState.albums = action.json.albums;
      return newState;
    }

    case 'MUSIC_ARTIST_DELETE_SUCCESS': {
      const newState = Object.assign({}, state);
      newState.artists = action.json.artists;
      return newState;
    }

.Good! Rolling along
.Save this file, and open /src/reducers/user.js
.Remove the opening brace from line 15 and below it add this line:

    case 'MUSIC_ALBUM_DELETE_SUCCESS': {

    case 'MUSIC_ARTIST_DELETE_SUCCESS': {

.Save the file, and let’s make rocket go … open up /src/components/list/ListPageContainer.jsx
.Import our new functions by changing lines 4 and 5 to this:

import { deleteAlbum, populateAlbums } from '../../actions/albums';
import { deleteArtist, populateArtists } from '../../actions/artists';

  deleteAlbumFunction: deleteAlbum,
  deleteArtistFunction: deleteArtist,

    const { authentication, deleteAlbumFunction, deleteArtistFunction, list } = this.props;

        deleteAlbumFunction={deleteAlbumFunction}
        deleteArtistFunction={deleteArtistFunction}

.All good here
.Save the file, and open /src/components/list/ListPage.jsx
.The main thing we’re doing here is making our delete function actually do what we want it to, so replace lines 16 to 18 with the following code:

  deleteItem(id, type) {
    const { deleteAlbumFunction, deleteArtistFunction } = this.props;
    if (type === 'album') {
      deleteAlbumFunction(id);
    }
    if (type === 'artist') {
      deleteArtistFunction(id);
    }
  }

.In the next tutorial, we’re going to take a short break from writing component code to upgrade to the latest and greatest Node and React, as well as cleaning up our woefully neglected package.json file a bit
.See you there!

#Five Minute React 76 - Upgrade Node and React

.We’re going to do this in a slightly unorthodox way, in that we’re going to edit our package.json file and then reinstall our entire node_modules folder, which will also allow us to move a few dev dependencies into the proper place
.First things first, we need to delete our existing node_modules folder
.If you’re on a Mac, cd to your musiclist directory and type

rm -rf node_modules

rmdir /s /q node_modules

    "redux-devtools": "^3.4.0",

    "webpack-dev-middleware": "^1.11.0",
    "webpack-hot-middleware": "^2.18.0",

.And move them down as well
.They should go at the end of the devDependencies block, which means you need to add a comma to the end of line 65 (the supertest line), and remove the comma from line 67, the hot-middleware line you just pasted.

.So, open up /src/index.js and change line 29 to look this this:

.Head back to a terminal window
.Assuming you’re in your musiclist folder, you can just type:

$ npm

#Five Minute React 77 - Improving The Home Page

.First we’re going to build a little action that snags the latest album uploaded to Discogs, just for fun
.Head for /src/actions/albums.js and below line 9, add the following code:

export const albumLatestFailure = error => ({ type: 'MUSIC_ALBUM_LATEST_FAILURE', error });
export const albumLatestSuccess = json => ({ type: 'MUSIC_ALBUM_LATEST_SUCCESS', json });

.Then head down to line 104, add a padding line, and create a getLatestAlbum function like this:

// Get the latest album from the Discogs API
export function getLatestAlbum() {
  return async (dispatch) => {
    // turn on spinner
    dispatch(incrementProgress());

    // Build packet to send to Discogs API
    const searchQuery = {
      q: '',
      type: 'master',
      format: 'album',
      sort_order: 'asc',
    };

    // Send packet to our API, which will communicate with Discogs
    await fetch(
      // where to contact
      '/api/albums/search',
      // what to send
      {
        method: 'POST',
        body: JSON.stringify(searchQuery),
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'same-origin',
      },
    )
    .then((response) => {
      if (response.status === 200) {
        return response.json();
      }
      return null;
    })
    .then((json) => {
      if (json.results) {
        return dispatch(albumLatestSuccess(json.results[0]));
      }
      return dispatch(albumLatestFailure(new Error(json.error)));
    })
    .catch(error => dispatch(albumLatestFailure(new Error(error))));

    // turn off spinner
    return dispatch(decrementProgress());
  };
}

.So, create a file in /src/reducers named latest.js, and in it put the following code:

const initialState = {};
export default function reducer(state = initialState, action) {
  switch (action.type) {
    case 'MUSIC_ALBUM_LATEST_SUCCESS': {
      const newState = action.json;
      return newState;
    }
    case 'MUSIC_ALBUM_LATEST_FAILURE': {
      const newState = Object.assign({}, initialState);
      return newState;
    }
    default: {
      return state;
    }
  }
}

.We’re good here, so save the file and head for /src/reducers/index.js
.Underneath line 5, add this code:

import LatestReducer from '../reducers/latest';

  latest: LatestReducer,

.Save that file and we’re ready to go
.Open /src/components/home/HomePageContainer.jsx
.We’re going to get rid of those increment/decrement buttons, so we don’t need the associated actions anymore
.Change line 5 to this:

import { getLatestAlbum } from '../../actions/albums';

.Now let’s nuke our old mapDispatchToProps function entirely and replace it with an ES2015 version, and a mapStateToProps
.So remove lines 18 to 23, and replace them with this code:

const mapDispatchToProps = dispatch => bindActionCreators({
  getLatestAlbumFunction: getLatestAlbum,
  dispatch,
}, dispatch);
const mapStateToProps = state => ({ latestAlbum: state.latest });

export default connect(mapStateToProps, mapDispatchToProps)(HomePageContainer);

export class HomePageContainer extends React.Component {
  componentWillMount() {
    const { getLatestAlbumFunction } = this.props;
    getLatestAlbumFunction();
  }

  render() {
    const { latestAlbum } = this.props;
    return (
      <HomePage
        latestAlbum={latestAlbum}
      />
    );
  }
}

.We’re good here, so let’s drill on down
.Save the file and open /src/components/home/HomePage.jsx
.We’re going to put some text here, and pass our latest album info to the sidebar component
.First, change line 2 to the following:

import { Link } from 'react-router-dom';

  const { latestAlbum } = props;

        <h1>Welcome to MusicList</h1>
        <p>
          This is a simple React app where you can look up artists you like and albums you own,
          and add them to your list. Got rid of an album or decided you're not that fond of an
          artist? Just remove them.
        </p>
        <ul>
          <li><h2><Link to="/artists">Search Artists</Link></h2></li>
          <li><h2><Link to="/albums">Search Albums</Link></h2></li>
        </ul>

      <Sidebar latestAlbum={latestAlbum} />

.Done here, so save the file
.Open /src/components/shared/Sidebar.jsx
.Change line 2 to this:

import { Card, CardBlock, CardText, CardTitle } from 'reactstrap';

const formatAlbum = (album) => {
  if (!album) {
    return null;
  }

  return (
    <span className="text-center">
      <img src={album.thumb} alt="album thumb" /><br />
      { album.title }
    </span>
  );
};

export default function Sidebar(props) {

  const { latestAlbum } = props;

          <CardTitle className="text-center">Latest Album</CardTitle>

          <CardText className="text-center">
            { latestAlbum && latestAlbum.title ? formatAlbum(latestAlbum) : null }
          </CardText>

.That’s it for new stuff
.Save the file
.Now we’re going to clean up a few things
.Specifically, our album and artist search forms
.Open up /src/albums/AlbumsPage.jsx
.We don’t need the handleKeyPress method anymore
.Why not? Because when we switched over to Availity-Reactstrap for validation, we got enter handling thrown in as a bonus
.So delete line 17 entirely, and then delete lines 31 to 37, the handleKeyPress method and the padding line below it.

.We don’t have to add anything here, so save the file
.We're going to do this same thing with a bunch of other files
.Open /src/components/artists/ArtistsPage.jsx
.We’re doing the same thing here, so delete line 13, and then delete lines 27 to 33
.Save the file, then open /src/components/account/ChangePasswordPage.jsx, remove line 12, and then lines 26 to 32
.Save the file, and open /src/components/account/LoginPage.jsx, remove line 12 and then delete lines 27 to 32
.Save that file and open /src/components/account/RegisterPage.jsx, remove line 11 and then delete lines 28 to 34
.Save that file and, finally, open /src/components/account/ResetPasswordPage.jsx
.Delete line 12, and then nuke lines 40 to 45.

#Five Minute React 78 - Final Webpack Optimizations

$ npm add compression-webpack-plugin@1.0.1 compression@1.7.1

.Let that do its thing, and you’re good to go
.Head for Sublime, open up webpack.config.js, and let’s get started
.Below line 2, let’s import the module we just added, like this:

const CompressionPlugin = require('compression-webpack-plugin');

  module.exports.plugins.push(new webpack.optimize.UglifyJsPlugin({
    compress: {
      warnings: false,
      screw_ie8: true,
      conditionals: true,
      unused: true,
      comparisons: true,
      sequences: true,
      dead_code: true,
      evaluate: true,
      if_return: true,
      join_vars: true,
    },
    output: {
      comments: false,
    },
  }));

  module.exports.plugins.push(new webpack.HashedModuleIdsPlugin());

  module.exports.plugins.push(new webpack.optimize.ModuleConcatenationPlugin());

  module.exports.plugins.push(
    new webpack.DefinePlugin(
      { 'process.env.NODE_ENV': JSON.stringify('production') },
    ),
  );

  module.exports.plugins.push(
    new CompressionPlugin({
      asset: '[path].gz[query]',
      algorithm: 'gzip',
      test: /\.js$|\.css$|\.html$|\.eot?.+$|\.ttf?.+$|\.woff?.+$|\.svg?.+$/,
      threshold: 10240,
      minRatio: 0.8,
    }),
  );

.Speaking of our webserver, we need to make a few minor changes there
.Save this file, and open app.js
.Below line 3, add the following:

const compression = require('compression');

app.use(compression());

$ npm start

and wait for the webpack output to run, then scroll up a bit, and you can see the file sizes. I get 4.59 MB for build.js and 194 KB for style.css. That’s … that’s unfortunate. Real unfortunate. Let’s see how the production build’s doing. ctrl-c out of your dev server and type:

$ npm run build-prod

.Let that do its thing, and then scroll up a bit
.TAKE A LOOK AT THOSE NUMBERS! Even without compression, we’ve got build.js down to 1.09 MB, which is over a 400% reduction, and 149 KB for style.css, which is, well, a mild reduction anyway
.But it’s the gzipped numbers that really stand out
.style.css drops down to 20.5 KB, and build.js falls all the way to an astounding 263 KB
.That’s a reduction of 1750%, which is fantastic
.We’ve reduced our bundle size by more than 17 times, and brought it down to a number that’ll be pretty speedy even on a 3G connection.

#Five Minute React 79 - Securing Express

$ npm add helmet@3.9.0

.While that runs, switch to Sublime, open /app.js, and under line 11 add this code:

const helmet = require('helmet');

app.use(helmet());

.That’s all we have to do, so save the file
.Next up on Express’s list is “Use cookies securely”
.This is, obviously, another good suggestion
.To use secure cookies with our session manager, Express-Session, we’re going to need to have TLS enabled on our server
.We can make some changes now to app.js to prepare for this, though (and to allow us to continue to work with insecure cookies on our dev server).

const expressSession = require('express-session');

.Now we’re going to work on express session, which is in the big chunk of app.use calls starting on line 40
.Normally I'd move this into its own section, but it needs to happen before the passport initialization or our app will break, so just take line 45 and expand it to all of this stuff:

// Express Session
const sessionValues = {
  cookie: {},
  name: 'sessionId',
  resave: false,
  saveUninitialized: true,
  secret: appConfig.expressSession.secret,
};
if (app.get('env') === 'production') {
  app.set('trust proxy', 1);
  sessionValues.cookie.secure = true;
}
app.use(expressSession(sessionValues));

$ npm install -g snyk

snyk auth

snyk test

.It’ll run for a while, and then output a whole ton of scary errors, most of them low severity, a few of them high
.So, here's the deal … in a real world application, what I'd recommend doing next is running snyk's wizard command, which will try to patch up as many of these issues as it can, and allow you to set 30-day reminders for those that don't have fixes yet
.The problem is: generally the solution to fixing vulnerabilities is to upgrade various modules, and that's something we don't want to do for the purposes of this tutorial
.In particular, it's going to recommend upgrading both Bootstrap and Express, the former of which is going to introduce minor visual issues, and the latter of which is going to potentially break your web server.

$ npm add express-rate-limit@2.9.0

.Let that run, then switch to sublime, open app.js, and below line 13 add this code:

const RateLimit = require('express-rate-limit');

// configure rate limiter
const apiLimiter = new RateLimit({
  windowMs: 1 * 60 * 1000, // 1 minute
  max: 50,
  delayMs: 0, // disabled
});
app.use('/api/', apiLimiter);

$ npm add dompurify@1.0.2 jsdom@11.5.1

.When it’s done, head for Sublime and open /routes/api/authentication.js
.Below line 1, add this code:

const createDOMPurify = require('dompurify');

const { JSDOM } = require('jsdom');

.Now head for your register routine on line 53
.Below line 61, add the following code:

    // sanitize data
    const window = (new JSDOM('')).window;
    const DOMPurify = createDOMPurify(window);
    const sanitizedBody = {
      username: DOMPurify.sanitize(req.body.username),
      email: DOMPurify.sanitize(req.body.email),
      firstName: DOMPurify.sanitize(req.body.firstName),
      lastName: DOMPurify.sanitize(req.body.lastName),
      password: req.body.password,
    };

    const newUser = new User(sanitizedBody);

        return res.send(JSON.stringify({ error: err.message }));

#Five Minute React 80 - Set Up a Server

  ssh-keygen -t rsa

#Five Minute React 81 - Create a Superuser

.Mac folks, here’s how you do this: open up a new terminal window, type ssh root@[your server’s ip], and hit enter
.That’s it
.Make sure you add the root username, though, or you’ll get an SSH error and be unable to connect
.If this is your first time connecting, you may be asked whether you want to trust this server (the answer is yes)
.Then you’ll be asked to enter your SSH key passphrase.

adduser [username]

where [username] is, of course, whatever username you want to use. Please do not use [username] as your username! I’m going to go with “cwbuecheler” because that is the username I use basically everywhere. You won’t believe this, but it’s rarely taken …

usermod -aG sudo [username]

su - [username]

cd /var

sudo mkdir www

ls -lsa

.To get a complete listing of folders and files with attributes, which show that the owner of www is root, even though we created it with our new user
.That’s the power of sudo.

sudo cp -r /root/.ssh /home/[username]

sudo chown -R [username]:[username] /home/[username]/.ssh

.Again, [username] should be the username you just set up and are currently logged in as
.So for example I would type:

sudo chown -R cwbuecheler:cwbuecheler .ssh

.All set? Good
.Now type logout
.You’ll see that returns you to root, so type logout again to end the SSH session completely
.Mac users, you can type the following to reconnect using your new user account:

ssh [username]@[your server’s ip]

#Five Minute React 82 - Merging to Master

cd /var/www

sudo mkdir musiclist

sudo git clone [your repo URL] musiclist

ls -lsa

#Five Minute React 83 - Install Node and MongoDB

cd ~
curl -sL https://deb.nodesource.com/setup_8.x -o nodesource_setup.sh

sudo bash nodesource_setup.sh

.You’ll need your sudo password for this, obviously
.Once you’ve run the script, Ubuntu’s built-in apt-get package manager will be prepared to download the proper version of Node, so type the following:

sudo apt-get install nodejs

sudo apt-get install build-essential

sudo npm install -g pm2 npm

cd /var/www/musiclist

sudo npm

to install your modules. This will also auto-run snyk-protect to apply security patches. It takes a couple of minutes, so don’t worry that it’s hanging.

.We’re almost done here! We need to manually create our config.json file because it’s not stored in github
.You can use the text editor of your choice here … vi, emacs, pico, nano … we could either fight all day about which one’s the best, or we could not give a crap
.I’m opting for the latter approach! If you have no preference, I suggest nano, because it’s easy
.Type the following:

sudo nano config.json

.You’ll be taken to a rudimentary-looking text editor
.From here, you can just paste in the content from the config.json file on your local machine
.If you’re using PuTTY, right-clicking pastes
.If you’re using the OSX SSH client, then it’s just cmd-v as normal.

.To save the file hit ctrl-x (NOT cmd-x) to exit the program
.It’ll ask if you want to save before exiting, so just hit y and move on.

pm2 startup systemd

sudo env PATH=$PATH:/usr/bin /usr/lib/node_modules/pm2/bin/pm2 startup systemd -u [yourusername] --hp /home/[yourusername]

sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 0C49F3730359A14518585931BC711F9BA15703C6

gpg: Total number processed: 1
gpg:               imported: 1  (RSA: 1)

echo "deb [ arch=amd64,arm64 ] http://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/3.4 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-3.4.list

sudo apt-get update

.This will make sure apt-get is prepared to install MongoDB, which is what we’re going to do next
.So type in this command:

sudo apt-get install -y mongodb-org

.Protip: that -y skips the “do you want to use the disk space?” question
.Once that’s done installing, let’s start it with systemctl, which will run it as a background service
.Here’s how:

sudo systemctl start mongod

sudo systemctl status mongod

.Which will output a whole bunch of information, the most important of which is the green “active (running)” part
.Our final step is making sure systemctl starts Mongo back up when the server restarts
.Do that with this line:

sudo systemctl enable mongod

#Five Minute React 84 - Secure MongoDB and Finalize

mongo

.So let’s create a user
.We do that by first switching to the admin db, which was auto-generated when we installed MongoDB
.We do that by typing:

use admin

db.createUser({ user: "administrator", pwd: "yourchosenpasswordgoeshere", roles: [ { role: "root", db: "admin" } ] })

.Obviously, “yourchosenpasswordgoeshere” should be the actual password you want associated with this admin account
.Warning: do not use a password with an @ sign in it, or it’ll break your MongoDB connection string later
.Found that out the hard way! Additionally, you don’t have to use the name “administrator” … that can be whatever you want.

.Hit enter and create that user
.They’re now a part of MongoDB, but not a required part
.To make them required, we need to head back to the command line, so type exit and press enter to exit the Mongo terminal
.Now we’re going to use nano again to edit our config file, with this command:

sudo nano /etc/mongod.conf

.You will, of course, need your sudo password for this
.Head down to the section marked #security and, first things first, delete that hashmark, which will uncomment the section
.Then add the following code on the line directly below:

  authorization: "enabled"

security:
  authorization: "enabled"

.Hit ctrl-x to exit and answer yes that you want to save the file
.Now we need to restart MongoDB to get this change applied, so do that with the following command:

sudo systemctl restart mongod

sudo systemctl status mongod

.We can check that regular users no longer have access by returning to the MongoDB console (using mongo), and then trying the show dbs command again
.Instead of showing the available databases, this will now throw an error, which is what we want
.Quit out of the console (exit), and then log in using your newly created administrative user, like this:

mongo -u administrator -p --authenticationDatabase admin

.Obviously, if you used a different username, put that in there instead
.You’ll be asked for your password, so enter that, and then run show dbs again
.If all has gone well, you’ll see your databases
.Success!

.Just cd to /var/www/musiclist and then type the following:

sudo nano config.json

"mongodb": {
    "user": "administrator",
    "password": "yourpasswordgoeshere"
  },

"port": "80"

.Now save the file—you know the drill by now, ctrl-x and then y and then enter
.Then type:

sudo nano config.js

exports.mongodb = parsed.mongodb;

sudo nano app.js

mongoose.connect(`mongodb://${appConfig.mongodb.user}:${appConfig.mongodb.password}@localhost/musiclist?authSource=admin`, { useMongoClient: true });

    sessionValues.cookie.secure = true;

  // sessionValues.cookie.secure = true;

sudo nano bin/www

var app = require('../app');

var appConfig = require('../config.js');

var port = normalizePort(process.env.PORT || '3000');

var port = normalizePort(process.env.PORT || appConfig.port);

sudo npm run build-prod

sudo fallocate -l 4G /swapfile && sudo chmod 600 /swapfile

sudo mkswap /swapfile && sudo swapon /swapfile

sudo swapon --show

sudo npm run build-prod

sudo apt-get install libcap2-bin

sudo setcap cap_net_bind_service=+ep `readlink -f `which node``

sudo chmod 777 ~/.babel.json

sudo pm2 start --name musiclist npm -- run start-prod --

sudo pm2 list

